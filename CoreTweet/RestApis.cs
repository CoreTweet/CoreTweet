// This file was automatically generated by CoreTweet.
// Do not modify this file directly.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Linq.Expressions;
using CoreTweet.Core;

using System.Threading;
using System.Threading.Tasks;

#pragma warning disable RECS0163

namespace CoreTweet.Rest
{
    /// <summary>
    /// Provides a set of methods for the wrapper of GET/POST account.
    /// </summary>
    public partial class Account : ApiProviderBase
    {
        internal Account(TokensBase e) : base(e) { }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a representation of the requesting user if authentication was successful.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_email (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse VerifyCredentials(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "account/verify_credentials", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a representation of the requesting user if authentication was successful.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_email (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse VerifyCredentials(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "account/verify_credentials", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a representation of the requesting user if authentication was successful.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_email (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse VerifyCredentials(object parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "account/verify_credentials", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a representation of the requesting user if authentication was successful.</para>
        /// </summary>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_email">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse VerifyCredentials(bool? include_entities = null, bool? skip_status = null, bool? include_email = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_email != null) parameters.Add("include_email", include_email);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "account/verify_credentials", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns a representation of the requesting user if authentication was successful.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_email (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> VerifyCredentialsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "account/verify_credentials", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a representation of the requesting user if authentication was successful.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_email (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> VerifyCredentialsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "account/verify_credentials", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a representation of the requesting user if authentication was successful.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_email (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> VerifyCredentialsAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "account/verify_credentials", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a representation of the requesting user if authentication was successful.</para>
        /// </summary>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_email">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> VerifyCredentialsAsync(bool? include_entities = null, bool? skip_status = null, bool? include_email = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_email != null) parameters.Add("include_email", include_email);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "account/verify_credentials", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns settings (including current trend, geo and sleep time information) for the authenticating user or updates the authenticating user's settings.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> trend_location_woeid (optional)</para>
        /// <para>- <c>bool</c> sleep_time_enabled (optional)</para>
        /// <para>- <c>int</c> start_sleep_time (optional)</para>
        /// <para>- <c>int</c> end_sleep_time (optional)</para>
        /// <para>- <c>string</c> time_zone (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// <para>- <c>string</c> allow_contributor_request (optional)</para>
        /// <para>- <c>string</c> current_password (optional)</para>
        /// <para>- <c>string</c> allow_dms_from (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The settings of the user.</returns>
        public Setting Settings(params Expression<Func<string, object>>[] parameters)
        {
            return this.SettingsImpl(InternalUtils.ExpressionsToDictionary(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns settings (including current trend, geo and sleep time information) for the authenticating user or updates the authenticating user's settings.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> trend_location_woeid (optional)</para>
        /// <para>- <c>bool</c> sleep_time_enabled (optional)</para>
        /// <para>- <c>int</c> start_sleep_time (optional)</para>
        /// <para>- <c>int</c> end_sleep_time (optional)</para>
        /// <para>- <c>string</c> time_zone (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// <para>- <c>string</c> allow_contributor_request (optional)</para>
        /// <para>- <c>string</c> current_password (optional)</para>
        /// <para>- <c>string</c> allow_dms_from (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The settings of the user.</returns>
        public Setting Settings(IDictionary<string, object> parameters)
        {
            return this.SettingsImpl(parameters, "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns settings (including current trend, geo and sleep time information) for the authenticating user or updates the authenticating user's settings.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> trend_location_woeid (optional)</para>
        /// <para>- <c>bool</c> sleep_time_enabled (optional)</para>
        /// <para>- <c>int</c> start_sleep_time (optional)</para>
        /// <para>- <c>int</c> end_sleep_time (optional)</para>
        /// <para>- <c>string</c> time_zone (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// <para>- <c>string</c> allow_contributor_request (optional)</para>
        /// <para>- <c>string</c> current_password (optional)</para>
        /// <para>- <c>string</c> allow_dms_from (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The settings of the user.</returns>
        public Setting Settings(object parameters)
        {
            return this.SettingsImpl(InternalUtils.ResolveObject(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns settings (including current trend, geo and sleep time information) for the authenticating user or updates the authenticating user's settings.</para>
        /// </summary>
        /// <param name="trend_location_woeid">optional.</param>
        /// <param name="sleep_time_enabled">optional.</param>
        /// <param name="start_sleep_time">optional.</param>
        /// <param name="end_sleep_time">optional.</param>
        /// <param name="time_zone">optional.</param>
        /// <param name="lang">optional.</param>
        /// <param name="allow_contributor_request">optional.</param>
        /// <param name="current_password">optional.</param>
        /// <param name="allow_dms_from">optional.</param>
        /// <returns>The settings of the user.</returns>
        public Setting Settings(int? trend_location_woeid = null, bool? sleep_time_enabled = null, int? start_sleep_time = null, int? end_sleep_time = null, string time_zone = null, string lang = null, string allow_contributor_request = null, string current_password = null, string allow_dms_from = null)
        {
            var parameters = new Dictionary<string, object>();
            if(trend_location_woeid != null) parameters.Add("trend_location_woeid", trend_location_woeid);
            if(sleep_time_enabled != null) parameters.Add("sleep_time_enabled", sleep_time_enabled);
            if(start_sleep_time != null) parameters.Add("start_sleep_time", start_sleep_time);
            if(end_sleep_time != null) parameters.Add("end_sleep_time", end_sleep_time);
            if(time_zone != null) parameters.Add("time_zone", time_zone);
            if(lang != null) parameters.Add("lang", lang);
            if(allow_contributor_request != null) parameters.Add("allow_contributor_request", allow_contributor_request);
            if(current_password != null) parameters.Add("current_password", current_password);
            if(allow_dms_from != null) parameters.Add("allow_dms_from", allow_dms_from);
            return this.SettingsImpl(parameters, "1.1", null);
        }
        #endif

        /// <summary>
        /// <para>Returns settings (including current trend, geo and sleep time information) for the authenticating user or updates the authenticating user's settings.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> trend_location_woeid (optional)</para>
        /// <para>- <c>bool</c> sleep_time_enabled (optional)</para>
        /// <para>- <c>int</c> start_sleep_time (optional)</para>
        /// <para>- <c>int</c> end_sleep_time (optional)</para>
        /// <para>- <c>string</c> time_zone (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// <para>- <c>string</c> allow_contributor_request (optional)</para>
        /// <para>- <c>string</c> current_password (optional)</para>
        /// <para>- <c>string</c> allow_dms_from (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The settings of the user.</returns>
        public Task<Setting> SettingsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.SettingsAsyncImpl(InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, "1.1", null);
        }

        /// <summary>
        /// <para>Returns settings (including current trend, geo and sleep time information) for the authenticating user or updates the authenticating user's settings.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> trend_location_woeid (optional)</para>
        /// <para>- <c>bool</c> sleep_time_enabled (optional)</para>
        /// <para>- <c>int</c> start_sleep_time (optional)</para>
        /// <para>- <c>int</c> end_sleep_time (optional)</para>
        /// <para>- <c>string</c> time_zone (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// <para>- <c>string</c> allow_contributor_request (optional)</para>
        /// <para>- <c>string</c> current_password (optional)</para>
        /// <para>- <c>string</c> allow_dms_from (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The settings of the user.</returns>
        public Task<Setting> SettingsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.SettingsAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Returns settings (including current trend, geo and sleep time information) for the authenticating user or updates the authenticating user's settings.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> trend_location_woeid (optional)</para>
        /// <para>- <c>bool</c> sleep_time_enabled (optional)</para>
        /// <para>- <c>int</c> start_sleep_time (optional)</para>
        /// <para>- <c>int</c> end_sleep_time (optional)</para>
        /// <para>- <c>string</c> time_zone (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// <para>- <c>string</c> allow_contributor_request (optional)</para>
        /// <para>- <c>string</c> current_password (optional)</para>
        /// <para>- <c>string</c> allow_dms_from (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The settings of the user.</returns>
        public Task<Setting> SettingsAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.SettingsAsyncImpl(InternalUtils.ResolveObject(parameters), cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Returns settings (including current trend, geo and sleep time information) for the authenticating user or updates the authenticating user's settings.</para>
        /// </summary>
        /// <param name="trend_location_woeid">optional.</param>
        /// <param name="sleep_time_enabled">optional.</param>
        /// <param name="start_sleep_time">optional.</param>
        /// <param name="end_sleep_time">optional.</param>
        /// <param name="time_zone">optional.</param>
        /// <param name="lang">optional.</param>
        /// <param name="allow_contributor_request">optional.</param>
        /// <param name="current_password">optional.</param>
        /// <param name="allow_dms_from">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The settings of the user.</returns>
        public Task<Setting> SettingsAsync(int? trend_location_woeid = null, bool? sleep_time_enabled = null, int? start_sleep_time = null, int? end_sleep_time = null, string time_zone = null, string lang = null, string allow_contributor_request = null, string current_password = null, string allow_dms_from = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(trend_location_woeid != null) parameters.Add("trend_location_woeid", trend_location_woeid);
            if(sleep_time_enabled != null) parameters.Add("sleep_time_enabled", sleep_time_enabled);
            if(start_sleep_time != null) parameters.Add("start_sleep_time", start_sleep_time);
            if(end_sleep_time != null) parameters.Add("end_sleep_time", end_sleep_time);
            if(time_zone != null) parameters.Add("time_zone", time_zone);
            if(lang != null) parameters.Add("lang", lang);
            if(allow_contributor_request != null) parameters.Add("allow_contributor_request", allow_contributor_request);
            if(current_password != null) parameters.Add("current_password", current_password);
            if(allow_dms_from != null) parameters.Add("allow_dms_from", allow_dms_from);
            return this.SettingsAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        #if !NETSTANDARD1_3
        private Setting SettingsImpl(IEnumerable<KeyValuePair<string, object>> parameters, string urlPrefix, string urlSuffix)
        {
            var param = parameters.ToArray();
            return this.Tokens.AccessApiImpl<Setting>(param.Any() ? MethodType.Post : MethodType.Get, "account/settings", param, "", urlPrefix, urlSuffix);
        }
        #endif
        private Task<Setting> SettingsAsyncImpl(IEnumerable<KeyValuePair<string, object>> parameters, CancellationToken cancellationToken, string urlPrefix, string urlSuffix)
        {
            var param = parameters.ToArray();
            return this.Tokens.AccessApiAsyncImpl<Setting>(param.Any() ? MethodType.Post : MethodType.Get, "account/settings", param, cancellationToken, "", urlPrefix, urlSuffix);
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Sets values that users are able to set under the "Account" tab of their settings page.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> url (optional)</para>
        /// <para>- <c>string</c> location (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// <para>- <c>string</c> profile_link_color (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfile(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Sets values that users are able to set under the "Account" tab of their settings page.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> url (optional)</para>
        /// <para>- <c>string</c> location (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// <para>- <c>string</c> profile_link_color (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfile(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Sets values that users are able to set under the "Account" tab of their settings page.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> url (optional)</para>
        /// <para>- <c>string</c> location (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// <para>- <c>string</c> profile_link_color (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfile(object parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Sets values that users are able to set under the "Account" tab of their settings page.</para>
        /// </summary>
        /// <param name="name">optional.</param>
        /// <param name="url">optional.</param>
        /// <param name="location">optional.</param>
        /// <param name="description">optional.</param>
        /// <param name="profile_link_color">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfile(string name = null, string url = null, string location = null, string description = null, string profile_link_color = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(name != null) parameters.Add("name", name);
            if(url != null) parameters.Add("url", url);
            if(location != null) parameters.Add("location", location);
            if(description != null) parameters.Add("description", description);
            if(profile_link_color != null) parameters.Add("profile_link_color", profile_link_color);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Sets values that users are able to set under the "Account" tab of their settings page.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> url (optional)</para>
        /// <para>- <c>string</c> location (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// <para>- <c>string</c> profile_link_color (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Sets values that users are able to set under the "Account" tab of their settings page.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> url (optional)</para>
        /// <para>- <c>string</c> location (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// <para>- <c>string</c> profile_link_color (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Sets values that users are able to set under the "Account" tab of their settings page.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> url (optional)</para>
        /// <para>- <c>string</c> location (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// <para>- <c>string</c> profile_link_color (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Sets values that users are able to set under the "Account" tab of their settings page.</para>
        /// </summary>
        /// <param name="name">optional.</param>
        /// <param name="url">optional.</param>
        /// <param name="location">optional.</param>
        /// <param name="description">optional.</param>
        /// <param name="profile_link_color">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileAsync(string name = null, string url = null, string location = null, string description = null, string profile_link_color = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(name != null) parameters.Add("name", name);
            if(url != null) parameters.Add("url", url);
            if(location != null) parameters.Add("location", location);
            if(description != null) parameters.Add("description", description);
            if(profile_link_color != null) parameters.Add("profile_link_color", profile_link_color);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Updates the authenticating user’s profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image or media_id must be provided when making this request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>long</c> media_id (any one is required)</para>
        /// <para>- <c>bool</c> tile (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileBackgroundImage(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Updates the authenticating user’s profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image or media_id must be provided when making this request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>long</c> media_id (any one is required)</para>
        /// <para>- <c>bool</c> tile (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileBackgroundImage(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Updates the authenticating user’s profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image or media_id must be provided when making this request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>long</c> media_id (any one is required)</para>
        /// <para>- <c>bool</c> tile (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileBackgroundImage(object parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Updates the authenticating user’s profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image or media_id must be provided when making this request.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="tile">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileBackgroundImage(Stream image, bool? tile = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            parameters.Add("image", image);
            if(tile != null) parameters.Add("tile", tile);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Updates the authenticating user’s profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image or media_id must be provided when making this request.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="tile">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileBackgroundImage(IEnumerable<byte> image, bool? tile = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            parameters.Add("image", image);
            if(tile != null) parameters.Add("tile", tile);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Updates the authenticating user’s profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image or media_id must be provided when making this request.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="tile">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileBackgroundImage(FileInfo image, bool? tile = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            parameters.Add("image", image);
            if(tile != null) parameters.Add("tile", tile);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Updates the authenticating user’s profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image or media_id must be provided when making this request.</para>
        /// </summary>
        /// <param name="media_id">any one is required.</param>
        /// <param name="tile">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileBackgroundImage(long media_id, bool? tile = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("media_id", media_id);
            if(tile != null) parameters.Add("tile", tile);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Updates the authenticating user’s profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image or media_id must be provided when making this request.</para>
        /// </summary>
        /// <param name="tile">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileBackgroundImage(bool? tile = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(tile != null) parameters.Add("tile", tile);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Updates the authenticating user’s profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image or media_id must be provided when making this request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>long</c> media_id (any one is required)</para>
        /// <para>- <c>bool</c> tile (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileBackgroundImageAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Updates the authenticating user’s profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image or media_id must be provided when making this request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>long</c> media_id (any one is required)</para>
        /// <para>- <c>bool</c> tile (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileBackgroundImageAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Updates the authenticating user’s profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image or media_id must be provided when making this request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>long</c> media_id (any one is required)</para>
        /// <para>- <c>bool</c> tile (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileBackgroundImageAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Updates the authenticating user’s profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image or media_id must be provided when making this request.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="tile">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileBackgroundImageAsync(Stream image, bool? tile = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            parameters.Add("image", image);
            if(tile != null) parameters.Add("tile", tile);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Updates the authenticating user’s profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image or media_id must be provided when making this request.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="tile">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileBackgroundImageAsync(IEnumerable<byte> image, bool? tile = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            parameters.Add("image", image);
            if(tile != null) parameters.Add("tile", tile);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Updates the authenticating user’s profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image or media_id must be provided when making this request.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="tile">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileBackgroundImageAsync(FileInfo image, bool? tile = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            parameters.Add("image", image);
            if(tile != null) parameters.Add("tile", tile);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Updates the authenticating user’s profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image or media_id must be provided when making this request.</para>
        /// </summary>
        /// <param name="media_id">any one is required.</param>
        /// <param name="tile">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileBackgroundImageAsync(long media_id, bool? tile = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("media_id", media_id);
            if(tile != null) parameters.Add("tile", tile);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Updates the authenticating user’s profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image or media_id must be provided when making this request.</para>
        /// </summary>
        /// <param name="tile">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileBackgroundImageAsync(bool? tile = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(tile != null) parameters.Add("tile", tile);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>string</c> banner (any one is required)</para>
        /// <para>- <c>string</c> width (optional)</para>
        /// <para>- <c>string</c> height (optional)</para>
        /// <para>- <c>string</c> offset_left (optional)</para>
        /// <para>- <c>string</c> offset_top (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void UpdateProfileBanner(params Expression<Func<string, object>>[] parameters)
        {
            this.Tokens.AccessApiNoResponse(MethodType.Post, "account/update_profile_banner", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>string</c> banner (any one is required)</para>
        /// <para>- <c>string</c> width (optional)</para>
        /// <para>- <c>string</c> height (optional)</para>
        /// <para>- <c>string</c> offset_left (optional)</para>
        /// <para>- <c>string</c> offset_top (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void UpdateProfileBanner(IDictionary<string, object> parameters)
        {
            this.Tokens.AccessApiNoResponse(MethodType.Post, "account/update_profile_banner", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>string</c> banner (any one is required)</para>
        /// <para>- <c>string</c> width (optional)</para>
        /// <para>- <c>string</c> height (optional)</para>
        /// <para>- <c>string</c> offset_left (optional)</para>
        /// <para>- <c>string</c> offset_top (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void UpdateProfileBanner(object parameters)
        {
            this.Tokens.AccessApiNoResponse(MethodType.Post, "account/update_profile_banner", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="width">optional.</param>
        /// <param name="height">optional.</param>
        /// <param name="offset_left">optional.</param>
        /// <param name="offset_top">optional.</param>
        /// <returns></returns>
        public void UpdateProfileBanner(Stream image, string width = null, string height = null, string offset_left = null, string offset_top = null)
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            parameters.Add("image", image);
            if(width != null) parameters.Add("width", width);
            if(height != null) parameters.Add("height", height);
            if(offset_left != null) parameters.Add("offset_left", offset_left);
            if(offset_top != null) parameters.Add("offset_top", offset_top);
            this.Tokens.AccessApiNoResponse(MethodType.Post, "account/update_profile_banner", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="width">optional.</param>
        /// <param name="height">optional.</param>
        /// <param name="offset_left">optional.</param>
        /// <param name="offset_top">optional.</param>
        /// <returns></returns>
        public void UpdateProfileBanner(IEnumerable<byte> image, string width = null, string height = null, string offset_left = null, string offset_top = null)
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            parameters.Add("image", image);
            if(width != null) parameters.Add("width", width);
            if(height != null) parameters.Add("height", height);
            if(offset_left != null) parameters.Add("offset_left", offset_left);
            if(offset_top != null) parameters.Add("offset_top", offset_top);
            this.Tokens.AccessApiNoResponse(MethodType.Post, "account/update_profile_banner", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="width">optional.</param>
        /// <param name="height">optional.</param>
        /// <param name="offset_left">optional.</param>
        /// <param name="offset_top">optional.</param>
        /// <returns></returns>
        public void UpdateProfileBanner(FileInfo image, string width = null, string height = null, string offset_left = null, string offset_top = null)
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            parameters.Add("image", image);
            if(width != null) parameters.Add("width", width);
            if(height != null) parameters.Add("height", height);
            if(offset_left != null) parameters.Add("offset_left", offset_left);
            if(offset_top != null) parameters.Add("offset_top", offset_top);
            this.Tokens.AccessApiNoResponse(MethodType.Post, "account/update_profile_banner", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// </summary>
        /// <param name="banner">any one is required.</param>
        /// <param name="width">optional.</param>
        /// <param name="height">optional.</param>
        /// <param name="offset_left">optional.</param>
        /// <param name="offset_top">optional.</param>
        /// <returns></returns>
        public void UpdateProfileBanner(string banner, string width = null, string height = null, string offset_left = null, string offset_top = null)
        {
            var parameters = new Dictionary<string, object>();
            if(banner == null) throw new ArgumentNullException("banner");
            parameters.Add("banner", banner);
            if(width != null) parameters.Add("width", width);
            if(height != null) parameters.Add("height", height);
            if(offset_left != null) parameters.Add("offset_left", offset_left);
            if(offset_top != null) parameters.Add("offset_top", offset_top);
            this.Tokens.AccessApiNoResponse(MethodType.Post, "account/update_profile_banner", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>string</c> banner (any one is required)</para>
        /// <para>- <c>string</c> width (optional)</para>
        /// <para>- <c>string</c> height (optional)</para>
        /// <para>- <c>string</c> offset_left (optional)</para>
        /// <para>- <c>string</c> offset_top (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public Task UpdateProfileBannerAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiNoResponseAsync(MethodType.Post, "account/update_profile_banner", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>string</c> banner (any one is required)</para>
        /// <para>- <c>string</c> width (optional)</para>
        /// <para>- <c>string</c> height (optional)</para>
        /// <para>- <c>string</c> offset_left (optional)</para>
        /// <para>- <c>string</c> offset_top (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task UpdateProfileBannerAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiNoResponseAsync(MethodType.Post, "account/update_profile_banner", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>string</c> banner (any one is required)</para>
        /// <para>- <c>string</c> width (optional)</para>
        /// <para>- <c>string</c> height (optional)</para>
        /// <para>- <c>string</c> offset_left (optional)</para>
        /// <para>- <c>string</c> offset_top (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task UpdateProfileBannerAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiNoResponseAsync(MethodType.Post, "account/update_profile_banner", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="width">optional.</param>
        /// <param name="height">optional.</param>
        /// <param name="offset_left">optional.</param>
        /// <param name="offset_top">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task UpdateProfileBannerAsync(Stream image, string width = null, string height = null, string offset_left = null, string offset_top = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            parameters.Add("image", image);
            if(width != null) parameters.Add("width", width);
            if(height != null) parameters.Add("height", height);
            if(offset_left != null) parameters.Add("offset_left", offset_left);
            if(offset_top != null) parameters.Add("offset_top", offset_top);
            return this.Tokens.AccessApiNoResponseAsync(MethodType.Post, "account/update_profile_banner", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="width">optional.</param>
        /// <param name="height">optional.</param>
        /// <param name="offset_left">optional.</param>
        /// <param name="offset_top">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task UpdateProfileBannerAsync(IEnumerable<byte> image, string width = null, string height = null, string offset_left = null, string offset_top = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            parameters.Add("image", image);
            if(width != null) parameters.Add("width", width);
            if(height != null) parameters.Add("height", height);
            if(offset_left != null) parameters.Add("offset_left", offset_left);
            if(offset_top != null) parameters.Add("offset_top", offset_top);
            return this.Tokens.AccessApiNoResponseAsync(MethodType.Post, "account/update_profile_banner", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="width">optional.</param>
        /// <param name="height">optional.</param>
        /// <param name="offset_left">optional.</param>
        /// <param name="offset_top">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task UpdateProfileBannerAsync(FileInfo image, string width = null, string height = null, string offset_left = null, string offset_top = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            parameters.Add("image", image);
            if(width != null) parameters.Add("width", width);
            if(height != null) parameters.Add("height", height);
            if(offset_left != null) parameters.Add("offset_left", offset_left);
            if(offset_top != null) parameters.Add("offset_top", offset_top);
            return this.Tokens.AccessApiNoResponseAsync(MethodType.Post, "account/update_profile_banner", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// </summary>
        /// <param name="banner">any one is required.</param>
        /// <param name="width">optional.</param>
        /// <param name="height">optional.</param>
        /// <param name="offset_left">optional.</param>
        /// <param name="offset_top">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task UpdateProfileBannerAsync(string banner, string width = null, string height = null, string offset_left = null, string offset_top = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(banner == null) throw new ArgumentNullException("banner");
            parameters.Add("banner", banner);
            if(width != null) parameters.Add("width", width);
            if(height != null) parameters.Add("height", height);
            if(offset_left != null) parameters.Add("offset_left", offset_left);
            if(offset_top != null) parameters.Add("offset_top", offset_top);
            return this.Tokens.AccessApiNoResponseAsync(MethodType.Post, "account/update_profile_banner", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Removes the uploaded profile banner for the authenticating user.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void RemoveProfileBanner(params Expression<Func<string, object>>[] parameters)
        {
            this.Tokens.AccessApiNoResponse(MethodType.Post, "account/remove_profile_banner", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Removes the uploaded profile banner for the authenticating user.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void RemoveProfileBanner(IDictionary<string, object> parameters)
        {
            this.Tokens.AccessApiNoResponse(MethodType.Post, "account/remove_profile_banner", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Removes the uploaded profile banner for the authenticating user.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void RemoveProfileBanner(object parameters)
        {
            this.Tokens.AccessApiNoResponse(MethodType.Post, "account/remove_profile_banner", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Removes the uploaded profile banner for the authenticating user.</para>
        /// </summary>
        /// <returns></returns>
        public void RemoveProfileBanner()
        {
            var parameters = new Dictionary<string, object>();
            this.Tokens.AccessApiNoResponse(MethodType.Post, "account/remove_profile_banner", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Removes the uploaded profile banner for the authenticating user.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public Task RemoveProfileBannerAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiNoResponseAsync(MethodType.Post, "account/remove_profile_banner", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Removes the uploaded profile banner for the authenticating user.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task RemoveProfileBannerAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiNoResponseAsync(MethodType.Post, "account/remove_profile_banner", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Removes the uploaded profile banner for the authenticating user.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task RemoveProfileBannerAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiNoResponseAsync(MethodType.Post, "account/remove_profile_banner", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Removes the uploaded profile banner for the authenticating user.</para>
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task RemoveProfileBannerAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiNoResponseAsync(MethodType.Post, "account/remove_profile_banner", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileImage(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_image", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileImage(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_image", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileImage(object parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_image", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileImage(Stream image, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            parameters.Add("image", image);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_image", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileImage(IEnumerable<byte> image, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            parameters.Add("image", image);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_image", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileImage(FileInfo image, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            parameters.Add("image", image);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_image", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileImageAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_image", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileImageAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_image", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileImageAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_image", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileImageAsync(Stream image, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            parameters.Add("image", image);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_image", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileImageAsync(IEnumerable<byte> image, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            parameters.Add("image", image);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_image", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileImageAsync(FileInfo image, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            parameters.Add("image", image);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_image", parameters, cancellationToken, urlPrefix: "1.1");
        }

    }

}
namespace CoreTweet.AccountActivity
{
    /// <summary>
    /// Provides a set of methods for Enterprise Account Activity API.
    /// </summary>
    public partial class AccountActivityEnterpriseApi : ApiProviderBase
    {
        internal AccountActivityEnterpriseApi(TokensBase e) : base(e) { }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Registers a new webhook URL for the given application context.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> url (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The webhook URL object.</returns>
        public Webhook PostWebhooks(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Webhook>(MethodType.Post, "account_activity/webhooks", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Registers a new webhook URL for the given application context.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> url (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The webhook URL object.</returns>
        public Webhook PostWebhooks(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Webhook>(MethodType.Post, "account_activity/webhooks", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Registers a new webhook URL for the given application context.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> url (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The webhook URL object.</returns>
        public Webhook PostWebhooks(object parameters)
        {
            return this.Tokens.AccessApi<Webhook>(MethodType.Post, "account_activity/webhooks", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Registers a new webhook URL for the given application context.</para>
        /// </summary>
        /// <param name="url">required.</param>
        /// <returns>The webhook URL object.</returns>
        public Webhook PostWebhooks(string url)
        {
            var parameters = new Dictionary<string, object>();
            if(url == null) throw new ArgumentNullException("url");
            parameters.Add("url", url);
            return this.Tokens.AccessApi<Webhook>(MethodType.Post, "account_activity/webhooks", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Registers a new webhook URL for the given application context.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> url (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The webhook URL object.</returns>
        public Task<Webhook> PostWebhooksAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Webhook>(MethodType.Post, "account_activity/webhooks", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Registers a new webhook URL for the given application context.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> url (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The webhook URL object.</returns>
        public Task<Webhook> PostWebhooksAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Webhook>(MethodType.Post, "account_activity/webhooks", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Registers a new webhook URL for the given application context.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> url (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The webhook URL object.</returns>
        public Task<Webhook> PostWebhooksAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Webhook>(MethodType.Post, "account_activity/webhooks", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Registers a new webhook URL for the given application context.</para>
        /// </summary>
        /// <param name="url">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The webhook URL object.</returns>
        public Task<Webhook> PostWebhooksAsync(string url, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(url == null) throw new ArgumentNullException("url");
            parameters.Add("url", url);
            return this.Tokens.AccessApiAsync<Webhook>(MethodType.Post, "account_activity/webhooks", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns all webhook URLs and their statuses for the given application.</para>
        /// <para>This endpoint is for application-only authorization only.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list of environments object.</returns>
        public ListedResponse<Webhook> GetWebhooks(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<Webhook>(MethodType.Get, "account_activity/webhooks", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns all webhook URLs and their statuses for the given application.</para>
        /// <para>This endpoint is for application-only authorization only.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list of environments object.</returns>
        public ListedResponse<Webhook> GetWebhooks(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<Webhook>(MethodType.Get, "account_activity/webhooks", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns all webhook URLs and their statuses for the given application.</para>
        /// <para>This endpoint is for application-only authorization only.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list of environments object.</returns>
        public ListedResponse<Webhook> GetWebhooks(object parameters)
        {
            return this.Tokens.AccessApiArray<Webhook>(MethodType.Get, "account_activity/webhooks", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns all webhook URLs and their statuses for the given application.</para>
        /// <para>This endpoint is for application-only authorization only.</para>
        /// </summary>
        /// <returns>The list of environments object.</returns>
        public ListedResponse<Webhook> GetWebhooks()
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiArray<Webhook>(MethodType.Get, "account_activity/webhooks", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns all webhook URLs and their statuses for the given application.</para>
        /// <para>This endpoint is for application-only authorization only.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list of environments object.</returns>
        public Task<ListedResponse<Webhook>> GetWebhooksAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<Webhook>(MethodType.Get, "account_activity/webhooks", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns all webhook URLs and their statuses for the given application.</para>
        /// <para>This endpoint is for application-only authorization only.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list of environments object.</returns>
        public Task<ListedResponse<Webhook>> GetWebhooksAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Webhook>(MethodType.Get, "account_activity/webhooks", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns all webhook URLs and their statuses for the given application.</para>
        /// <para>This endpoint is for application-only authorization only.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list of environments object.</returns>
        public Task<ListedResponse<Webhook>> GetWebhooksAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Webhook>(MethodType.Get, "account_activity/webhooks", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns all webhook URLs and their statuses for the given application.</para>
        /// <para>This endpoint is for application-only authorization only.</para>
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list of environments object.</returns>
        public Task<ListedResponse<Webhook>> GetWebhooksAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiArrayAsync<Webhook>(MethodType.Get, "account_activity/webhooks", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Triggers the challenge response check (CRC) for the given webhook’s URL.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void PutWebhooks(params Expression<Func<string, object>>[] parameters)
        {
            this.Tokens.AccessParameterReservedApiNoResponse(MethodType.Put, "account_activity/webhooks/{webhook_id}", new [] { "webhook_id" }, InternalUtils.ExpressionsToDictionary(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Triggers the challenge response check (CRC) for the given webhook’s URL.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void PutWebhooks(IDictionary<string, object> parameters)
        {
            this.Tokens.AccessParameterReservedApiNoResponse(MethodType.Put, "account_activity/webhooks/{webhook_id}", new [] { "webhook_id" }, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Triggers the challenge response check (CRC) for the given webhook’s URL.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void PutWebhooks(object parameters)
        {
            this.Tokens.AccessParameterReservedApiNoResponse(MethodType.Put, "account_activity/webhooks/{webhook_id}", new [] { "webhook_id" }, InternalUtils.ResolveObject(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Triggers the challenge response check (CRC) for the given webhook’s URL.</para>
        /// </summary>
        /// <param name="webhook_id">required.</param>
        /// <returns></returns>
        public void PutWebhooks(string webhook_id)
        {
            var parameters = new Dictionary<string, object>();
            if(webhook_id == null) throw new ArgumentNullException("webhook_id");
            parameters.Add("webhook_id", webhook_id);
            this.Tokens.AccessParameterReservedApiNoResponse(MethodType.Put, "account_activity/webhooks/{webhook_id}", new [] { "webhook_id" }, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Triggers the challenge response check (CRC) for the given webhook’s URL.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public Task PutWebhooksAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiNoResponseAsync(MethodType.Put, "account_activity/webhooks/{webhook_id}", new [] { "webhook_id" }, InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Triggers the challenge response check (CRC) for the given webhook’s URL.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task PutWebhooksAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiNoResponseAsync(MethodType.Put, "account_activity/webhooks/{webhook_id}", new [] { "webhook_id" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Triggers the challenge response check (CRC) for the given webhook’s URL.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task PutWebhooksAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiNoResponseAsync(MethodType.Put, "account_activity/webhooks/{webhook_id}", new [] { "webhook_id" }, InternalUtils.ResolveObject(parameters), cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Triggers the challenge response check (CRC) for the given webhook’s URL.</para>
        /// </summary>
        /// <param name="webhook_id">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task PutWebhooksAsync(string webhook_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(webhook_id == null) throw new ArgumentNullException("webhook_id");
            parameters.Add("webhook_id", webhook_id);
            return this.Tokens.AccessParameterReservedApiNoResponseAsync(MethodType.Put, "account_activity/webhooks/{webhook_id}", new [] { "webhook_id" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Subscribes the provided application to all events for the provided user context for all message types. </para>
        /// <para>After activation, all events for the requesting user will be sent to the application’s webhook via POST request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void PostWebhooksSubscriptionsAll(params Expression<Func<string, object>>[] parameters)
        {
            this.Tokens.AccessParameterReservedApiNoResponse(MethodType.Post, "account_activity/webhooks/{webhook_id}/subscriptions/all", new [] { "webhook_id" }, InternalUtils.ExpressionsToDictionary(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Subscribes the provided application to all events for the provided user context for all message types. </para>
        /// <para>After activation, all events for the requesting user will be sent to the application’s webhook via POST request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void PostWebhooksSubscriptionsAll(IDictionary<string, object> parameters)
        {
            this.Tokens.AccessParameterReservedApiNoResponse(MethodType.Post, "account_activity/webhooks/{webhook_id}/subscriptions/all", new [] { "webhook_id" }, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Subscribes the provided application to all events for the provided user context for all message types. </para>
        /// <para>After activation, all events for the requesting user will be sent to the application’s webhook via POST request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void PostWebhooksSubscriptionsAll(object parameters)
        {
            this.Tokens.AccessParameterReservedApiNoResponse(MethodType.Post, "account_activity/webhooks/{webhook_id}/subscriptions/all", new [] { "webhook_id" }, InternalUtils.ResolveObject(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Subscribes the provided application to all events for the provided user context for all message types. </para>
        /// <para>After activation, all events for the requesting user will be sent to the application’s webhook via POST request.</para>
        /// </summary>
        /// <param name="webhook_id">required.</param>
        /// <returns></returns>
        public void PostWebhooksSubscriptionsAll(string webhook_id)
        {
            var parameters = new Dictionary<string, object>();
            if(webhook_id == null) throw new ArgumentNullException("webhook_id");
            parameters.Add("webhook_id", webhook_id);
            this.Tokens.AccessParameterReservedApiNoResponse(MethodType.Post, "account_activity/webhooks/{webhook_id}/subscriptions/all", new [] { "webhook_id" }, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Subscribes the provided application to all events for the provided user context for all message types. </para>
        /// <para>After activation, all events for the requesting user will be sent to the application’s webhook via POST request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public Task PostWebhooksSubscriptionsAllAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiNoResponseAsync(MethodType.Post, "account_activity/webhooks/{webhook_id}/subscriptions/all", new [] { "webhook_id" }, InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Subscribes the provided application to all events for the provided user context for all message types. </para>
        /// <para>After activation, all events for the requesting user will be sent to the application’s webhook via POST request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task PostWebhooksSubscriptionsAllAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiNoResponseAsync(MethodType.Post, "account_activity/webhooks/{webhook_id}/subscriptions/all", new [] { "webhook_id" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Subscribes the provided application to all events for the provided user context for all message types. </para>
        /// <para>After activation, all events for the requesting user will be sent to the application’s webhook via POST request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task PostWebhooksSubscriptionsAllAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiNoResponseAsync(MethodType.Post, "account_activity/webhooks/{webhook_id}/subscriptions/all", new [] { "webhook_id" }, InternalUtils.ResolveObject(parameters), cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Subscribes the provided application to all events for the provided user context for all message types. </para>
        /// <para>After activation, all events for the requesting user will be sent to the application’s webhook via POST request.</para>
        /// </summary>
        /// <param name="webhook_id">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task PostWebhooksSubscriptionsAllAsync(string webhook_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(webhook_id == null) throw new ArgumentNullException("webhook_id");
            parameters.Add("webhook_id", webhook_id);
            return this.Tokens.AccessParameterReservedApiNoResponseAsync(MethodType.Post, "account_activity/webhooks/{webhook_id}/subscriptions/all", new [] { "webhook_id" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the count of subscriptions that are currently active on your account.</para>
        /// <para>Note that the /count endpoint requires application-only OAuth, so that you should make requests using a bearer token instead of user context.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The count of subscriptions.</returns>
        public SubscriptionsCount SubscriptionsCount(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<SubscriptionsCount>(MethodType.Get, "account_activity/subscriptions/count", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the count of subscriptions that are currently active on your account.</para>
        /// <para>Note that the /count endpoint requires application-only OAuth, so that you should make requests using a bearer token instead of user context.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The count of subscriptions.</returns>
        public SubscriptionsCount SubscriptionsCount(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<SubscriptionsCount>(MethodType.Get, "account_activity/subscriptions/count", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the count of subscriptions that are currently active on your account.</para>
        /// <para>Note that the /count endpoint requires application-only OAuth, so that you should make requests using a bearer token instead of user context.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The count of subscriptions.</returns>
        public SubscriptionsCount SubscriptionsCount(object parameters)
        {
            return this.Tokens.AccessApi<SubscriptionsCount>(MethodType.Get, "account_activity/subscriptions/count", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the count of subscriptions that are currently active on your account.</para>
        /// <para>Note that the /count endpoint requires application-only OAuth, so that you should make requests using a bearer token instead of user context.</para>
        /// </summary>
        /// <returns>The count of subscriptions.</returns>
        public SubscriptionsCount SubscriptionsCount()
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApi<SubscriptionsCount>(MethodType.Get, "account_activity/subscriptions/count", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns the count of subscriptions that are currently active on your account.</para>
        /// <para>Note that the /count endpoint requires application-only OAuth, so that you should make requests using a bearer token instead of user context.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The count of subscriptions.</returns>
        public Task<SubscriptionsCount> SubscriptionsCountAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<SubscriptionsCount>(MethodType.Get, "account_activity/subscriptions/count", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the count of subscriptions that are currently active on your account.</para>
        /// <para>Note that the /count endpoint requires application-only OAuth, so that you should make requests using a bearer token instead of user context.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The count of subscriptions.</returns>
        public Task<SubscriptionsCount> SubscriptionsCountAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<SubscriptionsCount>(MethodType.Get, "account_activity/subscriptions/count", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the count of subscriptions that are currently active on your account.</para>
        /// <para>Note that the /count endpoint requires application-only OAuth, so that you should make requests using a bearer token instead of user context.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The count of subscriptions.</returns>
        public Task<SubscriptionsCount> SubscriptionsCountAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<SubscriptionsCount>(MethodType.Get, "account_activity/subscriptions/count", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the count of subscriptions that are currently active on your account.</para>
        /// <para>Note that the /count endpoint requires application-only OAuth, so that you should make requests using a bearer token instead of user context.</para>
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The count of subscriptions.</returns>
        public Task<SubscriptionsCount> SubscriptionsCountAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiAsync<SubscriptionsCount>(MethodType.Get, "account_activity/subscriptions/count", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Provides a way to determine if a webhook configuration is subscribed to the provided user’s events. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void GetWebhooksSubscriptionsAll(params Expression<Func<string, object>>[] parameters)
        {
            this.Tokens.AccessParameterReservedApiNoResponse(MethodType.Get, "account_activity/webhooks/{webhook_id}/subscriptions/all", new [] { "webhook_id" }, InternalUtils.ExpressionsToDictionary(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Provides a way to determine if a webhook configuration is subscribed to the provided user’s events. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void GetWebhooksSubscriptionsAll(IDictionary<string, object> parameters)
        {
            this.Tokens.AccessParameterReservedApiNoResponse(MethodType.Get, "account_activity/webhooks/{webhook_id}/subscriptions/all", new [] { "webhook_id" }, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Provides a way to determine if a webhook configuration is subscribed to the provided user’s events. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void GetWebhooksSubscriptionsAll(object parameters)
        {
            this.Tokens.AccessParameterReservedApiNoResponse(MethodType.Get, "account_activity/webhooks/{webhook_id}/subscriptions/all", new [] { "webhook_id" }, InternalUtils.ResolveObject(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Provides a way to determine if a webhook configuration is subscribed to the provided user’s events. </para>
        /// </summary>
        /// <param name="webhook_id">required.</param>
        /// <returns></returns>
        public void GetWebhooksSubscriptionsAll(string webhook_id)
        {
            var parameters = new Dictionary<string, object>();
            if(webhook_id == null) throw new ArgumentNullException("webhook_id");
            parameters.Add("webhook_id", webhook_id);
            this.Tokens.AccessParameterReservedApiNoResponse(MethodType.Get, "account_activity/webhooks/{webhook_id}/subscriptions/all", new [] { "webhook_id" }, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Provides a way to determine if a webhook configuration is subscribed to the provided user’s events. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public Task GetWebhooksSubscriptionsAllAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiNoResponseAsync(MethodType.Get, "account_activity/webhooks/{webhook_id}/subscriptions/all", new [] { "webhook_id" }, InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Provides a way to determine if a webhook configuration is subscribed to the provided user’s events. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task GetWebhooksSubscriptionsAllAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiNoResponseAsync(MethodType.Get, "account_activity/webhooks/{webhook_id}/subscriptions/all", new [] { "webhook_id" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Provides a way to determine if a webhook configuration is subscribed to the provided user’s events. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task GetWebhooksSubscriptionsAllAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiNoResponseAsync(MethodType.Get, "account_activity/webhooks/{webhook_id}/subscriptions/all", new [] { "webhook_id" }, InternalUtils.ResolveObject(parameters), cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Provides a way to determine if a webhook configuration is subscribed to the provided user’s events. </para>
        /// </summary>
        /// <param name="webhook_id">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task GetWebhooksSubscriptionsAllAsync(string webhook_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(webhook_id == null) throw new ArgumentNullException("webhook_id");
            parameters.Add("webhook_id", webhook_id);
            return this.Tokens.AccessParameterReservedApiNoResponseAsync(MethodType.Get, "account_activity/webhooks/{webhook_id}/subscriptions/all", new [] { "webhook_id" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a list of the current All Activity type subscriptions for the specified webhook.</para>
        /// <para>Note that the /list endpoint requires application-only OAuth, so requests should be made using a bearer token instead of user context.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list of subscriptions object.</returns>
        public SubscriptionsList WebhooksSubscriptionsAllList(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApi<SubscriptionsList>(MethodType.Get, "account_activity/webhooks/{webhook_id}/subscriptions/all/list", new [] { "webhook_id" }, InternalUtils.ExpressionsToDictionary(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a list of the current All Activity type subscriptions for the specified webhook.</para>
        /// <para>Note that the /list endpoint requires application-only OAuth, so requests should be made using a bearer token instead of user context.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list of subscriptions object.</returns>
        public SubscriptionsList WebhooksSubscriptionsAllList(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessParameterReservedApi<SubscriptionsList>(MethodType.Get, "account_activity/webhooks/{webhook_id}/subscriptions/all/list", new [] { "webhook_id" }, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a list of the current All Activity type subscriptions for the specified webhook.</para>
        /// <para>Note that the /list endpoint requires application-only OAuth, so requests should be made using a bearer token instead of user context.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list of subscriptions object.</returns>
        public SubscriptionsList WebhooksSubscriptionsAllList(object parameters)
        {
            return this.Tokens.AccessParameterReservedApi<SubscriptionsList>(MethodType.Get, "account_activity/webhooks/{webhook_id}/subscriptions/all/list", new [] { "webhook_id" }, InternalUtils.ResolveObject(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a list of the current All Activity type subscriptions for the specified webhook.</para>
        /// <para>Note that the /list endpoint requires application-only OAuth, so requests should be made using a bearer token instead of user context.</para>
        /// </summary>
        /// <param name="webhook_id">required.</param>
        /// <returns>The list of subscriptions object.</returns>
        public SubscriptionsList WebhooksSubscriptionsAllList(string webhook_id)
        {
            var parameters = new Dictionary<string, object>();
            if(webhook_id == null) throw new ArgumentNullException("webhook_id");
            parameters.Add("webhook_id", webhook_id);
            return this.Tokens.AccessParameterReservedApi<SubscriptionsList>(MethodType.Get, "account_activity/webhooks/{webhook_id}/subscriptions/all/list", new [] { "webhook_id" }, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns a list of the current All Activity type subscriptions for the specified webhook.</para>
        /// <para>Note that the /list endpoint requires application-only OAuth, so requests should be made using a bearer token instead of user context.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list of subscriptions object.</returns>
        public Task<SubscriptionsList> WebhooksSubscriptionsAllListAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiAsync<SubscriptionsList>(MethodType.Get, "account_activity/webhooks/{webhook_id}/subscriptions/all/list", new [] { "webhook_id" }, InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a list of the current All Activity type subscriptions for the specified webhook.</para>
        /// <para>Note that the /list endpoint requires application-only OAuth, so requests should be made using a bearer token instead of user context.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list of subscriptions object.</returns>
        public Task<SubscriptionsList> WebhooksSubscriptionsAllListAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<SubscriptionsList>(MethodType.Get, "account_activity/webhooks/{webhook_id}/subscriptions/all/list", new [] { "webhook_id" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a list of the current All Activity type subscriptions for the specified webhook.</para>
        /// <para>Note that the /list endpoint requires application-only OAuth, so requests should be made using a bearer token instead of user context.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list of subscriptions object.</returns>
        public Task<SubscriptionsList> WebhooksSubscriptionsAllListAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<SubscriptionsList>(MethodType.Get, "account_activity/webhooks/{webhook_id}/subscriptions/all/list", new [] { "webhook_id" }, InternalUtils.ResolveObject(parameters), cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a list of the current All Activity type subscriptions for the specified webhook.</para>
        /// <para>Note that the /list endpoint requires application-only OAuth, so requests should be made using a bearer token instead of user context.</para>
        /// </summary>
        /// <param name="webhook_id">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list of subscriptions object.</returns>
        public Task<SubscriptionsList> WebhooksSubscriptionsAllListAsync(string webhook_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(webhook_id == null) throw new ArgumentNullException("webhook_id");
            parameters.Add("webhook_id", webhook_id);
            return this.Tokens.AccessParameterReservedApiAsync<SubscriptionsList>(MethodType.Get, "account_activity/webhooks/{webhook_id}/subscriptions/all/list", new [] { "webhook_id" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Removes the webhook from the provided application’s configuration. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void DeleteWebhooks(params Expression<Func<string, object>>[] parameters)
        {
            this.Tokens.AccessParameterReservedApiNoResponse(MethodType.Delete, "account_activity/webhooks/{webhook_id}", new [] { "webhook_id" }, InternalUtils.ExpressionsToDictionary(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Removes the webhook from the provided application’s configuration. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void DeleteWebhooks(IDictionary<string, object> parameters)
        {
            this.Tokens.AccessParameterReservedApiNoResponse(MethodType.Delete, "account_activity/webhooks/{webhook_id}", new [] { "webhook_id" }, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Removes the webhook from the provided application’s configuration. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void DeleteWebhooks(object parameters)
        {
            this.Tokens.AccessParameterReservedApiNoResponse(MethodType.Delete, "account_activity/webhooks/{webhook_id}", new [] { "webhook_id" }, InternalUtils.ResolveObject(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Removes the webhook from the provided application’s configuration. </para>
        /// </summary>
        /// <param name="webhook_id">required.</param>
        /// <returns></returns>
        public void DeleteWebhooks(string webhook_id)
        {
            var parameters = new Dictionary<string, object>();
            if(webhook_id == null) throw new ArgumentNullException("webhook_id");
            parameters.Add("webhook_id", webhook_id);
            this.Tokens.AccessParameterReservedApiNoResponse(MethodType.Delete, "account_activity/webhooks/{webhook_id}", new [] { "webhook_id" }, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Removes the webhook from the provided application’s configuration. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public Task DeleteWebhooksAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiNoResponseAsync(MethodType.Delete, "account_activity/webhooks/{webhook_id}", new [] { "webhook_id" }, InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Removes the webhook from the provided application’s configuration. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task DeleteWebhooksAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiNoResponseAsync(MethodType.Delete, "account_activity/webhooks/{webhook_id}", new [] { "webhook_id" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Removes the webhook from the provided application’s configuration. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task DeleteWebhooksAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiNoResponseAsync(MethodType.Delete, "account_activity/webhooks/{webhook_id}", new [] { "webhook_id" }, InternalUtils.ResolveObject(parameters), cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Removes the webhook from the provided application’s configuration. </para>
        /// </summary>
        /// <param name="webhook_id">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task DeleteWebhooksAsync(string webhook_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(webhook_id == null) throw new ArgumentNullException("webhook_id");
            parameters.Add("webhook_id", webhook_id);
            return this.Tokens.AccessParameterReservedApiNoResponseAsync(MethodType.Delete, "account_activity/webhooks/{webhook_id}", new [] { "webhook_id" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Deactivates subscription(s) for the provided user context and application.  </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void DeleteWebhooksSubscriptionsAll(params Expression<Func<string, object>>[] parameters)
        {
            this.Tokens.AccessParameterReservedApiNoResponse(MethodType.Delete, "account_activity/webhooks/{webhook_id}/subscriptions/all", new [] { "webhook_id" }, InternalUtils.ExpressionsToDictionary(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Deactivates subscription(s) for the provided user context and application.  </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void DeleteWebhooksSubscriptionsAll(IDictionary<string, object> parameters)
        {
            this.Tokens.AccessParameterReservedApiNoResponse(MethodType.Delete, "account_activity/webhooks/{webhook_id}/subscriptions/all", new [] { "webhook_id" }, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Deactivates subscription(s) for the provided user context and application.  </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void DeleteWebhooksSubscriptionsAll(object parameters)
        {
            this.Tokens.AccessParameterReservedApiNoResponse(MethodType.Delete, "account_activity/webhooks/{webhook_id}/subscriptions/all", new [] { "webhook_id" }, InternalUtils.ResolveObject(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Deactivates subscription(s) for the provided user context and application.  </para>
        /// </summary>
        /// <param name="webhook_id">required.</param>
        /// <returns></returns>
        public void DeleteWebhooksSubscriptionsAll(string webhook_id)
        {
            var parameters = new Dictionary<string, object>();
            if(webhook_id == null) throw new ArgumentNullException("webhook_id");
            parameters.Add("webhook_id", webhook_id);
            this.Tokens.AccessParameterReservedApiNoResponse(MethodType.Delete, "account_activity/webhooks/{webhook_id}/subscriptions/all", new [] { "webhook_id" }, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Deactivates subscription(s) for the provided user context and application.  </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public Task DeleteWebhooksSubscriptionsAllAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiNoResponseAsync(MethodType.Delete, "account_activity/webhooks/{webhook_id}/subscriptions/all", new [] { "webhook_id" }, InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Deactivates subscription(s) for the provided user context and application.  </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task DeleteWebhooksSubscriptionsAllAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiNoResponseAsync(MethodType.Delete, "account_activity/webhooks/{webhook_id}/subscriptions/all", new [] { "webhook_id" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Deactivates subscription(s) for the provided user context and application.  </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task DeleteWebhooksSubscriptionsAllAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiNoResponseAsync(MethodType.Delete, "account_activity/webhooks/{webhook_id}/subscriptions/all", new [] { "webhook_id" }, InternalUtils.ResolveObject(parameters), cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Deactivates subscription(s) for the provided user context and application.  </para>
        /// </summary>
        /// <param name="webhook_id">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task DeleteWebhooksSubscriptionsAllAsync(string webhook_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(webhook_id == null) throw new ArgumentNullException("webhook_id");
            parameters.Add("webhook_id", webhook_id);
            return this.Tokens.AccessParameterReservedApiNoResponseAsync(MethodType.Delete, "account_activity/webhooks/{webhook_id}/subscriptions/all", new [] { "webhook_id" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

    }

}
namespace CoreTweet.Rest
{
}
namespace CoreTweet.AccountActivity
{
    /// <summary>
    /// Provides a set of methods for using a dev environment of Premium Account Activity API.
    /// </summary>
    public partial class AccountActivityEnvironment : ApiProviderBase
    {
        internal AccountActivityEnvironment(TokensBase e) : base(e) { }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Registers a webhook URL for all event types.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> url (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The webhook URL object.</returns>
        public Webhook PostWebhooks(params Expression<Func<string, object>>[] parameters)
        {
            return this.PostWebhooksImpl(InternalUtils.ExpressionsToDictionary(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Registers a webhook URL for all event types.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> url (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The webhook URL object.</returns>
        public Webhook PostWebhooks(IDictionary<string, object> parameters)
        {
            return this.PostWebhooksImpl(parameters, "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Registers a webhook URL for all event types.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> url (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The webhook URL object.</returns>
        public Webhook PostWebhooks(object parameters)
        {
            return this.PostWebhooksImpl(InternalUtils.ResolveObject(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Registers a webhook URL for all event types.</para>
        /// </summary>
        /// <param name="url">required.</param>
        /// <returns>The webhook URL object.</returns>
        public Webhook PostWebhooks(string url)
        {
            var parameters = new Dictionary<string, object>();
            if(url == null) throw new ArgumentNullException("url");
            parameters.Add("url", url);
            return this.PostWebhooksImpl(parameters, "1.1", null);
        }
        #endif

        /// <summary>
        /// <para>Registers a webhook URL for all event types.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> url (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The webhook URL object.</returns>
        public Task<Webhook> PostWebhooksAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.PostWebhooksAsyncImpl(InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, "1.1", null);
        }

        /// <summary>
        /// <para>Registers a webhook URL for all event types.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> url (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The webhook URL object.</returns>
        public Task<Webhook> PostWebhooksAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.PostWebhooksAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Registers a webhook URL for all event types.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> url (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The webhook URL object.</returns>
        public Task<Webhook> PostWebhooksAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.PostWebhooksAsyncImpl(InternalUtils.ResolveObject(parameters), cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Registers a webhook URL for all event types.</para>
        /// </summary>
        /// <param name="url">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The webhook URL object.</returns>
        public Task<Webhook> PostWebhooksAsync(string url, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(url == null) throw new ArgumentNullException("url");
            parameters.Add("url", url);
            return this.PostWebhooksAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns all webhook URLs and their statuses for the environment.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list of environments object.</returns>
        public ListedResponse<Webhook> GetWebhooks(params Expression<Func<string, object>>[] parameters)
        {
            return this.GetWebhooksImpl(InternalUtils.ExpressionsToDictionary(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns all webhook URLs and their statuses for the environment.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list of environments object.</returns>
        public ListedResponse<Webhook> GetWebhooks(IDictionary<string, object> parameters)
        {
            return this.GetWebhooksImpl(parameters, "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns all webhook URLs and their statuses for the environment.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list of environments object.</returns>
        public ListedResponse<Webhook> GetWebhooks(object parameters)
        {
            return this.GetWebhooksImpl(InternalUtils.ResolveObject(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns all webhook URLs and their statuses for the environment.</para>
        /// </summary>
        /// <returns>The list of environments object.</returns>
        public ListedResponse<Webhook> GetWebhooks()
        {
            var parameters = new Dictionary<string, object>();
            return this.GetWebhooksImpl(parameters, "1.1", null);
        }
        #endif

        /// <summary>
        /// <para>Returns all webhook URLs and their statuses for the environment.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list of environments object.</returns>
        public Task<ListedResponse<Webhook>> GetWebhooksAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.GetWebhooksAsyncImpl(InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, "1.1", null);
        }

        /// <summary>
        /// <para>Returns all webhook URLs and their statuses for the environment.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list of environments object.</returns>
        public Task<ListedResponse<Webhook>> GetWebhooksAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.GetWebhooksAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Returns all webhook URLs and their statuses for the environment.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list of environments object.</returns>
        public Task<ListedResponse<Webhook>> GetWebhooksAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.GetWebhooksAsyncImpl(InternalUtils.ResolveObject(parameters), cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Returns all webhook URLs and their statuses for the environment.</para>
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list of environments object.</returns>
        public Task<ListedResponse<Webhook>> GetWebhooksAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            return this.GetWebhooksAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Triggers the challenge response check (CRC) for the given enviroments webhook for all activites.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void PutWebhooks(params Expression<Func<string, object>>[] parameters)
        {
            this.PutWebhooksImpl(InternalUtils.ExpressionsToDictionary(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Triggers the challenge response check (CRC) for the given enviroments webhook for all activites.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void PutWebhooks(IDictionary<string, object> parameters)
        {
            this.PutWebhooksImpl(parameters, "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Triggers the challenge response check (CRC) for the given enviroments webhook for all activites.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void PutWebhooks(object parameters)
        {
            this.PutWebhooksImpl(InternalUtils.ResolveObject(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Triggers the challenge response check (CRC) for the given enviroments webhook for all activites.</para>
        /// </summary>
        /// <param name="webhook_id">required.</param>
        /// <returns></returns>
        public void PutWebhooks(string webhook_id)
        {
            var parameters = new Dictionary<string, object>();
            if(webhook_id == null) throw new ArgumentNullException("webhook_id");
            parameters.Add("webhook_id", webhook_id);
            this.PutWebhooksImpl(parameters, "1.1", null);
        }
        #endif

        /// <summary>
        /// <para>Triggers the challenge response check (CRC) for the given enviroments webhook for all activites.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public Task PutWebhooksAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.PutWebhooksAsyncImpl(InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, "1.1", null);
        }

        /// <summary>
        /// <para>Triggers the challenge response check (CRC) for the given enviroments webhook for all activites.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task PutWebhooksAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.PutWebhooksAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Triggers the challenge response check (CRC) for the given enviroments webhook for all activites.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task PutWebhooksAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.PutWebhooksAsyncImpl(InternalUtils.ResolveObject(parameters), cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Triggers the challenge response check (CRC) for the given enviroments webhook for all activites.</para>
        /// </summary>
        /// <param name="webhook_id">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task PutWebhooksAsync(string webhook_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(webhook_id == null) throw new ArgumentNullException("webhook_id");
            parameters.Add("webhook_id", webhook_id);
            return this.PutWebhooksAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Removes the webhook from the provided application’s all activities configuration.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void DeleteWebhooks(params Expression<Func<string, object>>[] parameters)
        {
            this.DeleteWebhooksImpl(InternalUtils.ExpressionsToDictionary(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Removes the webhook from the provided application’s all activities configuration.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void DeleteWebhooks(IDictionary<string, object> parameters)
        {
            this.DeleteWebhooksImpl(parameters, "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Removes the webhook from the provided application’s all activities configuration.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void DeleteWebhooks(object parameters)
        {
            this.DeleteWebhooksImpl(InternalUtils.ResolveObject(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Removes the webhook from the provided application’s all activities configuration.</para>
        /// </summary>
        /// <param name="webhook_id">required.</param>
        /// <returns></returns>
        public void DeleteWebhooks(string webhook_id)
        {
            var parameters = new Dictionary<string, object>();
            if(webhook_id == null) throw new ArgumentNullException("webhook_id");
            parameters.Add("webhook_id", webhook_id);
            this.DeleteWebhooksImpl(parameters, "1.1", null);
        }
        #endif

        /// <summary>
        /// <para>Removes the webhook from the provided application’s all activities configuration.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public Task DeleteWebhooksAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.DeleteWebhooksAsyncImpl(InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, "1.1", null);
        }

        /// <summary>
        /// <para>Removes the webhook from the provided application’s all activities configuration.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task DeleteWebhooksAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.DeleteWebhooksAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Removes the webhook from the provided application’s all activities configuration.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> webhook_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task DeleteWebhooksAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.DeleteWebhooksAsyncImpl(InternalUtils.ResolveObject(parameters), cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Removes the webhook from the provided application’s all activities configuration.</para>
        /// </summary>
        /// <param name="webhook_id">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task DeleteWebhooksAsync(string webhook_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(webhook_id == null) throw new ArgumentNullException("webhook_id");
            parameters.Add("webhook_id", webhook_id);
            return this.DeleteWebhooksAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Subscribes the provided application to all events for the provided environment for all message types.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void PostSubscriptions(params Expression<Func<string, object>>[] parameters)
        {
            this.PostSubscriptionsImpl(InternalUtils.ExpressionsToDictionary(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Subscribes the provided application to all events for the provided environment for all message types.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void PostSubscriptions(IDictionary<string, object> parameters)
        {
            this.PostSubscriptionsImpl(parameters, "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Subscribes the provided application to all events for the provided environment for all message types.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void PostSubscriptions(object parameters)
        {
            this.PostSubscriptionsImpl(InternalUtils.ResolveObject(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Subscribes the provided application to all events for the provided environment for all message types.</para>
        /// </summary>
        /// <returns></returns>
        public void PostSubscriptions()
        {
            var parameters = new Dictionary<string, object>();
            this.PostSubscriptionsImpl(parameters, "1.1", null);
        }
        #endif

        /// <summary>
        /// <para>Subscribes the provided application to all events for the provided environment for all message types.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public Task PostSubscriptionsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.PostSubscriptionsAsyncImpl(InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, "1.1", null);
        }

        /// <summary>
        /// <para>Subscribes the provided application to all events for the provided environment for all message types.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task PostSubscriptionsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.PostSubscriptionsAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Subscribes the provided application to all events for the provided environment for all message types.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task PostSubscriptionsAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.PostSubscriptionsAsyncImpl(InternalUtils.ResolveObject(parameters), cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Subscribes the provided application to all events for the provided environment for all message types.</para>
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task PostSubscriptionsAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            return this.PostSubscriptionsAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Provides a way to determine if a webhook configuration is subscribed to the provided user’s events.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void GetSubscriptions(params Expression<Func<string, object>>[] parameters)
        {
            this.GetSubscriptionsImpl(InternalUtils.ExpressionsToDictionary(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Provides a way to determine if a webhook configuration is subscribed to the provided user’s events.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void GetSubscriptions(IDictionary<string, object> parameters)
        {
            this.GetSubscriptionsImpl(parameters, "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Provides a way to determine if a webhook configuration is subscribed to the provided user’s events.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void GetSubscriptions(object parameters)
        {
            this.GetSubscriptionsImpl(InternalUtils.ResolveObject(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Provides a way to determine if a webhook configuration is subscribed to the provided user’s events.</para>
        /// </summary>
        /// <returns></returns>
        public void GetSubscriptions()
        {
            var parameters = new Dictionary<string, object>();
            this.GetSubscriptionsImpl(parameters, "1.1", null);
        }
        #endif

        /// <summary>
        /// <para>Provides a way to determine if a webhook configuration is subscribed to the provided user’s events.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public Task GetSubscriptionsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.GetSubscriptionsAsyncImpl(InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, "1.1", null);
        }

        /// <summary>
        /// <para>Provides a way to determine if a webhook configuration is subscribed to the provided user’s events.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task GetSubscriptionsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.GetSubscriptionsAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Provides a way to determine if a webhook configuration is subscribed to the provided user’s events.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task GetSubscriptionsAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.GetSubscriptionsAsyncImpl(InternalUtils.ResolveObject(parameters), cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Provides a way to determine if a webhook configuration is subscribed to the provided user’s events.</para>
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task GetSubscriptionsAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            return this.GetSubscriptionsAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Deactivates subscription(s) for the provided user context and application for all activities.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void DeleteSubscriptions(params Expression<Func<string, object>>[] parameters)
        {
            this.DeleteSubscriptionsImpl(InternalUtils.ExpressionsToDictionary(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Deactivates subscription(s) for the provided user context and application for all activities.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void DeleteSubscriptions(IDictionary<string, object> parameters)
        {
            this.DeleteSubscriptionsImpl(parameters, "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Deactivates subscription(s) for the provided user context and application for all activities.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void DeleteSubscriptions(object parameters)
        {
            this.DeleteSubscriptionsImpl(InternalUtils.ResolveObject(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Deactivates subscription(s) for the provided user context and application for all activities.</para>
        /// </summary>
        /// <returns></returns>
        public void DeleteSubscriptions()
        {
            var parameters = new Dictionary<string, object>();
            this.DeleteSubscriptionsImpl(parameters, "1.1", null);
        }
        #endif

        /// <summary>
        /// <para>Deactivates subscription(s) for the provided user context and application for all activities.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public Task DeleteSubscriptionsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.DeleteSubscriptionsAsyncImpl(InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, "1.1", null);
        }

        /// <summary>
        /// <para>Deactivates subscription(s) for the provided user context and application for all activities.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task DeleteSubscriptionsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.DeleteSubscriptionsAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Deactivates subscription(s) for the provided user context and application for all activities.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task DeleteSubscriptionsAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.DeleteSubscriptionsAsyncImpl(InternalUtils.ResolveObject(parameters), cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Deactivates subscription(s) for the provided user context and application for all activities.</para>
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task DeleteSubscriptionsAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            return this.DeleteSubscriptionsAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a list of the current All Activity type subscriptions.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list of subscriptions object.</returns>
        public SubscriptionsList SubscriptionsList(params Expression<Func<string, object>>[] parameters)
        {
            return this.SubscriptionsListImpl(InternalUtils.ExpressionsToDictionary(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a list of the current All Activity type subscriptions.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list of subscriptions object.</returns>
        public SubscriptionsList SubscriptionsList(IDictionary<string, object> parameters)
        {
            return this.SubscriptionsListImpl(parameters, "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a list of the current All Activity type subscriptions.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list of subscriptions object.</returns>
        public SubscriptionsList SubscriptionsList(object parameters)
        {
            return this.SubscriptionsListImpl(InternalUtils.ResolveObject(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a list of the current All Activity type subscriptions.</para>
        /// </summary>
        /// <returns>The list of subscriptions object.</returns>
        public SubscriptionsList SubscriptionsList()
        {
            var parameters = new Dictionary<string, object>();
            return this.SubscriptionsListImpl(parameters, "1.1", null);
        }
        #endif

        /// <summary>
        /// <para>Returns a list of the current All Activity type subscriptions.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list of subscriptions object.</returns>
        public Task<SubscriptionsList> SubscriptionsListAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.SubscriptionsListAsyncImpl(InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, "1.1", null);
        }

        /// <summary>
        /// <para>Returns a list of the current All Activity type subscriptions.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list of subscriptions object.</returns>
        public Task<SubscriptionsList> SubscriptionsListAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.SubscriptionsListAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Returns a list of the current All Activity type subscriptions.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list of subscriptions object.</returns>
        public Task<SubscriptionsList> SubscriptionsListAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.SubscriptionsListAsyncImpl(InternalUtils.ResolveObject(parameters), cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Returns a list of the current All Activity type subscriptions.</para>
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list of subscriptions object.</returns>
        public Task<SubscriptionsList> SubscriptionsListAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            return this.SubscriptionsListAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

    }

}
namespace CoreTweet.Rest
{
}
namespace CoreTweet.AccountActivity
{
    /// <summary>
    /// Provides a set of methods for Premium Account Activity API.
    /// </summary>
    public partial class AccountActivityPremiumApi : ApiProviderBase
    {
        internal AccountActivityPremiumApi(TokensBase e) : base(e) { }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns all environments, webhook URLs and their statuses for the authenticating app.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list of environments object.</returns>
        public Environments Webhooks(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Environments>(MethodType.Get, "account_activity/all/webhooks", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns all environments, webhook URLs and their statuses for the authenticating app.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list of environments object.</returns>
        public Environments Webhooks(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Environments>(MethodType.Get, "account_activity/all/webhooks", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns all environments, webhook URLs and their statuses for the authenticating app.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list of environments object.</returns>
        public Environments Webhooks(object parameters)
        {
            return this.Tokens.AccessApi<Environments>(MethodType.Get, "account_activity/all/webhooks", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns all environments, webhook URLs and their statuses for the authenticating app.</para>
        /// </summary>
        /// <returns>The list of environments object.</returns>
        public Environments Webhooks()
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApi<Environments>(MethodType.Get, "account_activity/all/webhooks", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns all environments, webhook URLs and their statuses for the authenticating app.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list of environments object.</returns>
        public Task<Environments> WebhooksAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Environments>(MethodType.Get, "account_activity/all/webhooks", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns all environments, webhook URLs and their statuses for the authenticating app.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list of environments object.</returns>
        public Task<Environments> WebhooksAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Environments>(MethodType.Get, "account_activity/all/webhooks", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns all environments, webhook URLs and their statuses for the authenticating app.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list of environments object.</returns>
        public Task<Environments> WebhooksAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Environments>(MethodType.Get, "account_activity/all/webhooks", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns all environments, webhook URLs and their statuses for the authenticating app.</para>
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list of environments object.</returns>
        public Task<Environments> WebhooksAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiAsync<Environments>(MethodType.Get, "account_activity/all/webhooks", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the count of subscriptions that are currently active on your account for all activities.</para>
        /// <para>Note that the /count endpoint requires application-only OAuth, so that you should make requests using a bearer token instead of user context.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The count of subscriptions.</returns>
        public SubscriptionsCount SubscriptionsCount(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<SubscriptionsCount>(MethodType.Get, "account_activity/all/subscriptions/count", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the count of subscriptions that are currently active on your account for all activities.</para>
        /// <para>Note that the /count endpoint requires application-only OAuth, so that you should make requests using a bearer token instead of user context.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The count of subscriptions.</returns>
        public SubscriptionsCount SubscriptionsCount(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<SubscriptionsCount>(MethodType.Get, "account_activity/all/subscriptions/count", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the count of subscriptions that are currently active on your account for all activities.</para>
        /// <para>Note that the /count endpoint requires application-only OAuth, so that you should make requests using a bearer token instead of user context.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The count of subscriptions.</returns>
        public SubscriptionsCount SubscriptionsCount(object parameters)
        {
            return this.Tokens.AccessApi<SubscriptionsCount>(MethodType.Get, "account_activity/all/subscriptions/count", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the count of subscriptions that are currently active on your account for all activities.</para>
        /// <para>Note that the /count endpoint requires application-only OAuth, so that you should make requests using a bearer token instead of user context.</para>
        /// </summary>
        /// <returns>The count of subscriptions.</returns>
        public SubscriptionsCount SubscriptionsCount()
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApi<SubscriptionsCount>(MethodType.Get, "account_activity/all/subscriptions/count", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns the count of subscriptions that are currently active on your account for all activities.</para>
        /// <para>Note that the /count endpoint requires application-only OAuth, so that you should make requests using a bearer token instead of user context.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The count of subscriptions.</returns>
        public Task<SubscriptionsCount> SubscriptionsCountAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<SubscriptionsCount>(MethodType.Get, "account_activity/all/subscriptions/count", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the count of subscriptions that are currently active on your account for all activities.</para>
        /// <para>Note that the /count endpoint requires application-only OAuth, so that you should make requests using a bearer token instead of user context.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The count of subscriptions.</returns>
        public Task<SubscriptionsCount> SubscriptionsCountAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<SubscriptionsCount>(MethodType.Get, "account_activity/all/subscriptions/count", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the count of subscriptions that are currently active on your account for all activities.</para>
        /// <para>Note that the /count endpoint requires application-only OAuth, so that you should make requests using a bearer token instead of user context.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The count of subscriptions.</returns>
        public Task<SubscriptionsCount> SubscriptionsCountAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<SubscriptionsCount>(MethodType.Get, "account_activity/all/subscriptions/count", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the count of subscriptions that are currently active on your account for all activities.</para>
        /// <para>Note that the /count endpoint requires application-only OAuth, so that you should make requests using a bearer token instead of user context.</para>
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The count of subscriptions.</returns>
        public Task<SubscriptionsCount> SubscriptionsCountAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiAsync<SubscriptionsCount>(MethodType.Get, "account_activity/all/subscriptions/count", parameters, cancellationToken, urlPrefix: "1.1");
        }

    }

}
namespace CoreTweet.Rest
{
    /// <summary>
    /// Provides a set of methods for the wrapper of GET application.
    /// </summary>
    public partial class Application : ApiProviderBase
    {
        internal Application(TokensBase e) : base(e) { }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> resources (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> resources (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The dictionary.</returns>
        public DictionaryResponse<string, Dictionary<string,RateLimit>> RateLimitStatus(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiDictionary<string, Dictionary<string,RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, jsonPath: "resources", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> resources (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> resources (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The dictionary.</returns>
        public DictionaryResponse<string, Dictionary<string,RateLimit>> RateLimitStatus(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiDictionary<string, Dictionary<string,RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, jsonPath: "resources", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> resources (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> resources (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The dictionary.</returns>
        public DictionaryResponse<string, Dictionary<string,RateLimit>> RateLimitStatus(object parameters)
        {
            return this.Tokens.AccessApiDictionary<string, Dictionary<string,RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, jsonPath: "resources", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// </summary>
        /// <returns>The dictionary.</returns>
        public DictionaryResponse<string, Dictionary<string,RateLimit>> RateLimitStatus()
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiDictionary<string, Dictionary<string,RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, jsonPath: "resources", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// </summary>
        /// <param name="resources">any one is required.</param>
        /// <returns>The dictionary.</returns>
        public DictionaryResponse<string, Dictionary<string,RateLimit>> RateLimitStatus(string resources)
        {
            var parameters = new Dictionary<string, object>();
            if(resources == null) throw new ArgumentNullException("resources");
            parameters.Add("resources", resources);
            return this.Tokens.AccessApiDictionary<string, Dictionary<string,RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, jsonPath: "resources", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// </summary>
        /// <param name="resources">any one is required.</param>
        /// <returns>The dictionary.</returns>
        public DictionaryResponse<string, Dictionary<string,RateLimit>> RateLimitStatus(IEnumerable<string> resources)
        {
            var parameters = new Dictionary<string, object>();
            if(resources == null) throw new ArgumentNullException("resources");
            parameters.Add("resources", resources);
            return this.Tokens.AccessApiDictionary<string, Dictionary<string,RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, jsonPath: "resources", urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> resources (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> resources (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The dictionary.</returns>
        public Task<DictionaryResponse<string, Dictionary<string,RateLimit>>> RateLimitStatusAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiDictionaryAsync<string, Dictionary<string,RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, jsonPath: "resources", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> resources (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> resources (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The dictionary.</returns>
        public Task<DictionaryResponse<string, Dictionary<string,RateLimit>>> RateLimitStatusAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiDictionaryAsync<string, Dictionary<string,RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, cancellationToken, jsonPath: "resources", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> resources (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> resources (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The dictionary.</returns>
        public Task<DictionaryResponse<string, Dictionary<string,RateLimit>>> RateLimitStatusAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiDictionaryAsync<string, Dictionary<string,RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, cancellationToken, jsonPath: "resources", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The dictionary.</returns>
        public Task<DictionaryResponse<string, Dictionary<string,RateLimit>>> RateLimitStatusAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiDictionaryAsync<string, Dictionary<string,RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, cancellationToken, jsonPath: "resources", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// </summary>
        /// <param name="resources">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The dictionary.</returns>
        public Task<DictionaryResponse<string, Dictionary<string,RateLimit>>> RateLimitStatusAsync(string resources, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(resources == null) throw new ArgumentNullException("resources");
            parameters.Add("resources", resources);
            return this.Tokens.AccessApiDictionaryAsync<string, Dictionary<string,RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, cancellationToken, jsonPath: "resources", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// </summary>
        /// <param name="resources">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The dictionary.</returns>
        public Task<DictionaryResponse<string, Dictionary<string,RateLimit>>> RateLimitStatusAsync(IEnumerable<string> resources, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(resources == null) throw new ArgumentNullException("resources");
            parameters.Add("resources", resources);
            return this.Tokens.AccessApiDictionaryAsync<string, Dictionary<string,RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, cancellationToken, jsonPath: "resources", urlPrefix: "1.1");
        }

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET/POST blocks.
    /// </summary>
    public partial class Blocks : ApiProviderBase
    {
        internal Blocks(TokensBase e) : base(e) { }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>IDs.</returns>
        public Cursored<long> Ids(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "blocks/ids", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>IDs.</returns>
        public Cursored<long> Ids(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "blocks/ids", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>IDs.</returns>
        public Cursored<long> Ids(object parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "blocks/ids", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// </summary>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>IDs.</returns>
        public IEnumerable<long> EnumerateIds(EnumerateMode mode, long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            return Cursored.Enumerate<long>(this.Tokens, "blocks/ids", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// </summary>
        /// <param name="cursor">semi-optional.</param>
        /// <returns>IDs.</returns>
        public Cursored<long> Ids(long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "blocks/ids", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>IDs.</returns>
        public IEnumerable<long> EnumerateIds(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored.Enumerate<long>(this.Tokens, "blocks/ids", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>IDs.</returns>
        public IEnumerable<long> EnumerateIds(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored.Enumerate<long>(this.Tokens, "blocks/ids", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>IDs.</returns>
        public IEnumerable<long> EnumerateIds(EnumerateMode mode, object parameters)
        {
            return Cursored.Enumerate<long>(this.Tokens, "blocks/ids", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>IDs.</returns>
        public Task<Cursored<long>> IdsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "blocks/ids", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>IDs.</returns>
        public Task<Cursored<long>> IdsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "blocks/ids", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>IDs.</returns>
        public Task<Cursored<long>> IdsAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "blocks/ids", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// </summary>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>IDs.</returns>
        public Task<Cursored<long>> IdsAsync(long? cursor = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "blocks/ids", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "blocks/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "blocks/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(object parameters)
        {
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "blocks/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// </summary>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, long? cursor = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return Cursored.Enumerate<User>(this.Tokens, "blocks/list", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// </summary>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(long? cursor = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "blocks/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored.Enumerate<User>(this.Tokens, "blocks/list", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored.Enumerate<User>(this.Tokens, "blocks/list", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, object parameters)
        {
            return Cursored.Enumerate<User>(this.Tokens, "blocks/list", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "blocks/list", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "blocks/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "blocks/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// </summary>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(long? cursor = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "blocks/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Blocks the specified user from following the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse Create(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "blocks/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Blocks the specified user from following the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse Create(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "blocks/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Blocks the specified user from following the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse Create(object parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "blocks/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Blocks the specified user from following the authenticating user.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse Create(string screen_name, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "blocks/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Blocks the specified user from following the authenticating user.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse Create(long user_id, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "blocks/create", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Blocks the specified user from following the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> CreateAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "blocks/create", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Blocks the specified user from following the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> CreateAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "blocks/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Blocks the specified user from following the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> CreateAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "blocks/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Blocks the specified user from following the authenticating user.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> CreateAsync(string screen_name, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "blocks/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Blocks the specified user from following the authenticating user.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> CreateAsync(long user_id, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "blocks/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Un-blocks the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse Destroy(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "blocks/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Un-blocks the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse Destroy(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "blocks/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Un-blocks the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse Destroy(object parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "blocks/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Un-blocks the user specified in the ID parameter for the authenticating user.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse Destroy(string screen_name, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "blocks/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Un-blocks the user specified in the ID parameter for the authenticating user.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse Destroy(long user_id, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "blocks/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Un-blocks the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> DestroyAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "blocks/destroy", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Un-blocks the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> DestroyAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "blocks/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Un-blocks the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> DestroyAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "blocks/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Un-blocks the user specified in the ID parameter for the authenticating user.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> DestroyAsync(string screen_name, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "blocks/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Un-blocks the user specified in the ID parameter for the authenticating user.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> DestroyAsync(long user_id, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "blocks/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET/POST collections.
    /// </summary>
    public partial class Collections : ApiProviderBase
    {
        internal Collections(TokensBase e) : base(e) { }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Find Collections created by a specific user or containing a specific curated Tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (optional)</para>
        /// <para>- <c>string</c> screen_name (optional)</para>
        /// <para>- <c>long</c> tweet_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The timelines.</returns>
        public CollectionsListResult List(params Expression<Func<string, object>>[] parameters)
        {
            return this.ListImpl(InternalUtils.ExpressionsToDictionary(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Find Collections created by a specific user or containing a specific curated Tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (optional)</para>
        /// <para>- <c>string</c> screen_name (optional)</para>
        /// <para>- <c>long</c> tweet_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The timelines.</returns>
        public CollectionsListResult List(IDictionary<string, object> parameters)
        {
            return this.ListImpl(parameters, "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Find Collections created by a specific user or containing a specific curated Tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (optional)</para>
        /// <para>- <c>string</c> screen_name (optional)</para>
        /// <para>- <c>long</c> tweet_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The timelines.</returns>
        public CollectionsListResult List(object parameters)
        {
            return this.ListImpl(InternalUtils.ResolveObject(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Find Collections created by a specific user or containing a specific curated Tweet.</para>
        /// </summary>
        /// <param name="user_id">optional.</param>
        /// <param name="screen_name">optional.</param>
        /// <param name="tweet_id">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <returns>The timelines.</returns>
        public CollectionsListResult List(long? user_id = null, string screen_name = null, long? tweet_id = null, int? count = null, string cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(user_id != null) parameters.Add("user_id", user_id);
            if(screen_name != null) parameters.Add("screen_name", screen_name);
            if(tweet_id != null) parameters.Add("tweet_id", tweet_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.ListImpl(parameters, "1.1", null);
        }
        #endif

        /// <summary>
        /// <para>Find Collections created by a specific user or containing a specific curated Tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (optional)</para>
        /// <para>- <c>string</c> screen_name (optional)</para>
        /// <para>- <c>long</c> tweet_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The timelines.</returns>
        public Task<CollectionsListResult> ListAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.ListAsyncImpl(InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, "1.1", null);
        }

        /// <summary>
        /// <para>Find Collections created by a specific user or containing a specific curated Tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (optional)</para>
        /// <para>- <c>string</c> screen_name (optional)</para>
        /// <para>- <c>long</c> tweet_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The timelines.</returns>
        public Task<CollectionsListResult> ListAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.ListAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Find Collections created by a specific user or containing a specific curated Tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (optional)</para>
        /// <para>- <c>string</c> screen_name (optional)</para>
        /// <para>- <c>long</c> tweet_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The timelines.</returns>
        public Task<CollectionsListResult> ListAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.ListAsyncImpl(InternalUtils.ResolveObject(parameters), cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Find Collections created by a specific user or containing a specific curated Tweet.</para>
        /// </summary>
        /// <param name="user_id">optional.</param>
        /// <param name="screen_name">optional.</param>
        /// <param name="tweet_id">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The timelines.</returns>
        public Task<CollectionsListResult> ListAsync(long? user_id = null, string screen_name = null, long? tweet_id = null, int? count = null, string cursor = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(user_id != null) parameters.Add("user_id", user_id);
            if(screen_name != null) parameters.Add("screen_name", screen_name);
            if(tweet_id != null) parameters.Add("tweet_id", tweet_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.ListAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Retrieve information associated with a specific Collection.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The timeline.</returns>
        public TimelineResponse Show(params Expression<Func<string, object>>[] parameters)
        {
            return this.ShowImpl(InternalUtils.ExpressionsToDictionary(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Retrieve information associated with a specific Collection.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The timeline.</returns>
        public TimelineResponse Show(IDictionary<string, object> parameters)
        {
            return this.ShowImpl(parameters, "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Retrieve information associated with a specific Collection.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The timeline.</returns>
        public TimelineResponse Show(object parameters)
        {
            return this.ShowImpl(InternalUtils.ResolveObject(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Retrieve information associated with a specific Collection.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <returns>The timeline.</returns>
        public TimelineResponse Show(string id)
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            return this.ShowImpl(parameters, "1.1", null);
        }
        #endif

        /// <summary>
        /// <para>Retrieve information associated with a specific Collection.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The timeline.</returns>
        public Task<TimelineResponse> ShowAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.ShowAsyncImpl(InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, "1.1", null);
        }

        /// <summary>
        /// <para>Retrieve information associated with a specific Collection.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The timeline.</returns>
        public Task<TimelineResponse> ShowAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.ShowAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Retrieve information associated with a specific Collection.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The timeline.</returns>
        public Task<TimelineResponse> ShowAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.ShowAsyncImpl(InternalUtils.ResolveObject(parameters), cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Retrieve information associated with a specific Collection.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The timeline.</returns>
        public Task<TimelineResponse> ShowAsync(string id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            return this.ShowAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Retrieve the identified Collection, presented as a list of the Tweets curated within.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> max_position (optional)</para>
        /// <para>- <c>long</c> min_position (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The entries.</returns>
        public CollectionEntriesResult Entries(params Expression<Func<string, object>>[] parameters)
        {
            return this.EntriesImpl(InternalUtils.ExpressionsToDictionary(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Retrieve the identified Collection, presented as a list of the Tweets curated within.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> max_position (optional)</para>
        /// <para>- <c>long</c> min_position (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The entries.</returns>
        public CollectionEntriesResult Entries(IDictionary<string, object> parameters)
        {
            return this.EntriesImpl(parameters, "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Retrieve the identified Collection, presented as a list of the Tweets curated within.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> max_position (optional)</para>
        /// <para>- <c>long</c> min_position (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The entries.</returns>
        public CollectionEntriesResult Entries(object parameters)
        {
            return this.EntriesImpl(InternalUtils.ResolveObject(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Retrieve the identified Collection, presented as a list of the Tweets curated within.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="count">optional.</param>
        /// <param name="max_position">optional.</param>
        /// <param name="min_position">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The entries.</returns>
        public CollectionEntriesResult Entries(string id, int? count = null, long? max_position = null, long? min_position = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            if(count != null) parameters.Add("count", count);
            if(max_position != null) parameters.Add("max_position", max_position);
            if(min_position != null) parameters.Add("min_position", min_position);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.EntriesImpl(parameters, "1.1", null);
        }
        #endif

        /// <summary>
        /// <para>Retrieve the identified Collection, presented as a list of the Tweets curated within.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> max_position (optional)</para>
        /// <para>- <c>long</c> min_position (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The entries.</returns>
        public Task<CollectionEntriesResult> EntriesAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.EntriesAsyncImpl(InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, "1.1", null);
        }

        /// <summary>
        /// <para>Retrieve the identified Collection, presented as a list of the Tweets curated within.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> max_position (optional)</para>
        /// <para>- <c>long</c> min_position (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The entries.</returns>
        public Task<CollectionEntriesResult> EntriesAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.EntriesAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Retrieve the identified Collection, presented as a list of the Tweets curated within.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> max_position (optional)</para>
        /// <para>- <c>long</c> min_position (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The entries.</returns>
        public Task<CollectionEntriesResult> EntriesAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.EntriesAsyncImpl(InternalUtils.ResolveObject(parameters), cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Retrieve the identified Collection, presented as a list of the Tweets curated within.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="count">optional.</param>
        /// <param name="max_position">optional.</param>
        /// <param name="min_position">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The entries.</returns>
        public Task<CollectionEntriesResult> EntriesAsync(string id, int? count = null, long? max_position = null, long? min_position = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            if(count != null) parameters.Add("count", count);
            if(max_position != null) parameters.Add("max_position", max_position);
            if(min_position != null) parameters.Add("min_position", min_position);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.EntriesAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Create a Collection owned by the currently authenticated user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (required)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// <para>- <c>string</c> url (optional)</para>
        /// <para>- <c>string</c> timeline_order (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The timeline.</returns>
        public TimelineResponse Create(params Expression<Func<string, object>>[] parameters)
        {
            return this.CreateImpl(InternalUtils.ExpressionsToDictionary(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Create a Collection owned by the currently authenticated user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (required)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// <para>- <c>string</c> url (optional)</para>
        /// <para>- <c>string</c> timeline_order (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The timeline.</returns>
        public TimelineResponse Create(IDictionary<string, object> parameters)
        {
            return this.CreateImpl(parameters, "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Create a Collection owned by the currently authenticated user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (required)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// <para>- <c>string</c> url (optional)</para>
        /// <para>- <c>string</c> timeline_order (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The timeline.</returns>
        public TimelineResponse Create(object parameters)
        {
            return this.CreateImpl(InternalUtils.ResolveObject(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Create a Collection owned by the currently authenticated user.</para>
        /// </summary>
        /// <param name="name">required.</param>
        /// <param name="description">optional.</param>
        /// <param name="url">optional.</param>
        /// <param name="timeline_order">optional.</param>
        /// <returns>The timeline.</returns>
        public TimelineResponse Create(string name, string description = null, string url = null, string timeline_order = null)
        {
            var parameters = new Dictionary<string, object>();
            if(name == null) throw new ArgumentNullException("name");
            parameters.Add("name", name);
            if(description != null) parameters.Add("description", description);
            if(url != null) parameters.Add("url", url);
            if(timeline_order != null) parameters.Add("timeline_order", timeline_order);
            return this.CreateImpl(parameters, "1.1", null);
        }
        #endif

        /// <summary>
        /// <para>Create a Collection owned by the currently authenticated user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (required)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// <para>- <c>string</c> url (optional)</para>
        /// <para>- <c>string</c> timeline_order (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The timeline.</returns>
        public Task<TimelineResponse> CreateAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.CreateAsyncImpl(InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, "1.1", null);
        }

        /// <summary>
        /// <para>Create a Collection owned by the currently authenticated user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (required)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// <para>- <c>string</c> url (optional)</para>
        /// <para>- <c>string</c> timeline_order (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The timeline.</returns>
        public Task<TimelineResponse> CreateAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.CreateAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Create a Collection owned by the currently authenticated user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (required)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// <para>- <c>string</c> url (optional)</para>
        /// <para>- <c>string</c> timeline_order (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The timeline.</returns>
        public Task<TimelineResponse> CreateAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.CreateAsyncImpl(InternalUtils.ResolveObject(parameters), cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Create a Collection owned by the currently authenticated user.</para>
        /// </summary>
        /// <param name="name">required.</param>
        /// <param name="description">optional.</param>
        /// <param name="url">optional.</param>
        /// <param name="timeline_order">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The timeline.</returns>
        public Task<TimelineResponse> CreateAsync(string name, string description = null, string url = null, string timeline_order = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(name == null) throw new ArgumentNullException("name");
            parameters.Add("name", name);
            if(description != null) parameters.Add("description", description);
            if(url != null) parameters.Add("url", url);
            if(timeline_order != null) parameters.Add("timeline_order", timeline_order);
            return this.CreateAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Update information concerning a Collection owned by the currently authenticated user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// <para>- <c>string</c> url (optional)</para>
        /// <para>- <c>string</c> timeline_order (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The timeline.</returns>
        public TimelineResponse Update(params Expression<Func<string, object>>[] parameters)
        {
            return this.UpdateImpl(InternalUtils.ExpressionsToDictionary(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Update information concerning a Collection owned by the currently authenticated user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// <para>- <c>string</c> url (optional)</para>
        /// <para>- <c>string</c> timeline_order (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The timeline.</returns>
        public TimelineResponse Update(IDictionary<string, object> parameters)
        {
            return this.UpdateImpl(parameters, "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Update information concerning a Collection owned by the currently authenticated user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// <para>- <c>string</c> url (optional)</para>
        /// <para>- <c>string</c> timeline_order (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The timeline.</returns>
        public TimelineResponse Update(object parameters)
        {
            return this.UpdateImpl(InternalUtils.ResolveObject(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Update information concerning a Collection owned by the currently authenticated user.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="name">optional.</param>
        /// <param name="description">optional.</param>
        /// <param name="url">optional.</param>
        /// <param name="timeline_order">optional.</param>
        /// <returns>The timeline.</returns>
        public TimelineResponse Update(string id, string name = null, string description = null, string url = null, string timeline_order = null)
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            if(name != null) parameters.Add("name", name);
            if(description != null) parameters.Add("description", description);
            if(url != null) parameters.Add("url", url);
            if(timeline_order != null) parameters.Add("timeline_order", timeline_order);
            return this.UpdateImpl(parameters, "1.1", null);
        }
        #endif

        /// <summary>
        /// <para>Update information concerning a Collection owned by the currently authenticated user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// <para>- <c>string</c> url (optional)</para>
        /// <para>- <c>string</c> timeline_order (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The timeline.</returns>
        public Task<TimelineResponse> UpdateAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.UpdateAsyncImpl(InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, "1.1", null);
        }

        /// <summary>
        /// <para>Update information concerning a Collection owned by the currently authenticated user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// <para>- <c>string</c> url (optional)</para>
        /// <para>- <c>string</c> timeline_order (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The timeline.</returns>
        public Task<TimelineResponse> UpdateAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.UpdateAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Update information concerning a Collection owned by the currently authenticated user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// <para>- <c>string</c> url (optional)</para>
        /// <para>- <c>string</c> timeline_order (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The timeline.</returns>
        public Task<TimelineResponse> UpdateAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.UpdateAsyncImpl(InternalUtils.ResolveObject(parameters), cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Update information concerning a Collection owned by the currently authenticated user.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="name">optional.</param>
        /// <param name="description">optional.</param>
        /// <param name="url">optional.</param>
        /// <param name="timeline_order">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The timeline.</returns>
        public Task<TimelineResponse> UpdateAsync(string id, string name = null, string description = null, string url = null, string timeline_order = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            if(name != null) parameters.Add("name", name);
            if(description != null) parameters.Add("description", description);
            if(url != null) parameters.Add("url", url);
            if(timeline_order != null) parameters.Add("timeline_order", timeline_order);
            return this.UpdateAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Permanently delete a Collection owned by the currently authenticated user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The value that indicates whether the operation has been succeeded.</returns>
        public CollectionDestroyResult Destroy(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<CollectionDestroyResult>(MethodType.Post, "collections/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Permanently delete a Collection owned by the currently authenticated user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The value that indicates whether the operation has been succeeded.</returns>
        public CollectionDestroyResult Destroy(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<CollectionDestroyResult>(MethodType.Post, "collections/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Permanently delete a Collection owned by the currently authenticated user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The value that indicates whether the operation has been succeeded.</returns>
        public CollectionDestroyResult Destroy(object parameters)
        {
            return this.Tokens.AccessApi<CollectionDestroyResult>(MethodType.Post, "collections/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Permanently delete a Collection owned by the currently authenticated user.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <returns>The value that indicates whether the operation has been succeeded.</returns>
        public CollectionDestroyResult Destroy(string id)
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            return this.Tokens.AccessApi<CollectionDestroyResult>(MethodType.Post, "collections/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Permanently delete a Collection owned by the currently authenticated user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The value that indicates whether the operation has been succeeded.</returns>
        public Task<CollectionDestroyResult> DestroyAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<CollectionDestroyResult>(MethodType.Post, "collections/destroy", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Permanently delete a Collection owned by the currently authenticated user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The value that indicates whether the operation has been succeeded.</returns>
        public Task<CollectionDestroyResult> DestroyAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<CollectionDestroyResult>(MethodType.Post, "collections/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Permanently delete a Collection owned by the currently authenticated user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The value that indicates whether the operation has been succeeded.</returns>
        public Task<CollectionDestroyResult> DestroyAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<CollectionDestroyResult>(MethodType.Post, "collections/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Permanently delete a Collection owned by the currently authenticated user.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The value that indicates whether the operation has been succeeded.</returns>
        public Task<CollectionDestroyResult> DestroyAsync(string id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            return this.Tokens.AccessApiAsync<CollectionDestroyResult>(MethodType.Post, "collections/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Add a specified Tweet to a Collection.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>long</c> tweet_id (required)</para>
        /// <para>- <c>long</c> relative_to (optional)</para>
        /// <para>- <c>bool</c> above (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The errors.</returns>
        public ListedResponse<CollectionEntryOperationError> EntriesAdd(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<CollectionEntryOperationError>(MethodType.Post, "collections/entries/add", parameters, jsonPath: "response.errors", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Add a specified Tweet to a Collection.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>long</c> tweet_id (required)</para>
        /// <para>- <c>long</c> relative_to (optional)</para>
        /// <para>- <c>bool</c> above (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The errors.</returns>
        public ListedResponse<CollectionEntryOperationError> EntriesAdd(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<CollectionEntryOperationError>(MethodType.Post, "collections/entries/add", parameters, jsonPath: "response.errors", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Add a specified Tweet to a Collection.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>long</c> tweet_id (required)</para>
        /// <para>- <c>long</c> relative_to (optional)</para>
        /// <para>- <c>bool</c> above (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The errors.</returns>
        public ListedResponse<CollectionEntryOperationError> EntriesAdd(object parameters)
        {
            return this.Tokens.AccessApiArray<CollectionEntryOperationError>(MethodType.Post, "collections/entries/add", parameters, jsonPath: "response.errors", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Add a specified Tweet to a Collection.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="tweet_id">required.</param>
        /// <param name="relative_to">optional.</param>
        /// <param name="above">optional.</param>
        /// <returns>The errors.</returns>
        public ListedResponse<CollectionEntryOperationError> EntriesAdd(string id, long tweet_id, long? relative_to = null, bool? above = null)
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            parameters.Add("tweet_id", tweet_id);
            if(relative_to != null) parameters.Add("relative_to", relative_to);
            if(above != null) parameters.Add("above", above);
            return this.Tokens.AccessApiArray<CollectionEntryOperationError>(MethodType.Post, "collections/entries/add", parameters, jsonPath: "response.errors", urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Add a specified Tweet to a Collection.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>long</c> tweet_id (required)</para>
        /// <para>- <c>long</c> relative_to (optional)</para>
        /// <para>- <c>bool</c> above (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The errors.</returns>
        public Task<ListedResponse<CollectionEntryOperationError>> EntriesAddAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<CollectionEntryOperationError>(MethodType.Post, "collections/entries/add", parameters, jsonPath: "response.errors", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Add a specified Tweet to a Collection.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>long</c> tweet_id (required)</para>
        /// <para>- <c>long</c> relative_to (optional)</para>
        /// <para>- <c>bool</c> above (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The errors.</returns>
        public Task<ListedResponse<CollectionEntryOperationError>> EntriesAddAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<CollectionEntryOperationError>(MethodType.Post, "collections/entries/add", parameters, cancellationToken, jsonPath: "response.errors", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Add a specified Tweet to a Collection.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>long</c> tweet_id (required)</para>
        /// <para>- <c>long</c> relative_to (optional)</para>
        /// <para>- <c>bool</c> above (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The errors.</returns>
        public Task<ListedResponse<CollectionEntryOperationError>> EntriesAddAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<CollectionEntryOperationError>(MethodType.Post, "collections/entries/add", parameters, cancellationToken, jsonPath: "response.errors", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Add a specified Tweet to a Collection.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="tweet_id">required.</param>
        /// <param name="relative_to">optional.</param>
        /// <param name="above">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The errors.</returns>
        public Task<ListedResponse<CollectionEntryOperationError>> EntriesAddAsync(string id, long tweet_id, long? relative_to = null, bool? above = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            parameters.Add("tweet_id", tweet_id);
            if(relative_to != null) parameters.Add("relative_to", relative_to);
            if(above != null) parameters.Add("above", above);
            return this.Tokens.AccessApiArrayAsync<CollectionEntryOperationError>(MethodType.Post, "collections/entries/add", parameters, cancellationToken, jsonPath: "response.errors", urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Remove the specified Tweet from a Collection.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>long</c> tweet_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The errors.</returns>
        public ListedResponse<CollectionEntryOperationError> EntriesRemove(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<CollectionEntryOperationError>(MethodType.Post, "collections/entries/remove", parameters, jsonPath: "response.errors", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Remove the specified Tweet from a Collection.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>long</c> tweet_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The errors.</returns>
        public ListedResponse<CollectionEntryOperationError> EntriesRemove(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<CollectionEntryOperationError>(MethodType.Post, "collections/entries/remove", parameters, jsonPath: "response.errors", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Remove the specified Tweet from a Collection.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>long</c> tweet_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The errors.</returns>
        public ListedResponse<CollectionEntryOperationError> EntriesRemove(object parameters)
        {
            return this.Tokens.AccessApiArray<CollectionEntryOperationError>(MethodType.Post, "collections/entries/remove", parameters, jsonPath: "response.errors", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Remove the specified Tweet from a Collection.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="tweet_id">required.</param>
        /// <returns>The errors.</returns>
        public ListedResponse<CollectionEntryOperationError> EntriesRemove(string id, long tweet_id)
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            parameters.Add("tweet_id", tweet_id);
            return this.Tokens.AccessApiArray<CollectionEntryOperationError>(MethodType.Post, "collections/entries/remove", parameters, jsonPath: "response.errors", urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Remove the specified Tweet from a Collection.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>long</c> tweet_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The errors.</returns>
        public Task<ListedResponse<CollectionEntryOperationError>> EntriesRemoveAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<CollectionEntryOperationError>(MethodType.Post, "collections/entries/remove", parameters, jsonPath: "response.errors", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Remove the specified Tweet from a Collection.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>long</c> tweet_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The errors.</returns>
        public Task<ListedResponse<CollectionEntryOperationError>> EntriesRemoveAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<CollectionEntryOperationError>(MethodType.Post, "collections/entries/remove", parameters, cancellationToken, jsonPath: "response.errors", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Remove the specified Tweet from a Collection.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>long</c> tweet_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The errors.</returns>
        public Task<ListedResponse<CollectionEntryOperationError>> EntriesRemoveAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<CollectionEntryOperationError>(MethodType.Post, "collections/entries/remove", parameters, cancellationToken, jsonPath: "response.errors", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Remove the specified Tweet from a Collection.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="tweet_id">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The errors.</returns>
        public Task<ListedResponse<CollectionEntryOperationError>> EntriesRemoveAsync(string id, long tweet_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            parameters.Add("tweet_id", tweet_id);
            return this.Tokens.AccessApiArrayAsync<CollectionEntryOperationError>(MethodType.Post, "collections/entries/remove", parameters, cancellationToken, jsonPath: "response.errors", urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Move a specified Tweet to a new position in a curation_reverse_chron ordered collection.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>long</c> tweet_id (required)</para>
        /// <para>- <c>long</c> relative_to (required)</para>
        /// <para>- <c>bool</c> above (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The errors.</returns>
        public ListedResponse<CollectionEntryOperationError> EntriesMove(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<CollectionEntryOperationError>(MethodType.Post, "collections/entries/move", parameters, jsonPath: "response.errors", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Move a specified Tweet to a new position in a curation_reverse_chron ordered collection.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>long</c> tweet_id (required)</para>
        /// <para>- <c>long</c> relative_to (required)</para>
        /// <para>- <c>bool</c> above (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The errors.</returns>
        public ListedResponse<CollectionEntryOperationError> EntriesMove(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<CollectionEntryOperationError>(MethodType.Post, "collections/entries/move", parameters, jsonPath: "response.errors", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Move a specified Tweet to a new position in a curation_reverse_chron ordered collection.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>long</c> tweet_id (required)</para>
        /// <para>- <c>long</c> relative_to (required)</para>
        /// <para>- <c>bool</c> above (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The errors.</returns>
        public ListedResponse<CollectionEntryOperationError> EntriesMove(object parameters)
        {
            return this.Tokens.AccessApiArray<CollectionEntryOperationError>(MethodType.Post, "collections/entries/move", parameters, jsonPath: "response.errors", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Move a specified Tweet to a new position in a curation_reverse_chron ordered collection.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="tweet_id">required.</param>
        /// <param name="relative_to">required.</param>
        /// <param name="above">optional.</param>
        /// <returns>The errors.</returns>
        public ListedResponse<CollectionEntryOperationError> EntriesMove(string id, long tweet_id, long relative_to, bool? above = null)
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            parameters.Add("tweet_id", tweet_id);
            parameters.Add("relative_to", relative_to);
            if(above != null) parameters.Add("above", above);
            return this.Tokens.AccessApiArray<CollectionEntryOperationError>(MethodType.Post, "collections/entries/move", parameters, jsonPath: "response.errors", urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Move a specified Tweet to a new position in a curation_reverse_chron ordered collection.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>long</c> tweet_id (required)</para>
        /// <para>- <c>long</c> relative_to (required)</para>
        /// <para>- <c>bool</c> above (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The errors.</returns>
        public Task<ListedResponse<CollectionEntryOperationError>> EntriesMoveAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<CollectionEntryOperationError>(MethodType.Post, "collections/entries/move", parameters, jsonPath: "response.errors", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Move a specified Tweet to a new position in a curation_reverse_chron ordered collection.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>long</c> tweet_id (required)</para>
        /// <para>- <c>long</c> relative_to (required)</para>
        /// <para>- <c>bool</c> above (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The errors.</returns>
        public Task<ListedResponse<CollectionEntryOperationError>> EntriesMoveAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<CollectionEntryOperationError>(MethodType.Post, "collections/entries/move", parameters, cancellationToken, jsonPath: "response.errors", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Move a specified Tweet to a new position in a curation_reverse_chron ordered collection.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>long</c> tweet_id (required)</para>
        /// <para>- <c>long</c> relative_to (required)</para>
        /// <para>- <c>bool</c> above (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The errors.</returns>
        public Task<ListedResponse<CollectionEntryOperationError>> EntriesMoveAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<CollectionEntryOperationError>(MethodType.Post, "collections/entries/move", parameters, cancellationToken, jsonPath: "response.errors", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Move a specified Tweet to a new position in a curation_reverse_chron ordered collection.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="tweet_id">required.</param>
        /// <param name="relative_to">required.</param>
        /// <param name="above">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The errors.</returns>
        public Task<ListedResponse<CollectionEntryOperationError>> EntriesMoveAsync(string id, long tweet_id, long relative_to, bool? above = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            parameters.Add("tweet_id", tweet_id);
            parameters.Add("relative_to", relative_to);
            if(above != null) parameters.Add("above", above);
            return this.Tokens.AccessApiArrayAsync<CollectionEntryOperationError>(MethodType.Post, "collections/entries/move", parameters, cancellationToken, jsonPath: "response.errors", urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Curate a Collection by adding or removing Tweets in bulk.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>IEnumerable&lt;CollectionEntryChange&gt;</c> changes (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The errors.</returns>
        public ListedResponse<CollectionEntryOperationError> EntriesCurate(params Expression<Func<string, object>>[] parameters)
        {
            var jm = new string[4];
            jm[0] = "{";
            jm[1] = "\"id\": $id,";
            jm[2] = "\"changes\": $changes";
            jm[3] = "}";
            return this.Tokens.AccessJsonParameteredApiArray<CollectionEntryOperationError>("collections/entries/curate", parameters, jm, jsonPath: "response.errors", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Curate a Collection by adding or removing Tweets in bulk.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>IEnumerable&lt;CollectionEntryChange&gt;</c> changes (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The errors.</returns>
        public ListedResponse<CollectionEntryOperationError> EntriesCurate(IDictionary<string, object> parameters)
        {
            var jm = new string[4];
            jm[0] = "{";
            jm[1] = "\"id\": $id,";
            jm[2] = "\"changes\": $changes";
            jm[3] = "}";
            return this.Tokens.AccessJsonParameteredApiArray<CollectionEntryOperationError>("collections/entries/curate", parameters, jm, jsonPath: "response.errors", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Curate a Collection by adding or removing Tweets in bulk.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>IEnumerable&lt;CollectionEntryChange&gt;</c> changes (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The errors.</returns>
        public ListedResponse<CollectionEntryOperationError> EntriesCurate(object parameters)
        {
            var jm = new string[4];
            jm[0] = "{";
            jm[1] = "\"id\": $id,";
            jm[2] = "\"changes\": $changes";
            jm[3] = "}";
            return this.Tokens.AccessJsonParameteredApiArray<CollectionEntryOperationError>("collections/entries/curate", parameters, jm, jsonPath: "response.errors", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Curate a Collection by adding or removing Tweets in bulk.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="changes">required.</param>
        /// <returns>The errors.</returns>
        public ListedResponse<CollectionEntryOperationError> EntriesCurate(string id, IEnumerable<CollectionEntryChange> changes)
        {
            var jm = new string[4];
            jm[0] = "{";
            jm[1] = "\"id\": $id,";
            jm[2] = "\"changes\": $changes";
            jm[3] = "}";
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            if(changes == null) throw new ArgumentNullException("changes");
            parameters.Add("changes", changes);
            return this.Tokens.AccessJsonParameteredApiArray<CollectionEntryOperationError>("collections/entries/curate", parameters, jm, jsonPath: "response.errors", urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Curate a Collection by adding or removing Tweets in bulk.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>IEnumerable&lt;CollectionEntryChange&gt;</c> changes (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The errors.</returns>
        public Task<ListedResponse<CollectionEntryOperationError>> EntriesCurateAsync(params Expression<Func<string, object>>[] parameters)
        {
            var jm = new string[4];
            jm[0] = "{";
            jm[1] = "\"id\": $id,";
            jm[2] = "\"changes\": $changes";
            jm[3] = "}";
            return this.Tokens.AccessJsonParameteredApiArrayAsync<CollectionEntryOperationError>("collections/entries/curate", parameters, jm, jsonPath: "response.errors", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Curate a Collection by adding or removing Tweets in bulk.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>IEnumerable&lt;CollectionEntryChange&gt;</c> changes (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The errors.</returns>
        public Task<ListedResponse<CollectionEntryOperationError>> EntriesCurateAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            var jm = new string[4];
            jm[0] = "{";
            jm[1] = "\"id\": $id,";
            jm[2] = "\"changes\": $changes";
            jm[3] = "}";
            return this.Tokens.AccessJsonParameteredApiArrayAsync<CollectionEntryOperationError>("collections/entries/curate", parameters, jm, cancellationToken, jsonPath: "response.errors", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Curate a Collection by adding or removing Tweets in bulk.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// <para>- <c>IEnumerable&lt;CollectionEntryChange&gt;</c> changes (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The errors.</returns>
        public Task<ListedResponse<CollectionEntryOperationError>> EntriesCurateAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            var jm = new string[4];
            jm[0] = "{";
            jm[1] = "\"id\": $id,";
            jm[2] = "\"changes\": $changes";
            jm[3] = "}";
            return this.Tokens.AccessJsonParameteredApiArrayAsync<CollectionEntryOperationError>("collections/entries/curate", parameters, jm, cancellationToken, jsonPath: "response.errors", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Curate a Collection by adding or removing Tweets in bulk.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="changes">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The errors.</returns>
        public Task<ListedResponse<CollectionEntryOperationError>> EntriesCurateAsync(string id, IEnumerable<CollectionEntryChange> changes, CancellationToken cancellationToken = default(CancellationToken))
        {
            var jm = new string[4];
            jm[0] = "{";
            jm[1] = "\"id\": $id,";
            jm[2] = "\"changes\": $changes";
            jm[3] = "}";
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            if(changes == null) throw new ArgumentNullException("changes");
            parameters.Add("changes", changes);
            return this.Tokens.AccessJsonParameteredApiArrayAsync<CollectionEntryOperationError>("collections/entries/curate", parameters, jm, cancellationToken, jsonPath: "response.errors", urlPrefix: "1.1");
        }

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET/POST direct_messages.
    /// </summary>
    public partial class DirectMessages : ApiProviderBase
    {
        internal DirectMessages(TokensBase e) : base(e) { }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the most recent direct messages sent to the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>bool</c> full_text (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct messages.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public ListedResponse<DirectMessage> Received(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<DirectMessage>(MethodType.Get, "direct_messages", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the most recent direct messages sent to the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>bool</c> full_text (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct messages.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public ListedResponse<DirectMessage> Received(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<DirectMessage>(MethodType.Get, "direct_messages", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the most recent direct messages sent to the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>bool</c> full_text (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct messages.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public ListedResponse<DirectMessage> Received(object parameters)
        {
            return this.Tokens.AccessApiArray<DirectMessage>(MethodType.Get, "direct_messages", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the most recent direct messages sent to the authenticating user.</para>
        /// </summary>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="page">optional.</param>
        /// <param name="full_text">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <returns>The direct messages.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public ListedResponse<DirectMessage> Received(long? since_id = null, long? max_id = null, int? count = null, int? page = null, bool? full_text = null, bool? include_entities = null)
        {
            var parameters = new Dictionary<string, object>();
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(count != null) parameters.Add("count", count);
            if(page != null) parameters.Add("page", page);
            if(full_text != null) parameters.Add("full_text", full_text);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApiArray<DirectMessage>(MethodType.Get, "direct_messages", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns the most recent direct messages sent to the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>bool</c> full_text (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct messages.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public Task<ListedResponse<DirectMessage>> ReceivedAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<DirectMessage>(MethodType.Get, "direct_messages", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the most recent direct messages sent to the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>bool</c> full_text (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The direct messages.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public Task<ListedResponse<DirectMessage>> ReceivedAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<DirectMessage>(MethodType.Get, "direct_messages", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the most recent direct messages sent to the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>bool</c> full_text (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The direct messages.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public Task<ListedResponse<DirectMessage>> ReceivedAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<DirectMessage>(MethodType.Get, "direct_messages", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the most recent direct messages sent to the authenticating user.</para>
        /// </summary>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="page">optional.</param>
        /// <param name="full_text">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The direct messages.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public Task<ListedResponse<DirectMessage>> ReceivedAsync(long? since_id = null, long? max_id = null, int? count = null, int? page = null, bool? full_text = null, bool? include_entities = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(count != null) parameters.Add("count", count);
            if(page != null) parameters.Add("page", page);
            if(full_text != null) parameters.Add("full_text", full_text);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApiArrayAsync<DirectMessage>(MethodType.Get, "direct_messages", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the most recent direct messages sent by the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>bool</c> full_text (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct messages.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public ListedResponse<DirectMessage> Sent(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<DirectMessage>(MethodType.Get, "direct_messages/sent", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the most recent direct messages sent by the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>bool</c> full_text (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct messages.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public ListedResponse<DirectMessage> Sent(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<DirectMessage>(MethodType.Get, "direct_messages/sent", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the most recent direct messages sent by the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>bool</c> full_text (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct messages.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public ListedResponse<DirectMessage> Sent(object parameters)
        {
            return this.Tokens.AccessApiArray<DirectMessage>(MethodType.Get, "direct_messages/sent", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the most recent direct messages sent by the authenticating user.</para>
        /// </summary>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="page">optional.</param>
        /// <param name="full_text">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <returns>The direct messages.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public ListedResponse<DirectMessage> Sent(long? since_id = null, long? max_id = null, int? count = null, int? page = null, bool? full_text = null, bool? include_entities = null)
        {
            var parameters = new Dictionary<string, object>();
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(count != null) parameters.Add("count", count);
            if(page != null) parameters.Add("page", page);
            if(full_text != null) parameters.Add("full_text", full_text);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApiArray<DirectMessage>(MethodType.Get, "direct_messages/sent", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns the most recent direct messages sent by the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>bool</c> full_text (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct messages.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public Task<ListedResponse<DirectMessage>> SentAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<DirectMessage>(MethodType.Get, "direct_messages/sent", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the most recent direct messages sent by the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>bool</c> full_text (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The direct messages.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public Task<ListedResponse<DirectMessage>> SentAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<DirectMessage>(MethodType.Get, "direct_messages/sent", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the most recent direct messages sent by the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>bool</c> full_text (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The direct messages.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public Task<ListedResponse<DirectMessage>> SentAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<DirectMessage>(MethodType.Get, "direct_messages/sent", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the most recent direct messages sent by the authenticating user.</para>
        /// </summary>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="page">optional.</param>
        /// <param name="full_text">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The direct messages.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public Task<ListedResponse<DirectMessage>> SentAsync(long? since_id = null, long? max_id = null, int? count = null, int? page = null, bool? full_text = null, bool? include_entities = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(count != null) parameters.Add("count", count);
            if(page != null) parameters.Add("page", page);
            if(full_text != null) parameters.Add("full_text", full_text);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApiArrayAsync<DirectMessage>(MethodType.Get, "direct_messages/sent", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a single direct message, specified by an id parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id  (required)</para>
        /// <para>- <c>bool</c> full_text (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct message.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public DirectMessageResponse Show(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<DirectMessageResponse>(MethodType.Get, "direct_messages/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a single direct message, specified by an id parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id  (required)</para>
        /// <para>- <c>bool</c> full_text (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct message.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public DirectMessageResponse Show(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<DirectMessageResponse>(MethodType.Get, "direct_messages/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a single direct message, specified by an id parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id  (required)</para>
        /// <para>- <c>bool</c> full_text (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct message.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public DirectMessageResponse Show(object parameters)
        {
            return this.Tokens.AccessApi<DirectMessageResponse>(MethodType.Get, "direct_messages/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a single direct message, specified by an id parameter.</para>
        /// </summary>
        /// <param name="id ">required.</param>
        /// <param name="full_text">optional.</param>
        /// <returns>The direct message.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public DirectMessageResponse Show(long id , bool? full_text = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id ", id );
            if(full_text != null) parameters.Add("full_text", full_text);
            return this.Tokens.AccessApi<DirectMessageResponse>(MethodType.Get, "direct_messages/show", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns a single direct message, specified by an id parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id  (required)</para>
        /// <para>- <c>bool</c> full_text (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct message.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public Task<DirectMessageResponse> ShowAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<DirectMessageResponse>(MethodType.Get, "direct_messages/show", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a single direct message, specified by an id parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id  (required)</para>
        /// <para>- <c>bool</c> full_text (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The direct message.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public Task<DirectMessageResponse> ShowAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<DirectMessageResponse>(MethodType.Get, "direct_messages/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a single direct message, specified by an id parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id  (required)</para>
        /// <para>- <c>bool</c> full_text (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The direct message.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public Task<DirectMessageResponse> ShowAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<DirectMessageResponse>(MethodType.Get, "direct_messages/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a single direct message, specified by an id parameter.</para>
        /// </summary>
        /// <param name="id ">required.</param>
        /// <param name="full_text">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The direct message.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public Task<DirectMessageResponse> ShowAsync(long id , bool? full_text = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id ", id );
            if(full_text != null) parameters.Add("full_text", full_text);
            return this.Tokens.AccessApiAsync<DirectMessageResponse>(MethodType.Get, "direct_messages/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Sends a new direct message to the specified user from the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>string</c> text  (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct message.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public DirectMessageResponse New(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<DirectMessageResponse>(MethodType.Post, "direct_messages/new", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Sends a new direct message to the specified user from the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>string</c> text  (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct message.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public DirectMessageResponse New(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<DirectMessageResponse>(MethodType.Post, "direct_messages/new", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Sends a new direct message to the specified user from the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>string</c> text  (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct message.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public DirectMessageResponse New(object parameters)
        {
            return this.Tokens.AccessApi<DirectMessageResponse>(MethodType.Post, "direct_messages/new", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Sends a new direct message to the specified user from the authenticating user.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="text ">required.</param>
        /// <returns>The direct message.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public DirectMessageResponse New(long user_id, string text )
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(text  == null) throw new ArgumentNullException("text ");
            parameters.Add("text ", text );
            return this.Tokens.AccessApi<DirectMessageResponse>(MethodType.Post, "direct_messages/new", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Sends a new direct message to the specified user from the authenticating user.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="text ">required.</param>
        /// <returns>The direct message.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public DirectMessageResponse New(string screen_name, string text )
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(text  == null) throw new ArgumentNullException("text ");
            parameters.Add("text ", text );
            return this.Tokens.AccessApi<DirectMessageResponse>(MethodType.Post, "direct_messages/new", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Sends a new direct message to the specified user from the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>string</c> text  (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct message.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public Task<DirectMessageResponse> NewAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<DirectMessageResponse>(MethodType.Post, "direct_messages/new", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Sends a new direct message to the specified user from the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>string</c> text  (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The direct message.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public Task<DirectMessageResponse> NewAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<DirectMessageResponse>(MethodType.Post, "direct_messages/new", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Sends a new direct message to the specified user from the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>string</c> text  (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The direct message.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public Task<DirectMessageResponse> NewAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<DirectMessageResponse>(MethodType.Post, "direct_messages/new", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Sends a new direct message to the specified user from the authenticating user.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="text ">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The direct message.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public Task<DirectMessageResponse> NewAsync(long user_id, string text , CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(text  == null) throw new ArgumentNullException("text ");
            parameters.Add("text ", text );
            return this.Tokens.AccessApiAsync<DirectMessageResponse>(MethodType.Post, "direct_messages/new", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Sends a new direct message to the specified user from the authenticating user.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="text ">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The direct message.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public Task<DirectMessageResponse> NewAsync(string screen_name, string text , CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(text  == null) throw new ArgumentNullException("text ");
            parameters.Add("text ", text );
            return this.Tokens.AccessApiAsync<DirectMessageResponse>(MethodType.Post, "direct_messages/new", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Destroys the direct message specified in the required ID parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities  (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct message.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public DirectMessageResponse Destroy(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<DirectMessageResponse>(MethodType.Post, "direct_messages/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Destroys the direct message specified in the required ID parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities  (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct message.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public DirectMessageResponse Destroy(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<DirectMessageResponse>(MethodType.Post, "direct_messages/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Destroys the direct message specified in the required ID parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities  (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct message.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public DirectMessageResponse Destroy(object parameters)
        {
            return this.Tokens.AccessApi<DirectMessageResponse>(MethodType.Post, "direct_messages/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Destroys the direct message specified in the required ID parameter.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="include_entities ">optional.</param>
        /// <returns>The direct message.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public DirectMessageResponse Destroy(long id, bool? include_entities  = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(include_entities  != null) parameters.Add("include_entities ", include_entities );
            return this.Tokens.AccessApi<DirectMessageResponse>(MethodType.Post, "direct_messages/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Destroys the direct message specified in the required ID parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities  (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct message.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public Task<DirectMessageResponse> DestroyAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<DirectMessageResponse>(MethodType.Post, "direct_messages/destroy", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Destroys the direct message specified in the required ID parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities  (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The direct message.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public Task<DirectMessageResponse> DestroyAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<DirectMessageResponse>(MethodType.Post, "direct_messages/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Destroys the direct message specified in the required ID parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities  (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The direct message.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public Task<DirectMessageResponse> DestroyAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<DirectMessageResponse>(MethodType.Post, "direct_messages/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Destroys the direct message specified in the required ID parameter.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="include_entities ">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The direct message.</returns>
        [Obsolete("This endpoint has been retired on Aug 16, 2018.", false)]
        public Task<DirectMessageResponse> DestroyAsync(long id, bool? include_entities  = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(include_entities  != null) parameters.Add("include_entities ", include_entities );
            return this.Tokens.AccessApiAsync<DirectMessageResponse>(MethodType.Post, "direct_messages/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Marks a message as read in the recipient’s Direct Message conversation view with the sender.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> last_read_event_id (required)</para>
        /// <para>- <c>long</c> recipient_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void MarkRead(params Expression<Func<string, object>>[] parameters)
        {
            this.Tokens.AccessApiNoResponse(MethodType.Post, "direct_messages/mark_read", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Marks a message as read in the recipient’s Direct Message conversation view with the sender.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> last_read_event_id (required)</para>
        /// <para>- <c>long</c> recipient_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void MarkRead(IDictionary<string, object> parameters)
        {
            this.Tokens.AccessApiNoResponse(MethodType.Post, "direct_messages/mark_read", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Marks a message as read in the recipient’s Direct Message conversation view with the sender.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> last_read_event_id (required)</para>
        /// <para>- <c>long</c> recipient_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void MarkRead(object parameters)
        {
            this.Tokens.AccessApiNoResponse(MethodType.Post, "direct_messages/mark_read", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Marks a message as read in the recipient’s Direct Message conversation view with the sender.</para>
        /// </summary>
        /// <param name="last_read_event_id">required.</param>
        /// <param name="recipient_id">required.</param>
        /// <returns></returns>
        public void MarkRead(long last_read_event_id, long recipient_id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("last_read_event_id", last_read_event_id);
            parameters.Add("recipient_id", recipient_id);
            this.Tokens.AccessApiNoResponse(MethodType.Post, "direct_messages/mark_read", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Marks a message as read in the recipient’s Direct Message conversation view with the sender.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> last_read_event_id (required)</para>
        /// <para>- <c>long</c> recipient_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public Task MarkReadAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiNoResponseAsync(MethodType.Post, "direct_messages/mark_read", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Marks a message as read in the recipient’s Direct Message conversation view with the sender.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> last_read_event_id (required)</para>
        /// <para>- <c>long</c> recipient_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task MarkReadAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiNoResponseAsync(MethodType.Post, "direct_messages/mark_read", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Marks a message as read in the recipient’s Direct Message conversation view with the sender.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> last_read_event_id (required)</para>
        /// <para>- <c>long</c> recipient_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task MarkReadAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiNoResponseAsync(MethodType.Post, "direct_messages/mark_read", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Marks a message as read in the recipient’s Direct Message conversation view with the sender.</para>
        /// </summary>
        /// <param name="last_read_event_id">required.</param>
        /// <param name="recipient_id">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task MarkReadAsync(long last_read_event_id, long recipient_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("last_read_event_id", last_read_event_id);
            parameters.Add("recipient_id", recipient_id);
            return this.Tokens.AccessApiNoResponseAsync(MethodType.Post, "direct_messages/mark_read", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Displays a visual typing indicator in the recipient’s Direct Message conversation view with the sender.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> recipient_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void IndicateTyping(params Expression<Func<string, object>>[] parameters)
        {
            this.Tokens.AccessApiNoResponse(MethodType.Post, "direct_messages/indicate_typing", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Displays a visual typing indicator in the recipient’s Direct Message conversation view with the sender.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> recipient_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void IndicateTyping(IDictionary<string, object> parameters)
        {
            this.Tokens.AccessApiNoResponse(MethodType.Post, "direct_messages/indicate_typing", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Displays a visual typing indicator in the recipient’s Direct Message conversation view with the sender.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> recipient_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void IndicateTyping(object parameters)
        {
            this.Tokens.AccessApiNoResponse(MethodType.Post, "direct_messages/indicate_typing", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Displays a visual typing indicator in the recipient’s Direct Message conversation view with the sender.</para>
        /// </summary>
        /// <param name="recipient_id">required.</param>
        /// <returns></returns>
        public void IndicateTyping(long recipient_id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("recipient_id", recipient_id);
            this.Tokens.AccessApiNoResponse(MethodType.Post, "direct_messages/indicate_typing", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Displays a visual typing indicator in the recipient’s Direct Message conversation view with the sender.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> recipient_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public Task IndicateTypingAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiNoResponseAsync(MethodType.Post, "direct_messages/indicate_typing", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Displays a visual typing indicator in the recipient’s Direct Message conversation view with the sender.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> recipient_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task IndicateTypingAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiNoResponseAsync(MethodType.Post, "direct_messages/indicate_typing", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Displays a visual typing indicator in the recipient’s Direct Message conversation view with the sender.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> recipient_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task IndicateTypingAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiNoResponseAsync(MethodType.Post, "direct_messages/indicate_typing", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Displays a visual typing indicator in the recipient’s Direct Message conversation view with the sender.</para>
        /// </summary>
        /// <param name="recipient_id">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task IndicateTypingAsync(long recipient_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("recipient_id", recipient_id);
            return this.Tokens.AccessApiNoResponseAsync(MethodType.Post, "direct_messages/indicate_typing", parameters, cancellationToken, urlPrefix: "1.1");
        }

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET/POST direct_messages/events.
    /// </summary>
    public partial class DirectMessagesEvents : ApiProviderBase
    {
        internal DirectMessagesEvents(TokensBase e) : base(e) { }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Publishes a new message_create event resulting in a Direct Message sent to a specified user from the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> text (required)</para>
        /// <para>- <c>long</c> recipient_id (required)</para>
        /// <para>- <c>QuickReply</c> quick_reply (optional)</para>
        /// <para>- <c>string</c> attachment_type (optional)</para>
        /// <para>- <c>long</c> attachment_media_id (optional)</para>
        /// <para>- <c>IEnumerable&lt;MessageCallToAction&gt;</c> ctas (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The published event.</returns>
        public MessageCreateEventResponse New(params Expression<Func<string, object>>[] parameters)
        {
            var jm = new string[12];
            jm[0] = "{\"event\": {\"type\": \"message_create\",\"message_create\": {\"target\": {";
            jm[1] = "\"recipient_id\": $recipient_id";
            jm[2] = "},\"message_data\": {";
            jm[3] = "\"text\": $text,";
            jm[4] = "\"quick_reply\": $quick_reply,";
            jm[5] = "\"attachment\": {";
            jm[6] = "\"type\": $attachment_type,";
            jm[7] = "\"media\": {";
            jm[8] = "\"id\": $attachment_media_id";
            jm[9] = "}},";
            jm[10] = "\"ctas\": $ctas";
            jm[11] = "}}}}";
            return this.Tokens.AccessJsonParameteredApi<MessageCreateEventResponse>("direct_messages/events/new", parameters, jm, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Publishes a new message_create event resulting in a Direct Message sent to a specified user from the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> text (required)</para>
        /// <para>- <c>long</c> recipient_id (required)</para>
        /// <para>- <c>QuickReply</c> quick_reply (optional)</para>
        /// <para>- <c>string</c> attachment_type (optional)</para>
        /// <para>- <c>long</c> attachment_media_id (optional)</para>
        /// <para>- <c>IEnumerable&lt;MessageCallToAction&gt;</c> ctas (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The published event.</returns>
        public MessageCreateEventResponse New(IDictionary<string, object> parameters)
        {
            var jm = new string[12];
            jm[0] = "{\"event\": {\"type\": \"message_create\",\"message_create\": {\"target\": {";
            jm[1] = "\"recipient_id\": $recipient_id";
            jm[2] = "},\"message_data\": {";
            jm[3] = "\"text\": $text,";
            jm[4] = "\"quick_reply\": $quick_reply,";
            jm[5] = "\"attachment\": {";
            jm[6] = "\"type\": $attachment_type,";
            jm[7] = "\"media\": {";
            jm[8] = "\"id\": $attachment_media_id";
            jm[9] = "}},";
            jm[10] = "\"ctas\": $ctas";
            jm[11] = "}}}}";
            return this.Tokens.AccessJsonParameteredApi<MessageCreateEventResponse>("direct_messages/events/new", parameters, jm, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Publishes a new message_create event resulting in a Direct Message sent to a specified user from the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> text (required)</para>
        /// <para>- <c>long</c> recipient_id (required)</para>
        /// <para>- <c>QuickReply</c> quick_reply (optional)</para>
        /// <para>- <c>string</c> attachment_type (optional)</para>
        /// <para>- <c>long</c> attachment_media_id (optional)</para>
        /// <para>- <c>IEnumerable&lt;MessageCallToAction&gt;</c> ctas (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The published event.</returns>
        public MessageCreateEventResponse New(object parameters)
        {
            var jm = new string[12];
            jm[0] = "{\"event\": {\"type\": \"message_create\",\"message_create\": {\"target\": {";
            jm[1] = "\"recipient_id\": $recipient_id";
            jm[2] = "},\"message_data\": {";
            jm[3] = "\"text\": $text,";
            jm[4] = "\"quick_reply\": $quick_reply,";
            jm[5] = "\"attachment\": {";
            jm[6] = "\"type\": $attachment_type,";
            jm[7] = "\"media\": {";
            jm[8] = "\"id\": $attachment_media_id";
            jm[9] = "}},";
            jm[10] = "\"ctas\": $ctas";
            jm[11] = "}}}}";
            return this.Tokens.AccessJsonParameteredApi<MessageCreateEventResponse>("direct_messages/events/new", parameters, jm, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Publishes a new message_create event resulting in a Direct Message sent to a specified user from the authenticating user.</para>
        /// </summary>
        /// <param name="text">required.</param>
        /// <param name="recipient_id">required.</param>
        /// <param name="quick_reply">optional.</param>
        /// <param name="attachment_type">optional.</param>
        /// <param name="attachment_media_id">optional.</param>
        /// <param name="ctas">optional.</param>
        /// <returns>The published event.</returns>
        public MessageCreateEventResponse New(string text, long recipient_id, QuickReply quick_reply = null, string attachment_type = null, long? attachment_media_id = null, IEnumerable<MessageCallToAction> ctas = null)
        {
            var jm = new string[12];
            jm[0] = "{\"event\": {\"type\": \"message_create\",\"message_create\": {\"target\": {";
            jm[1] = "\"recipient_id\": $recipient_id";
            jm[2] = "},\"message_data\": {";
            jm[3] = "\"text\": $text,";
            jm[4] = "\"quick_reply\": $quick_reply,";
            jm[5] = "\"attachment\": {";
            jm[6] = "\"type\": $attachment_type,";
            jm[7] = "\"media\": {";
            jm[8] = "\"id\": $attachment_media_id";
            jm[9] = "}},";
            jm[10] = "\"ctas\": $ctas";
            jm[11] = "}}}}";
            var parameters = new Dictionary<string, object>();
            if(text == null) throw new ArgumentNullException("text");
            parameters.Add("text", text);
            parameters.Add("recipient_id", recipient_id);
            if(quick_reply != null) parameters.Add("quick_reply", quick_reply);
            if(attachment_type != null) parameters.Add("attachment_type", attachment_type);
            if(attachment_media_id != null) parameters.Add("attachment_media_id", attachment_media_id);
            if(ctas != null) parameters.Add("ctas", ctas);
            return this.Tokens.AccessJsonParameteredApi<MessageCreateEventResponse>("direct_messages/events/new", parameters, jm, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Publishes a new message_create event resulting in a Direct Message sent to a specified user from the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> text (required)</para>
        /// <para>- <c>long</c> recipient_id (required)</para>
        /// <para>- <c>QuickReply</c> quick_reply (optional)</para>
        /// <para>- <c>string</c> attachment_type (optional)</para>
        /// <para>- <c>long</c> attachment_media_id (optional)</para>
        /// <para>- <c>IEnumerable&lt;MessageCallToAction&gt;</c> ctas (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The published event.</returns>
        public Task<MessageCreateEventResponse> NewAsync(params Expression<Func<string, object>>[] parameters)
        {
            var jm = new string[12];
            jm[0] = "{\"event\": {\"type\": \"message_create\",\"message_create\": {\"target\": {";
            jm[1] = "\"recipient_id\": $recipient_id";
            jm[2] = "},\"message_data\": {";
            jm[3] = "\"text\": $text,";
            jm[4] = "\"quick_reply\": $quick_reply,";
            jm[5] = "\"attachment\": {";
            jm[6] = "\"type\": $attachment_type,";
            jm[7] = "\"media\": {";
            jm[8] = "\"id\": $attachment_media_id";
            jm[9] = "}},";
            jm[10] = "\"ctas\": $ctas";
            jm[11] = "}}}}";
            return this.Tokens.AccessJsonParameteredApiAsync<MessageCreateEventResponse>("direct_messages/events/new", parameters, jm, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Publishes a new message_create event resulting in a Direct Message sent to a specified user from the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> text (required)</para>
        /// <para>- <c>long</c> recipient_id (required)</para>
        /// <para>- <c>QuickReply</c> quick_reply (optional)</para>
        /// <para>- <c>string</c> attachment_type (optional)</para>
        /// <para>- <c>long</c> attachment_media_id (optional)</para>
        /// <para>- <c>IEnumerable&lt;MessageCallToAction&gt;</c> ctas (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The published event.</returns>
        public Task<MessageCreateEventResponse> NewAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            var jm = new string[12];
            jm[0] = "{\"event\": {\"type\": \"message_create\",\"message_create\": {\"target\": {";
            jm[1] = "\"recipient_id\": $recipient_id";
            jm[2] = "},\"message_data\": {";
            jm[3] = "\"text\": $text,";
            jm[4] = "\"quick_reply\": $quick_reply,";
            jm[5] = "\"attachment\": {";
            jm[6] = "\"type\": $attachment_type,";
            jm[7] = "\"media\": {";
            jm[8] = "\"id\": $attachment_media_id";
            jm[9] = "}},";
            jm[10] = "\"ctas\": $ctas";
            jm[11] = "}}}}";
            return this.Tokens.AccessJsonParameteredApiAsync<MessageCreateEventResponse>("direct_messages/events/new", parameters, jm, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Publishes a new message_create event resulting in a Direct Message sent to a specified user from the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> text (required)</para>
        /// <para>- <c>long</c> recipient_id (required)</para>
        /// <para>- <c>QuickReply</c> quick_reply (optional)</para>
        /// <para>- <c>string</c> attachment_type (optional)</para>
        /// <para>- <c>long</c> attachment_media_id (optional)</para>
        /// <para>- <c>IEnumerable&lt;MessageCallToAction&gt;</c> ctas (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The published event.</returns>
        public Task<MessageCreateEventResponse> NewAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            var jm = new string[12];
            jm[0] = "{\"event\": {\"type\": \"message_create\",\"message_create\": {\"target\": {";
            jm[1] = "\"recipient_id\": $recipient_id";
            jm[2] = "},\"message_data\": {";
            jm[3] = "\"text\": $text,";
            jm[4] = "\"quick_reply\": $quick_reply,";
            jm[5] = "\"attachment\": {";
            jm[6] = "\"type\": $attachment_type,";
            jm[7] = "\"media\": {";
            jm[8] = "\"id\": $attachment_media_id";
            jm[9] = "}},";
            jm[10] = "\"ctas\": $ctas";
            jm[11] = "}}}}";
            return this.Tokens.AccessJsonParameteredApiAsync<MessageCreateEventResponse>("direct_messages/events/new", parameters, jm, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Publishes a new message_create event resulting in a Direct Message sent to a specified user from the authenticating user.</para>
        /// </summary>
        /// <param name="text">required.</param>
        /// <param name="recipient_id">required.</param>
        /// <param name="quick_reply">optional.</param>
        /// <param name="attachment_type">optional.</param>
        /// <param name="attachment_media_id">optional.</param>
        /// <param name="ctas">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The published event.</returns>
        public Task<MessageCreateEventResponse> NewAsync(string text, long recipient_id, QuickReply quick_reply = null, string attachment_type = null, long? attachment_media_id = null, IEnumerable<MessageCallToAction> ctas = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var jm = new string[12];
            jm[0] = "{\"event\": {\"type\": \"message_create\",\"message_create\": {\"target\": {";
            jm[1] = "\"recipient_id\": $recipient_id";
            jm[2] = "},\"message_data\": {";
            jm[3] = "\"text\": $text,";
            jm[4] = "\"quick_reply\": $quick_reply,";
            jm[5] = "\"attachment\": {";
            jm[6] = "\"type\": $attachment_type,";
            jm[7] = "\"media\": {";
            jm[8] = "\"id\": $attachment_media_id";
            jm[9] = "}},";
            jm[10] = "\"ctas\": $ctas";
            jm[11] = "}}}}";
            var parameters = new Dictionary<string, object>();
            if(text == null) throw new ArgumentNullException("text");
            parameters.Add("text", text);
            parameters.Add("recipient_id", recipient_id);
            if(quick_reply != null) parameters.Add("quick_reply", quick_reply);
            if(attachment_type != null) parameters.Add("attachment_type", attachment_type);
            if(attachment_media_id != null) parameters.Add("attachment_media_id", attachment_media_id);
            if(ctas != null) parameters.Add("ctas", ctas);
            return this.Tokens.AccessJsonParameteredApiAsync<MessageCreateEventResponse>("direct_messages/events/new", parameters, jm, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns all Direct Message events (both sent and received) within the last 30 days. Sorted in reverse-chronological order.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Direct Messages.</returns>
        public CursoredMessageCreateEvents List(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<CursoredMessageCreateEvents>(MethodType.Get, "direct_messages/events/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns all Direct Message events (both sent and received) within the last 30 days. Sorted in reverse-chronological order.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Direct Messages.</returns>
        public CursoredMessageCreateEvents List(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<CursoredMessageCreateEvents>(MethodType.Get, "direct_messages/events/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns all Direct Message events (both sent and received) within the last 30 days. Sorted in reverse-chronological order.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Direct Messages.</returns>
        public CursoredMessageCreateEvents List(object parameters)
        {
            return this.Tokens.AccessApi<CursoredMessageCreateEvents>(MethodType.Get, "direct_messages/events/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns all Direct Message events (both sent and received) within the last 30 days. Sorted in reverse-chronological order.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <returns>The Direct Messages.</returns>
        public IEnumerable<MessageCreateEvent> EnumerateList(int? count = null, string cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return Cursored.EnumerateForward<CursoredMessageCreateEvents, MessageCreateEvent>(this.Tokens, "direct_messages/events/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns all Direct Message events (both sent and received) within the last 30 days. Sorted in reverse-chronological order.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <returns>The Direct Messages.</returns>
        public CursoredMessageCreateEvents List(int? count = null, string cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApi<CursoredMessageCreateEvents>(MethodType.Get, "direct_messages/events/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns all Direct Message events (both sent and received) within the last 30 days. Sorted in reverse-chronological order.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Direct Messages.</returns>
        public IEnumerable<MessageCreateEvent> EnumerateList(params Expression<Func<string, object>>[] parameters)
        {
            return Cursored.EnumerateForward<CursoredMessageCreateEvents, MessageCreateEvent>(this.Tokens, "direct_messages/events/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns all Direct Message events (both sent and received) within the last 30 days. Sorted in reverse-chronological order.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Direct Messages.</returns>
        public IEnumerable<MessageCreateEvent> EnumerateList(IDictionary<string, object> parameters)
        {
            return Cursored.EnumerateForward<CursoredMessageCreateEvents, MessageCreateEvent>(this.Tokens, "direct_messages/events/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns all Direct Message events (both sent and received) within the last 30 days. Sorted in reverse-chronological order.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Direct Messages.</returns>
        public IEnumerable<MessageCreateEvent> EnumerateList(object parameters)
        {
            return Cursored.EnumerateForward<CursoredMessageCreateEvents, MessageCreateEvent>(this.Tokens, "direct_messages/events/list", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns all Direct Message events (both sent and received) within the last 30 days. Sorted in reverse-chronological order.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Direct Messages.</returns>
        public Task<CursoredMessageCreateEvents> ListAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<CursoredMessageCreateEvents>(MethodType.Get, "direct_messages/events/list", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns all Direct Message events (both sent and received) within the last 30 days. Sorted in reverse-chronological order.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The Direct Messages.</returns>
        public Task<CursoredMessageCreateEvents> ListAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<CursoredMessageCreateEvents>(MethodType.Get, "direct_messages/events/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns all Direct Message events (both sent and received) within the last 30 days. Sorted in reverse-chronological order.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The Direct Messages.</returns>
        public Task<CursoredMessageCreateEvents> ListAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<CursoredMessageCreateEvents>(MethodType.Get, "direct_messages/events/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns all Direct Message events (both sent and received) within the last 30 days. Sorted in reverse-chronological order.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The Direct Messages.</returns>
        public Task<CursoredMessageCreateEvents> ListAsync(int? count = null, string cursor = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApiAsync<CursoredMessageCreateEvents>(MethodType.Get, "direct_messages/events/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a single Direct Message event by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Direct Message.</returns>
        public MessageCreateEventResponse Show(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<MessageCreateEventResponse>(MethodType.Get, "direct_messages/events/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a single Direct Message event by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Direct Message.</returns>
        public MessageCreateEventResponse Show(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<MessageCreateEventResponse>(MethodType.Get, "direct_messages/events/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a single Direct Message event by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Direct Message.</returns>
        public MessageCreateEventResponse Show(object parameters)
        {
            return this.Tokens.AccessApi<MessageCreateEventResponse>(MethodType.Get, "direct_messages/events/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a single Direct Message event by the given id.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <returns>The Direct Message.</returns>
        public MessageCreateEventResponse Show(string id)
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            return this.Tokens.AccessApi<MessageCreateEventResponse>(MethodType.Get, "direct_messages/events/show", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns a single Direct Message event by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Direct Message.</returns>
        public Task<MessageCreateEventResponse> ShowAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<MessageCreateEventResponse>(MethodType.Get, "direct_messages/events/show", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a single Direct Message event by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The Direct Message.</returns>
        public Task<MessageCreateEventResponse> ShowAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<MessageCreateEventResponse>(MethodType.Get, "direct_messages/events/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a single Direct Message event by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The Direct Message.</returns>
        public Task<MessageCreateEventResponse> ShowAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<MessageCreateEventResponse>(MethodType.Get, "direct_messages/events/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a single Direct Message event by the given id.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The Direct Message.</returns>
        public Task<MessageCreateEventResponse> ShowAsync(string id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            return this.Tokens.AccessApiAsync<MessageCreateEventResponse>(MethodType.Get, "direct_messages/events/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Deletes the direct message specified in the required ID parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void Destroy(params Expression<Func<string, object>>[] parameters)
        {
            this.Tokens.AccessApiNoResponse(MethodType.Delete, "direct_messages/events/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Deletes the direct message specified in the required ID parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void Destroy(IDictionary<string, object> parameters)
        {
            this.Tokens.AccessApiNoResponse(MethodType.Delete, "direct_messages/events/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Deletes the direct message specified in the required ID parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void Destroy(object parameters)
        {
            this.Tokens.AccessApiNoResponse(MethodType.Delete, "direct_messages/events/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Deletes the direct message specified in the required ID parameter.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <returns></returns>
        public void Destroy(string id)
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            this.Tokens.AccessApiNoResponse(MethodType.Delete, "direct_messages/events/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Deletes the direct message specified in the required ID parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public Task DestroyAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiNoResponseAsync(MethodType.Delete, "direct_messages/events/destroy", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Deletes the direct message specified in the required ID parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task DestroyAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiNoResponseAsync(MethodType.Delete, "direct_messages/events/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Deletes the direct message specified in the required ID parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task DestroyAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiNoResponseAsync(MethodType.Delete, "direct_messages/events/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Deletes the direct message specified in the required ID parameter.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task DestroyAsync(string id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            return this.Tokens.AccessApiNoResponseAsync(MethodType.Delete, "direct_messages/events/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET/POST favorites.
    /// </summary>
    public partial class Favorites : ApiProviderBase
    {
        internal Favorites(TokensBase e) : base(e) { }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the 20 most recent Tweets favorited by the authenticating or specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (optional)</para>
        /// <para>- <c>string</c> screen_name (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> List(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "favorites/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the 20 most recent Tweets favorited by the authenticating or specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (optional)</para>
        /// <para>- <c>string</c> screen_name (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> List(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "favorites/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the 20 most recent Tweets favorited by the authenticating or specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (optional)</para>
        /// <para>- <c>string</c> screen_name (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> List(object parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "favorites/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the 20 most recent Tweets favorited by the authenticating or specified user.</para>
        /// </summary>
        /// <param name="id">optional.</param>
        /// <param name="screen_name">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> List(long? id = null, string screen_name = null, int? count = null, long? since_id = null, long? max_id = null, bool? include_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(id != null) parameters.Add("id", id);
            if(screen_name != null) parameters.Add("screen_name", screen_name);
            if(count != null) parameters.Add("count", count);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "favorites/list", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns the 20 most recent Tweets favorited by the authenticating or specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (optional)</para>
        /// <para>- <c>string</c> screen_name (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> ListAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "favorites/list", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the 20 most recent Tweets favorited by the authenticating or specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (optional)</para>
        /// <para>- <c>string</c> screen_name (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> ListAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "favorites/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the 20 most recent Tweets favorited by the authenticating or specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (optional)</para>
        /// <para>- <c>string</c> screen_name (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> ListAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "favorites/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the 20 most recent Tweets favorited by the authenticating or specified user.</para>
        /// </summary>
        /// <param name="id">optional.</param>
        /// <param name="screen_name">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> ListAsync(long? id = null, string screen_name = null, int? count = null, long? since_id = null, long? max_id = null, bool? include_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(id != null) parameters.Add("id", id);
            if(screen_name != null) parameters.Add("screen_name", screen_name);
            if(count != null) parameters.Add("count", count);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "favorites/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Favorites the status specified in the ID parameter as the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The favorited status.</returns>
        public StatusResponse Create(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<StatusResponse>(MethodType.Post, "favorites/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Favorites the status specified in the ID parameter as the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The favorited status.</returns>
        public StatusResponse Create(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<StatusResponse>(MethodType.Post, "favorites/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Favorites the status specified in the ID parameter as the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The favorited status.</returns>
        public StatusResponse Create(object parameters)
        {
            return this.Tokens.AccessApi<StatusResponse>(MethodType.Post, "favorites/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Favorites the status specified in the ID parameter as the authenticating user.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The favorited status.</returns>
        public StatusResponse Create(long id, bool? include_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<StatusResponse>(MethodType.Post, "favorites/create", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Favorites the status specified in the ID parameter as the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The favorited status.</returns>
        public Task<StatusResponse> CreateAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<StatusResponse>(MethodType.Post, "favorites/create", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Favorites the status specified in the ID parameter as the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The favorited status.</returns>
        public Task<StatusResponse> CreateAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<StatusResponse>(MethodType.Post, "favorites/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Favorites the status specified in the ID parameter as the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The favorited status.</returns>
        public Task<StatusResponse> CreateAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<StatusResponse>(MethodType.Post, "favorites/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Favorites the status specified in the ID parameter as the authenticating user.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The favorited status.</returns>
        public Task<StatusResponse> CreateAsync(long id, bool? include_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<StatusResponse>(MethodType.Post, "favorites/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Un-favorites the status specified in the ID parameter as the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The unfavorited status.</returns>
        public StatusResponse Destroy(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<StatusResponse>(MethodType.Post, "favorites/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Un-favorites the status specified in the ID parameter as the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The unfavorited status.</returns>
        public StatusResponse Destroy(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<StatusResponse>(MethodType.Post, "favorites/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Un-favorites the status specified in the ID parameter as the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The unfavorited status.</returns>
        public StatusResponse Destroy(object parameters)
        {
            return this.Tokens.AccessApi<StatusResponse>(MethodType.Post, "favorites/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Un-favorites the status specified in the ID parameter as the authenticating user.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The unfavorited status.</returns>
        public StatusResponse Destroy(long id, bool? include_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<StatusResponse>(MethodType.Post, "favorites/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Un-favorites the status specified in the ID parameter as the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The unfavorited status.</returns>
        public Task<StatusResponse> DestroyAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<StatusResponse>(MethodType.Post, "favorites/destroy", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Un-favorites the status specified in the ID parameter as the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The unfavorited status.</returns>
        public Task<StatusResponse> DestroyAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<StatusResponse>(MethodType.Post, "favorites/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Un-favorites the status specified in the ID parameter as the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The unfavorited status.</returns>
        public Task<StatusResponse> DestroyAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<StatusResponse>(MethodType.Post, "favorites/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Un-favorites the status specified in the ID parameter as the authenticating user.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The unfavorited status.</returns>
        public Task<StatusResponse> DestroyAsync(long id, bool? include_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<StatusResponse>(MethodType.Post, "favorites/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET followers.
    /// </summary>
    public partial class Followers : ApiProviderBase
    {
        internal Followers(TokensBase e) : base(e) { }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user following the specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Ids(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "followers/ids", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user following the specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Ids(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "followers/ids", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user following the specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Ids(object parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "followers/ids", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user following the specified user.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateIds(EnumerateMode mode, long user_id, long? cursor = null, int? count = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            return Cursored.Enumerate<long>(this.Tokens, "followers/ids", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user following the specified user.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Ids(long user_id, long? cursor = null, int? count = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "followers/ids", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user following the specified user.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateIds(EnumerateMode mode, string screen_name, long? cursor = null, int? count = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            return Cursored.Enumerate<long>(this.Tokens, "followers/ids", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user following the specified user.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Ids(string screen_name, long? cursor = null, int? count = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "followers/ids", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user following the specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateIds(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored.Enumerate<long>(this.Tokens, "followers/ids", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user following the specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateIds(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored.Enumerate<long>(this.Tokens, "followers/ids", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user following the specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateIds(EnumerateMode mode, object parameters)
        {
            return Cursored.Enumerate<long>(this.Tokens, "followers/ids", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user following the specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> IdsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "followers/ids", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user following the specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> IdsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "followers/ids", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user following the specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> IdsAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "followers/ids", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user following the specified user.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> IdsAsync(long user_id, long? cursor = null, int? count = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "followers/ids", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user following the specified user.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> IdsAsync(string screen_name, long? cursor = null, int? count = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "followers/ids", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user objects for users following the specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_user_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "followers/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user objects for users following the specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_user_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "followers/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user objects for users following the specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_user_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(object parameters)
        {
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "followers/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user objects for users following the specified user.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_user_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, long user_id, long? cursor = null, int? count = null, bool? skip_status = null, bool? include_user_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_user_entities != null) parameters.Add("include_user_entities", include_user_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return Cursored.Enumerate<User>(this.Tokens, "followers/list", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user objects for users following the specified user.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_user_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(long user_id, long? cursor = null, int? count = null, bool? skip_status = null, bool? include_user_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_user_entities != null) parameters.Add("include_user_entities", include_user_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "followers/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user objects for users following the specified user.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_user_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, string screen_name, long? cursor = null, int? count = null, bool? skip_status = null, bool? include_user_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_user_entities != null) parameters.Add("include_user_entities", include_user_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return Cursored.Enumerate<User>(this.Tokens, "followers/list", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user objects for users following the specified user.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_user_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(string screen_name, long? cursor = null, int? count = null, bool? skip_status = null, bool? include_user_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_user_entities != null) parameters.Add("include_user_entities", include_user_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "followers/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user objects for users following the specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_user_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored.Enumerate<User>(this.Tokens, "followers/list", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user objects for users following the specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_user_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored.Enumerate<User>(this.Tokens, "followers/list", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user objects for users following the specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_user_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, object parameters)
        {
            return Cursored.Enumerate<User>(this.Tokens, "followers/list", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns a cursored collection of user objects for users following the specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_user_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "followers/list", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for users following the specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_user_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "followers/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for users following the specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_user_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "followers/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for users following the specified user.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_user_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(long user_id, long? cursor = null, int? count = null, bool? skip_status = null, bool? include_user_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_user_entities != null) parameters.Add("include_user_entities", include_user_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "followers/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for users following the specified user.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_user_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(string screen_name, long? cursor = null, int? count = null, bool? skip_status = null, bool? include_user_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_user_entities != null) parameters.Add("include_user_entities", include_user_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "followers/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET friends.
    /// </summary>
    public partial class Friends : ApiProviderBase
    {
        internal Friends(TokensBase e) : base(e) { }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Ids(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "friends/ids", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Ids(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "friends/ids", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Ids(object parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "friends/ids", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateIds(EnumerateMode mode, long user_id, long? cursor = null, int? count = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            return Cursored.Enumerate<long>(this.Tokens, "friends/ids", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Ids(long user_id, long? cursor = null, int? count = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "friends/ids", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateIds(EnumerateMode mode, string screen_name, long? cursor = null, int? count = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            return Cursored.Enumerate<long>(this.Tokens, "friends/ids", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Ids(string screen_name, long? cursor = null, int? count = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "friends/ids", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateIds(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored.Enumerate<long>(this.Tokens, "friends/ids", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateIds(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored.Enumerate<long>(this.Tokens, "friends/ids", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateIds(EnumerateMode mode, object parameters)
        {
            return Cursored.Enumerate<long>(this.Tokens, "friends/ids", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> IdsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "friends/ids", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> IdsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "friends/ids", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> IdsAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "friends/ids", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> IdsAsync(long user_id, long? cursor = null, int? count = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "friends/ids", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> IdsAsync(string screen_name, long? cursor = null, int? count = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "friends/ids", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_user_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "friends/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_user_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "friends/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_user_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(object parameters)
        {
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "friends/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_user_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, long user_id, long? cursor = null, int? count = null, bool? skip_status = null, bool? include_user_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_user_entities != null) parameters.Add("include_user_entities", include_user_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return Cursored.Enumerate<User>(this.Tokens, "friends/list", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_user_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(long user_id, long? cursor = null, int? count = null, bool? skip_status = null, bool? include_user_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_user_entities != null) parameters.Add("include_user_entities", include_user_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "friends/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_user_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, string screen_name, long? cursor = null, int? count = null, bool? skip_status = null, bool? include_user_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_user_entities != null) parameters.Add("include_user_entities", include_user_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return Cursored.Enumerate<User>(this.Tokens, "friends/list", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_user_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(string screen_name, long? cursor = null, int? count = null, bool? skip_status = null, bool? include_user_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_user_entities != null) parameters.Add("include_user_entities", include_user_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "friends/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_user_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored.Enumerate<User>(this.Tokens, "friends/list", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_user_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored.Enumerate<User>(this.Tokens, "friends/list", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_user_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, object parameters)
        {
            return Cursored.Enumerate<User>(this.Tokens, "friends/list", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_user_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "friends/list", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_user_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "friends/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_user_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "friends/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_user_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(long user_id, long? cursor = null, int? count = null, bool? skip_status = null, bool? include_user_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_user_entities != null) parameters.Add("include_user_entities", include_user_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "friends/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_user_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(string screen_name, long? cursor = null, int? count = null, bool? skip_status = null, bool? include_user_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_user_entities != null) parameters.Add("include_user_entities", include_user_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "friends/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET/POST friendships.
    /// </summary>
    public partial class Friendships : ApiProviderBase
    {
        internal Friendships(TokensBase e) : base(e) { }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of user_ids that the currently authenticated user does not want to receive retweets from.</para>
        /// <para>Use POST friendships/update to set the "no retweets" status for a given user account on behalf of the current user.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public ListedResponse<long> NoRetweetsIds(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<long>(MethodType.Get, "friendships/no_retweets/ids", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of user_ids that the currently authenticated user does not want to receive retweets from.</para>
        /// <para>Use POST friendships/update to set the "no retweets" status for a given user account on behalf of the current user.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public ListedResponse<long> NoRetweetsIds(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<long>(MethodType.Get, "friendships/no_retweets/ids", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of user_ids that the currently authenticated user does not want to receive retweets from.</para>
        /// <para>Use POST friendships/update to set the "no retweets" status for a given user account on behalf of the current user.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public ListedResponse<long> NoRetweetsIds(object parameters)
        {
            return this.Tokens.AccessApiArray<long>(MethodType.Get, "friendships/no_retweets/ids", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of user_ids that the currently authenticated user does not want to receive retweets from.</para>
        /// <para>Use POST friendships/update to set the "no retweets" status for a given user account on behalf of the current user.</para>
        /// </summary>
        /// <returns>The IDs.</returns>
        public ListedResponse<long> NoRetweetsIds()
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiArray<long>(MethodType.Get, "friendships/no_retweets/ids", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns a collection of user_ids that the currently authenticated user does not want to receive retweets from.</para>
        /// <para>Use POST friendships/update to set the "no retweets" status for a given user account on behalf of the current user.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Task<ListedResponse<long>> NoRetweetsIdsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<long>(MethodType.Get, "friendships/no_retweets/ids", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of user_ids that the currently authenticated user does not want to receive retweets from.</para>
        /// <para>Use POST friendships/update to set the "no retweets" status for a given user account on behalf of the current user.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<ListedResponse<long>> NoRetweetsIdsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<long>(MethodType.Get, "friendships/no_retweets/ids", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of user_ids that the currently authenticated user does not want to receive retweets from.</para>
        /// <para>Use POST friendships/update to set the "no retweets" status for a given user account on behalf of the current user.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<ListedResponse<long>> NoRetweetsIdsAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<long>(MethodType.Get, "friendships/no_retweets/ids", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of user_ids that the currently authenticated user does not want to receive retweets from.</para>
        /// <para>Use POST friendships/update to set the "no retweets" status for a given user account on behalf of the current user.</para>
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<ListedResponse<long>> NoRetweetsIdsAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiArrayAsync<long>(MethodType.Get, "friendships/no_retweets/ids", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of numeric IDs for every user who has a pending request to follow the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Incoming(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "friendships/incoming", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of numeric IDs for every user who has a pending request to follow the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Incoming(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "friendships/incoming", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of numeric IDs for every user who has a pending request to follow the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Incoming(object parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "friendships/incoming", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of numeric IDs for every user who has a pending request to follow the authenticating user.</para>
        /// </summary>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateIncoming(EnumerateMode mode, long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            return Cursored.Enumerate<long>(this.Tokens, "friendships/incoming", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of numeric IDs for every user who has a pending request to follow the authenticating user.</para>
        /// </summary>
        /// <param name="cursor">semi-optional.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Incoming(long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "friendships/incoming", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of numeric IDs for every user who has a pending request to follow the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateIncoming(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored.Enumerate<long>(this.Tokens, "friendships/incoming", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of numeric IDs for every user who has a pending request to follow the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateIncoming(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored.Enumerate<long>(this.Tokens, "friendships/incoming", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of numeric IDs for every user who has a pending request to follow the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateIncoming(EnumerateMode mode, object parameters)
        {
            return Cursored.Enumerate<long>(this.Tokens, "friendships/incoming", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns a collection of numeric IDs for every user who has a pending request to follow the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> IncomingAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "friendships/incoming", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of numeric IDs for every user who has a pending request to follow the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> IncomingAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "friendships/incoming", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of numeric IDs for every user who has a pending request to follow the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> IncomingAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "friendships/incoming", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of numeric IDs for every user who has a pending request to follow the authenticating user.</para>
        /// </summary>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> IncomingAsync(long? cursor = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "friendships/incoming", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of numeric IDs for every protected user for whom the authenticating user has a pending follow request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Outgoing(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "friendships/outgoing", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of numeric IDs for every protected user for whom the authenticating user has a pending follow request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Outgoing(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "friendships/outgoing", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of numeric IDs for every protected user for whom the authenticating user has a pending follow request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Outgoing(object parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "friendships/outgoing", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of numeric IDs for every protected user for whom the authenticating user has a pending follow request.</para>
        /// </summary>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateOutgoing(EnumerateMode mode, long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            return Cursored.Enumerate<long>(this.Tokens, "friendships/outgoing", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of numeric IDs for every protected user for whom the authenticating user has a pending follow request.</para>
        /// </summary>
        /// <param name="cursor">semi-optional.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Outgoing(long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "friendships/outgoing", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of numeric IDs for every protected user for whom the authenticating user has a pending follow request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateOutgoing(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored.Enumerate<long>(this.Tokens, "friendships/outgoing", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of numeric IDs for every protected user for whom the authenticating user has a pending follow request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateOutgoing(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored.Enumerate<long>(this.Tokens, "friendships/outgoing", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of numeric IDs for every protected user for whom the authenticating user has a pending follow request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateOutgoing(EnumerateMode mode, object parameters)
        {
            return Cursored.Enumerate<long>(this.Tokens, "friendships/outgoing", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns a collection of numeric IDs for every protected user for whom the authenticating user has a pending follow request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> OutgoingAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "friendships/outgoing", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of numeric IDs for every protected user for whom the authenticating user has a pending follow request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> OutgoingAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "friendships/outgoing", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of numeric IDs for every protected user for whom the authenticating user has a pending follow request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> OutgoingAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "friendships/outgoing", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of numeric IDs for every protected user for whom the authenticating user has a pending follow request.</para>
        /// </summary>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> OutgoingAsync(long? cursor = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "friendships/outgoing", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the relationships of the authenticating user to the comma-separated list of up to 100 screen_names or user_ids provided.</para>
        /// <para>Values for connections can be: following, following_requested, followed_by, none.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The friendships.</returns>
        public ListedResponse<Friendship> Lookup(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<Friendship>(MethodType.Get, "friendships/lookup", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the relationships of the authenticating user to the comma-separated list of up to 100 screen_names or user_ids provided.</para>
        /// <para>Values for connections can be: following, following_requested, followed_by, none.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The friendships.</returns>
        public ListedResponse<Friendship> Lookup(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<Friendship>(MethodType.Get, "friendships/lookup", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the relationships of the authenticating user to the comma-separated list of up to 100 screen_names or user_ids provided.</para>
        /// <para>Values for connections can be: following, following_requested, followed_by, none.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The friendships.</returns>
        public ListedResponse<Friendship> Lookup(object parameters)
        {
            return this.Tokens.AccessApiArray<Friendship>(MethodType.Get, "friendships/lookup", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the relationships of the authenticating user to the comma-separated list of up to 100 screen_names or user_ids provided.</para>
        /// <para>Values for connections can be: following, following_requested, followed_by, none.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The friendships.</returns>
        public ListedResponse<Friendship> Lookup(IEnumerable<string> screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiArray<Friendship>(MethodType.Get, "friendships/lookup", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the relationships of the authenticating user to the comma-separated list of up to 100 screen_names or user_ids provided.</para>
        /// <para>Values for connections can be: following, following_requested, followed_by, none.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The friendships.</returns>
        public ListedResponse<Friendship> Lookup(IEnumerable<long> user_id)
        {
            var parameters = new Dictionary<string, object>();
            if(user_id == null) throw new ArgumentNullException("user_id");
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiArray<Friendship>(MethodType.Get, "friendships/lookup", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns the relationships of the authenticating user to the comma-separated list of up to 100 screen_names or user_ids provided.</para>
        /// <para>Values for connections can be: following, following_requested, followed_by, none.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The friendships.</returns>
        public Task<ListedResponse<Friendship>> LookupAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<Friendship>(MethodType.Get, "friendships/lookup", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the relationships of the authenticating user to the comma-separated list of up to 100 screen_names or user_ids provided.</para>
        /// <para>Values for connections can be: following, following_requested, followed_by, none.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The friendships.</returns>
        public Task<ListedResponse<Friendship>> LookupAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Friendship>(MethodType.Get, "friendships/lookup", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the relationships of the authenticating user to the comma-separated list of up to 100 screen_names or user_ids provided.</para>
        /// <para>Values for connections can be: following, following_requested, followed_by, none.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The friendships.</returns>
        public Task<ListedResponse<Friendship>> LookupAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Friendship>(MethodType.Get, "friendships/lookup", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the relationships of the authenticating user to the comma-separated list of up to 100 screen_names or user_ids provided.</para>
        /// <para>Values for connections can be: following, following_requested, followed_by, none.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The friendships.</returns>
        public Task<ListedResponse<Friendship>> LookupAsync(IEnumerable<string> screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiArrayAsync<Friendship>(MethodType.Get, "friendships/lookup", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the relationships of the authenticating user to the comma-separated list of up to 100 screen_names or user_ids provided.</para>
        /// <para>Values for connections can be: following, following_requested, followed_by, none.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The friendships.</returns>
        public Task<ListedResponse<Friendship>> LookupAsync(IEnumerable<long> user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(user_id == null) throw new ArgumentNullException("user_id");
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiArrayAsync<Friendship>(MethodType.Get, "friendships/lookup", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns detailed information about the relationship between two arbitrary users.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> source_id (any one is required)</para>
        /// <para>- <c>string</c> source_screen_name (any one is required)</para>
        /// <para>- <c>long</c> target_id (any one is required)</para>
        /// <para>- <c>string</c> target_screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The relationship.</returns>
        public Relationship Show(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Relationship>(MethodType.Get, "friendships/show", parameters, jsonPath: "relationship", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns detailed information about the relationship between two arbitrary users.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> source_id (any one is required)</para>
        /// <para>- <c>string</c> source_screen_name (any one is required)</para>
        /// <para>- <c>long</c> target_id (any one is required)</para>
        /// <para>- <c>string</c> target_screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The relationship.</returns>
        public Relationship Show(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Relationship>(MethodType.Get, "friendships/show", parameters, jsonPath: "relationship", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns detailed information about the relationship between two arbitrary users.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> source_id (any one is required)</para>
        /// <para>- <c>string</c> source_screen_name (any one is required)</para>
        /// <para>- <c>long</c> target_id (any one is required)</para>
        /// <para>- <c>string</c> target_screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The relationship.</returns>
        public Relationship Show(object parameters)
        {
            return this.Tokens.AccessApi<Relationship>(MethodType.Get, "friendships/show", parameters, jsonPath: "relationship", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns detailed information about the relationship between two arbitrary users.</para>
        /// </summary>
        /// <param name="target_id">any one is required.</param>
        /// <returns>The relationship.</returns>
        public Relationship Show(long target_id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("target_id", target_id);
            return this.Tokens.AccessApi<Relationship>(MethodType.Get, "friendships/show", parameters, jsonPath: "relationship", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns detailed information about the relationship between two arbitrary users.</para>
        /// </summary>
        /// <param name="target_screen_name">any one is required.</param>
        /// <returns>The relationship.</returns>
        public Relationship Show(string target_screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(target_screen_name == null) throw new ArgumentNullException("target_screen_name");
            parameters.Add("target_screen_name", target_screen_name);
            return this.Tokens.AccessApi<Relationship>(MethodType.Get, "friendships/show", parameters, jsonPath: "relationship", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns detailed information about the relationship between two arbitrary users.</para>
        /// </summary>
        /// <param name="source_id">any one is required.</param>
        /// <param name="target_id">any one is required.</param>
        /// <returns>The relationship.</returns>
        public Relationship Show(long source_id, long target_id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("source_id", source_id);
            parameters.Add("target_id", target_id);
            return this.Tokens.AccessApi<Relationship>(MethodType.Get, "friendships/show", parameters, jsonPath: "relationship", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns detailed information about the relationship between two arbitrary users.</para>
        /// </summary>
        /// <param name="source_id">any one is required.</param>
        /// <param name="target_screen_name">any one is required.</param>
        /// <returns>The relationship.</returns>
        public Relationship Show(long source_id, string target_screen_name)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("source_id", source_id);
            if(target_screen_name == null) throw new ArgumentNullException("target_screen_name");
            parameters.Add("target_screen_name", target_screen_name);
            return this.Tokens.AccessApi<Relationship>(MethodType.Get, "friendships/show", parameters, jsonPath: "relationship", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns detailed information about the relationship between two arbitrary users.</para>
        /// </summary>
        /// <param name="source_screen_name">any one is required.</param>
        /// <param name="target_id">any one is required.</param>
        /// <returns>The relationship.</returns>
        public Relationship Show(string source_screen_name, long target_id)
        {
            var parameters = new Dictionary<string, object>();
            if(source_screen_name == null) throw new ArgumentNullException("source_screen_name");
            parameters.Add("source_screen_name", source_screen_name);
            parameters.Add("target_id", target_id);
            return this.Tokens.AccessApi<Relationship>(MethodType.Get, "friendships/show", parameters, jsonPath: "relationship", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns detailed information about the relationship between two arbitrary users.</para>
        /// </summary>
        /// <param name="source_screen_name">any one is required.</param>
        /// <param name="target_screen_name">any one is required.</param>
        /// <returns>The relationship.</returns>
        public Relationship Show(string source_screen_name, string target_screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(source_screen_name == null) throw new ArgumentNullException("source_screen_name");
            parameters.Add("source_screen_name", source_screen_name);
            if(target_screen_name == null) throw new ArgumentNullException("target_screen_name");
            parameters.Add("target_screen_name", target_screen_name);
            return this.Tokens.AccessApi<Relationship>(MethodType.Get, "friendships/show", parameters, jsonPath: "relationship", urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns detailed information about the relationship between two arbitrary users.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> source_id (any one is required)</para>
        /// <para>- <c>string</c> source_screen_name (any one is required)</para>
        /// <para>- <c>long</c> target_id (any one is required)</para>
        /// <para>- <c>string</c> target_screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The relationship.</returns>
        public Task<Relationship> ShowAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Relationship>(MethodType.Get, "friendships/show", parameters, jsonPath: "relationship", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns detailed information about the relationship between two arbitrary users.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> source_id (any one is required)</para>
        /// <para>- <c>string</c> source_screen_name (any one is required)</para>
        /// <para>- <c>long</c> target_id (any one is required)</para>
        /// <para>- <c>string</c> target_screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The relationship.</returns>
        public Task<Relationship> ShowAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Relationship>(MethodType.Get, "friendships/show", parameters, cancellationToken, jsonPath: "relationship", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns detailed information about the relationship between two arbitrary users.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> source_id (any one is required)</para>
        /// <para>- <c>string</c> source_screen_name (any one is required)</para>
        /// <para>- <c>long</c> target_id (any one is required)</para>
        /// <para>- <c>string</c> target_screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The relationship.</returns>
        public Task<Relationship> ShowAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Relationship>(MethodType.Get, "friendships/show", parameters, cancellationToken, jsonPath: "relationship", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns detailed information about the relationship between two arbitrary users.</para>
        /// </summary>
        /// <param name="target_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The relationship.</returns>
        public Task<Relationship> ShowAsync(long target_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("target_id", target_id);
            return this.Tokens.AccessApiAsync<Relationship>(MethodType.Get, "friendships/show", parameters, cancellationToken, jsonPath: "relationship", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns detailed information about the relationship between two arbitrary users.</para>
        /// </summary>
        /// <param name="target_screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The relationship.</returns>
        public Task<Relationship> ShowAsync(string target_screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(target_screen_name == null) throw new ArgumentNullException("target_screen_name");
            parameters.Add("target_screen_name", target_screen_name);
            return this.Tokens.AccessApiAsync<Relationship>(MethodType.Get, "friendships/show", parameters, cancellationToken, jsonPath: "relationship", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns detailed information about the relationship between two arbitrary users.</para>
        /// </summary>
        /// <param name="source_id">any one is required.</param>
        /// <param name="target_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The relationship.</returns>
        public Task<Relationship> ShowAsync(long source_id, long target_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("source_id", source_id);
            parameters.Add("target_id", target_id);
            return this.Tokens.AccessApiAsync<Relationship>(MethodType.Get, "friendships/show", parameters, cancellationToken, jsonPath: "relationship", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns detailed information about the relationship between two arbitrary users.</para>
        /// </summary>
        /// <param name="source_id">any one is required.</param>
        /// <param name="target_screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The relationship.</returns>
        public Task<Relationship> ShowAsync(long source_id, string target_screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("source_id", source_id);
            if(target_screen_name == null) throw new ArgumentNullException("target_screen_name");
            parameters.Add("target_screen_name", target_screen_name);
            return this.Tokens.AccessApiAsync<Relationship>(MethodType.Get, "friendships/show", parameters, cancellationToken, jsonPath: "relationship", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns detailed information about the relationship between two arbitrary users.</para>
        /// </summary>
        /// <param name="source_screen_name">any one is required.</param>
        /// <param name="target_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The relationship.</returns>
        public Task<Relationship> ShowAsync(string source_screen_name, long target_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(source_screen_name == null) throw new ArgumentNullException("source_screen_name");
            parameters.Add("source_screen_name", source_screen_name);
            parameters.Add("target_id", target_id);
            return this.Tokens.AccessApiAsync<Relationship>(MethodType.Get, "friendships/show", parameters, cancellationToken, jsonPath: "relationship", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns detailed information about the relationship between two arbitrary users.</para>
        /// </summary>
        /// <param name="source_screen_name">any one is required.</param>
        /// <param name="target_screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The relationship.</returns>
        public Task<Relationship> ShowAsync(string source_screen_name, string target_screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(source_screen_name == null) throw new ArgumentNullException("source_screen_name");
            parameters.Add("source_screen_name", source_screen_name);
            if(target_screen_name == null) throw new ArgumentNullException("target_screen_name");
            parameters.Add("target_screen_name", target_screen_name);
            return this.Tokens.AccessApiAsync<Relationship>(MethodType.Get, "friendships/show", parameters, cancellationToken, jsonPath: "relationship", urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Allows the authenticating users to follow the user specified in the ID parameter.</para>
        /// <para>Returns the befriended user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> follow (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse Create(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "friendships/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Allows the authenticating users to follow the user specified in the ID parameter.</para>
        /// <para>Returns the befriended user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> follow (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse Create(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "friendships/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Allows the authenticating users to follow the user specified in the ID parameter.</para>
        /// <para>Returns the befriended user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> follow (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse Create(object parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "friendships/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Allows the authenticating users to follow the user specified in the ID parameter.</para>
        /// <para>Returns the befriended user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="follow">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Create(long user_id, bool? follow = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(follow != null) parameters.Add("follow", follow);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "friendships/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Allows the authenticating users to follow the user specified in the ID parameter.</para>
        /// <para>Returns the befriended user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="follow">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Create(string screen_name, bool? follow = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(follow != null) parameters.Add("follow", follow);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "friendships/create", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Allows the authenticating users to follow the user specified in the ID parameter.</para>
        /// <para>Returns the befriended user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> follow (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> CreateAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "friendships/create", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Allows the authenticating users to follow the user specified in the ID parameter.</para>
        /// <para>Returns the befriended user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> follow (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> CreateAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "friendships/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Allows the authenticating users to follow the user specified in the ID parameter.</para>
        /// <para>Returns the befriended user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> follow (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> CreateAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "friendships/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Allows the authenticating users to follow the user specified in the ID parameter.</para>
        /// <para>Returns the befriended user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="follow">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> CreateAsync(long user_id, bool? follow = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(follow != null) parameters.Add("follow", follow);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "friendships/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Allows the authenticating users to follow the user specified in the ID parameter.</para>
        /// <para>Returns the befriended user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="follow">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> CreateAsync(string screen_name, bool? follow = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(follow != null) parameters.Add("follow", follow);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "friendships/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Allows the authenticating user to unfollow the user specified in the ID parameter.</para>
        /// <para>Returns the unfollowed user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse Destroy(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "friendships/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Allows the authenticating user to unfollow the user specified in the ID parameter.</para>
        /// <para>Returns the unfollowed user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse Destroy(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "friendships/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Allows the authenticating user to unfollow the user specified in the ID parameter.</para>
        /// <para>Returns the unfollowed user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse Destroy(object parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "friendships/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Allows the authenticating user to unfollow the user specified in the ID parameter.</para>
        /// <para>Returns the unfollowed user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Destroy(long user_id, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "friendships/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Allows the authenticating user to unfollow the user specified in the ID parameter.</para>
        /// <para>Returns the unfollowed user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Destroy(string screen_name, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "friendships/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Allows the authenticating user to unfollow the user specified in the ID parameter.</para>
        /// <para>Returns the unfollowed user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> DestroyAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "friendships/destroy", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Allows the authenticating user to unfollow the user specified in the ID parameter.</para>
        /// <para>Returns the unfollowed user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> DestroyAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "friendships/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Allows the authenticating user to unfollow the user specified in the ID parameter.</para>
        /// <para>Returns the unfollowed user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> DestroyAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "friendships/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Allows the authenticating user to unfollow the user specified in the ID parameter.</para>
        /// <para>Returns the unfollowed user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> DestroyAsync(long user_id, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "friendships/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Allows the authenticating user to unfollow the user specified in the ID parameter.</para>
        /// <para>Returns the unfollowed user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> DestroyAsync(string screen_name, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "friendships/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Allows one to enable or disable retweets and device notifications from the specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> device (optional)</para>
        /// <para>- <c>bool</c> retweets (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The relationship.</returns>
        public Relationship Update(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Relationship>(MethodType.Post, "friendships/update", parameters, jsonPath: "relationship", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Allows one to enable or disable retweets and device notifications from the specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> device (optional)</para>
        /// <para>- <c>bool</c> retweets (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The relationship.</returns>
        public Relationship Update(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Relationship>(MethodType.Post, "friendships/update", parameters, jsonPath: "relationship", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Allows one to enable or disable retweets and device notifications from the specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> device (optional)</para>
        /// <para>- <c>bool</c> retweets (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The relationship.</returns>
        public Relationship Update(object parameters)
        {
            return this.Tokens.AccessApi<Relationship>(MethodType.Post, "friendships/update", parameters, jsonPath: "relationship", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Allows one to enable or disable retweets and device notifications from the specified user.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="device">optional.</param>
        /// <param name="retweets">optional.</param>
        /// <returns>The relationship.</returns>
        public Relationship Update(long user_id, bool? device = null, bool? retweets = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(device != null) parameters.Add("device", device);
            if(retweets != null) parameters.Add("retweets", retweets);
            return this.Tokens.AccessApi<Relationship>(MethodType.Post, "friendships/update", parameters, jsonPath: "relationship", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Allows one to enable or disable retweets and device notifications from the specified user.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="device">optional.</param>
        /// <param name="retweets">optional.</param>
        /// <returns>The relationship.</returns>
        public Relationship Update(string screen_name, bool? device = null, bool? retweets = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(device != null) parameters.Add("device", device);
            if(retweets != null) parameters.Add("retweets", retweets);
            return this.Tokens.AccessApi<Relationship>(MethodType.Post, "friendships/update", parameters, jsonPath: "relationship", urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Allows one to enable or disable retweets and device notifications from the specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> device (optional)</para>
        /// <para>- <c>bool</c> retweets (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The relationship.</returns>
        public Task<Relationship> UpdateAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Relationship>(MethodType.Post, "friendships/update", parameters, jsonPath: "relationship", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Allows one to enable or disable retweets and device notifications from the specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> device (optional)</para>
        /// <para>- <c>bool</c> retweets (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The relationship.</returns>
        public Task<Relationship> UpdateAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Relationship>(MethodType.Post, "friendships/update", parameters, cancellationToken, jsonPath: "relationship", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Allows one to enable or disable retweets and device notifications from the specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> device (optional)</para>
        /// <para>- <c>bool</c> retweets (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The relationship.</returns>
        public Task<Relationship> UpdateAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Relationship>(MethodType.Post, "friendships/update", parameters, cancellationToken, jsonPath: "relationship", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Allows one to enable or disable retweets and device notifications from the specified user.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="device">optional.</param>
        /// <param name="retweets">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The relationship.</returns>
        public Task<Relationship> UpdateAsync(long user_id, bool? device = null, bool? retweets = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(device != null) parameters.Add("device", device);
            if(retweets != null) parameters.Add("retweets", retweets);
            return this.Tokens.AccessApiAsync<Relationship>(MethodType.Post, "friendships/update", parameters, cancellationToken, jsonPath: "relationship", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Allows one to enable or disable retweets and device notifications from the specified user.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="device">optional.</param>
        /// <param name="retweets">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The relationship.</returns>
        public Task<Relationship> UpdateAsync(string screen_name, bool? device = null, bool? retweets = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(device != null) parameters.Add("device", device);
            if(retweets != null) parameters.Add("retweets", retweets);
            return this.Tokens.AccessApiAsync<Relationship>(MethodType.Post, "friendships/update", parameters, cancellationToken, jsonPath: "relationship", urlPrefix: "1.1");
        }

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET/POST geo.
    /// </summary>
    public partial class Geo : ApiProviderBase
    {
        internal Geo(TokensBase e) : base(e) { }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns all the information about a known place.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> place_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The place.</returns>
        public PlaceResponse Id(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApi<PlaceResponse>(MethodType.Get, "geo/id/{place_id}", new [] { "place_id" }, InternalUtils.ExpressionsToDictionary(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns all the information about a known place.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> place_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The place.</returns>
        public PlaceResponse Id(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessParameterReservedApi<PlaceResponse>(MethodType.Get, "geo/id/{place_id}", new [] { "place_id" }, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns all the information about a known place.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> place_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The place.</returns>
        public PlaceResponse Id(object parameters)
        {
            return this.Tokens.AccessParameterReservedApi<PlaceResponse>(MethodType.Get, "geo/id/{place_id}", new [] { "place_id" }, InternalUtils.ResolveObject(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns all the information about a known place.</para>
        /// </summary>
        /// <param name="place_id">required.</param>
        /// <returns>The place.</returns>
        public PlaceResponse Id(string place_id)
        {
            var parameters = new Dictionary<string, object>();
            if(place_id == null) throw new ArgumentNullException("place_id");
            parameters.Add("place_id", place_id);
            return this.Tokens.AccessParameterReservedApi<PlaceResponse>(MethodType.Get, "geo/id/{place_id}", new [] { "place_id" }, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns all the information about a known place.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> place_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The place.</returns>
        public Task<PlaceResponse> IdAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiAsync<PlaceResponse>(MethodType.Get, "geo/id/{place_id}", new [] { "place_id" }, InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns all the information about a known place.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> place_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The place.</returns>
        public Task<PlaceResponse> IdAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<PlaceResponse>(MethodType.Get, "geo/id/{place_id}", new [] { "place_id" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns all the information about a known place.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> place_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The place.</returns>
        public Task<PlaceResponse> IdAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<PlaceResponse>(MethodType.Get, "geo/id/{place_id}", new [] { "place_id" }, InternalUtils.ResolveObject(parameters), cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns all the information about a known place.</para>
        /// </summary>
        /// <param name="place_id">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The place.</returns>
        public Task<PlaceResponse> IdAsync(string place_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(place_id == null) throw new ArgumentNullException("place_id");
            parameters.Add("place_id", place_id);
            return this.Tokens.AccessParameterReservedApiAsync<PlaceResponse>(MethodType.Get, "geo/id/{place_id}", new [] { "place_id" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Locates places near the given coordinates which are similar in name.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// <para>- <c>string</c> name (required)</para>
        /// <para>- <c>string</c> contained_within (optional)</para>
        /// <para>- <c>string</c> street_address (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Places and the token</returns>
        public GeoResult SimilarPlaces(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<GeoResult>(MethodType.Get, "geo/similar_places", parameters, jsonPath: "result", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Locates places near the given coordinates which are similar in name.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// <para>- <c>string</c> name (required)</para>
        /// <para>- <c>string</c> contained_within (optional)</para>
        /// <para>- <c>string</c> street_address (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Places and the token</returns>
        public GeoResult SimilarPlaces(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<GeoResult>(MethodType.Get, "geo/similar_places", parameters, jsonPath: "result", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Locates places near the given coordinates which are similar in name.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// <para>- <c>string</c> name (required)</para>
        /// <para>- <c>string</c> contained_within (optional)</para>
        /// <para>- <c>string</c> street_address (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Places and the token</returns>
        public GeoResult SimilarPlaces(object parameters)
        {
            return this.Tokens.AccessApi<GeoResult>(MethodType.Get, "geo/similar_places", parameters, jsonPath: "result", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Locates places near the given coordinates which are similar in name.</para>
        /// </summary>
        /// <param name="lat">required.</param>
        /// <param name="long">required.</param>
        /// <param name="name">required.</param>
        /// <param name="contained_within">optional.</param>
        /// <param name="street_address">optional.</param>
        /// <returns>Places and the token</returns>
        public GeoResult SimilarPlaces(double lat, double @long, string name, string contained_within = null, string street_address = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("lat", lat);
            parameters.Add("long", @long);
            if(name == null) throw new ArgumentNullException("name");
            parameters.Add("name", name);
            if(contained_within != null) parameters.Add("contained_within", contained_within);
            if(street_address != null) parameters.Add("street_address", street_address);
            return this.Tokens.AccessApi<GeoResult>(MethodType.Get, "geo/similar_places", parameters, jsonPath: "result", urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Locates places near the given coordinates which are similar in name.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// <para>- <c>string</c> name (required)</para>
        /// <para>- <c>string</c> contained_within (optional)</para>
        /// <para>- <c>string</c> street_address (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Places and the token</returns>
        public Task<GeoResult> SimilarPlacesAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<GeoResult>(MethodType.Get, "geo/similar_places", parameters, jsonPath: "result", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Locates places near the given coordinates which are similar in name.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// <para>- <c>string</c> name (required)</para>
        /// <para>- <c>string</c> contained_within (optional)</para>
        /// <para>- <c>string</c> street_address (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>Places and the token</returns>
        public Task<GeoResult> SimilarPlacesAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<GeoResult>(MethodType.Get, "geo/similar_places", parameters, cancellationToken, jsonPath: "result", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Locates places near the given coordinates which are similar in name.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// <para>- <c>string</c> name (required)</para>
        /// <para>- <c>string</c> contained_within (optional)</para>
        /// <para>- <c>string</c> street_address (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>Places and the token</returns>
        public Task<GeoResult> SimilarPlacesAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<GeoResult>(MethodType.Get, "geo/similar_places", parameters, cancellationToken, jsonPath: "result", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Locates places near the given coordinates which are similar in name.</para>
        /// </summary>
        /// <param name="lat">required.</param>
        /// <param name="long">required.</param>
        /// <param name="name">required.</param>
        /// <param name="contained_within">optional.</param>
        /// <param name="street_address">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>Places and the token</returns>
        public Task<GeoResult> SimilarPlacesAsync(double lat, double @long, string name, string contained_within = null, string street_address = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("lat", lat);
            parameters.Add("long", @long);
            if(name == null) throw new ArgumentNullException("name");
            parameters.Add("name", name);
            if(contained_within != null) parameters.Add("contained_within", contained_within);
            if(street_address != null) parameters.Add("street_address", street_address);
            return this.Tokens.AccessApiAsync<GeoResult>(MethodType.Get, "geo/similar_places", parameters, cancellationToken, jsonPath: "result", urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Search for places that can be attached to a statuses/update.</para>
        /// <para>Note: At least one of the following parameters must be provided to this resource: lat, long, ip, or query</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> query (optional)</para>
        /// <para>- <c>string</c> ip (optional)</para>
        /// <para>- <c>string</c> granularity (optional)</para>
        /// <para>- <c>string</c> accuracy (optional)</para>
        /// <para>- <c>int</c> max_results (optional)</para>
        /// <para>- <c>string</c> contained_within (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Places.</returns>
        public GeoResult Search(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<GeoResult>(MethodType.Get, "geo/search", parameters, jsonPath: "result", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Search for places that can be attached to a statuses/update.</para>
        /// <para>Note: At least one of the following parameters must be provided to this resource: lat, long, ip, or query</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> query (optional)</para>
        /// <para>- <c>string</c> ip (optional)</para>
        /// <para>- <c>string</c> granularity (optional)</para>
        /// <para>- <c>string</c> accuracy (optional)</para>
        /// <para>- <c>int</c> max_results (optional)</para>
        /// <para>- <c>string</c> contained_within (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Places.</returns>
        public GeoResult Search(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<GeoResult>(MethodType.Get, "geo/search", parameters, jsonPath: "result", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Search for places that can be attached to a statuses/update.</para>
        /// <para>Note: At least one of the following parameters must be provided to this resource: lat, long, ip, or query</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> query (optional)</para>
        /// <para>- <c>string</c> ip (optional)</para>
        /// <para>- <c>string</c> granularity (optional)</para>
        /// <para>- <c>string</c> accuracy (optional)</para>
        /// <para>- <c>int</c> max_results (optional)</para>
        /// <para>- <c>string</c> contained_within (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Places.</returns>
        public GeoResult Search(object parameters)
        {
            return this.Tokens.AccessApi<GeoResult>(MethodType.Get, "geo/search", parameters, jsonPath: "result", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Search for places that can be attached to a statuses/update.</para>
        /// <para>Note: At least one of the following parameters must be provided to this resource: lat, long, ip, or query</para>
        /// </summary>
        /// <param name="lat">optional.</param>
        /// <param name="long">optional.</param>
        /// <param name="query">optional.</param>
        /// <param name="ip">optional.</param>
        /// <param name="granularity">optional.</param>
        /// <param name="accuracy">optional.</param>
        /// <param name="max_results">optional.</param>
        /// <param name="contained_within">optional.</param>
        /// <returns>Places.</returns>
        public GeoResult Search(double? lat = null, double? @long = null, string query = null, string ip = null, string granularity = null, string accuracy = null, int? max_results = null, string contained_within = null)
        {
            var parameters = new Dictionary<string, object>();
            if(lat != null) parameters.Add("lat", lat);
            if(@long != null) parameters.Add("long", @long);
            if(query != null) parameters.Add("query", query);
            if(ip != null) parameters.Add("ip", ip);
            if(granularity != null) parameters.Add("granularity", granularity);
            if(accuracy != null) parameters.Add("accuracy", accuracy);
            if(max_results != null) parameters.Add("max_results", max_results);
            if(contained_within != null) parameters.Add("contained_within", contained_within);
            return this.Tokens.AccessApi<GeoResult>(MethodType.Get, "geo/search", parameters, jsonPath: "result", urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Search for places that can be attached to a statuses/update.</para>
        /// <para>Note: At least one of the following parameters must be provided to this resource: lat, long, ip, or query</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> query (optional)</para>
        /// <para>- <c>string</c> ip (optional)</para>
        /// <para>- <c>string</c> granularity (optional)</para>
        /// <para>- <c>string</c> accuracy (optional)</para>
        /// <para>- <c>int</c> max_results (optional)</para>
        /// <para>- <c>string</c> contained_within (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Places.</returns>
        public Task<GeoResult> SearchAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<GeoResult>(MethodType.Get, "geo/search", parameters, jsonPath: "result", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Search for places that can be attached to a statuses/update.</para>
        /// <para>Note: At least one of the following parameters must be provided to this resource: lat, long, ip, or query</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> query (optional)</para>
        /// <para>- <c>string</c> ip (optional)</para>
        /// <para>- <c>string</c> granularity (optional)</para>
        /// <para>- <c>string</c> accuracy (optional)</para>
        /// <para>- <c>int</c> max_results (optional)</para>
        /// <para>- <c>string</c> contained_within (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>Places.</returns>
        public Task<GeoResult> SearchAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<GeoResult>(MethodType.Get, "geo/search", parameters, cancellationToken, jsonPath: "result", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Search for places that can be attached to a statuses/update.</para>
        /// <para>Note: At least one of the following parameters must be provided to this resource: lat, long, ip, or query</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> query (optional)</para>
        /// <para>- <c>string</c> ip (optional)</para>
        /// <para>- <c>string</c> granularity (optional)</para>
        /// <para>- <c>string</c> accuracy (optional)</para>
        /// <para>- <c>int</c> max_results (optional)</para>
        /// <para>- <c>string</c> contained_within (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>Places.</returns>
        public Task<GeoResult> SearchAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<GeoResult>(MethodType.Get, "geo/search", parameters, cancellationToken, jsonPath: "result", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Search for places that can be attached to a statuses/update.</para>
        /// <para>Note: At least one of the following parameters must be provided to this resource: lat, long, ip, or query</para>
        /// </summary>
        /// <param name="lat">optional.</param>
        /// <param name="long">optional.</param>
        /// <param name="query">optional.</param>
        /// <param name="ip">optional.</param>
        /// <param name="granularity">optional.</param>
        /// <param name="accuracy">optional.</param>
        /// <param name="max_results">optional.</param>
        /// <param name="contained_within">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>Places.</returns>
        public Task<GeoResult> SearchAsync(double? lat = null, double? @long = null, string query = null, string ip = null, string granularity = null, string accuracy = null, int? max_results = null, string contained_within = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(lat != null) parameters.Add("lat", lat);
            if(@long != null) parameters.Add("long", @long);
            if(query != null) parameters.Add("query", query);
            if(ip != null) parameters.Add("ip", ip);
            if(granularity != null) parameters.Add("granularity", granularity);
            if(accuracy != null) parameters.Add("accuracy", accuracy);
            if(max_results != null) parameters.Add("max_results", max_results);
            if(contained_within != null) parameters.Add("contained_within", contained_within);
            return this.Tokens.AccessApiAsync<GeoResult>(MethodType.Get, "geo/search", parameters, cancellationToken, jsonPath: "result", urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Given a latitude and a longitude, searches for up to 20 places that can be used as a place_id when updating a status.</para>
        /// <para>This request is an informative call and will deliver generalized results about geography.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// <para>- <c>string</c> accuracy (optional)</para>
        /// <para>- <c>string</c> granularity (optional)</para>
        /// <para>- <c>int</c> max_results (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Places.</returns>
        public GeoResult ReverseGeocode(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<GeoResult>(MethodType.Get, "geo/reverse_geocode", parameters, jsonPath: "result", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Given a latitude and a longitude, searches for up to 20 places that can be used as a place_id when updating a status.</para>
        /// <para>This request is an informative call and will deliver generalized results about geography.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// <para>- <c>string</c> accuracy (optional)</para>
        /// <para>- <c>string</c> granularity (optional)</para>
        /// <para>- <c>int</c> max_results (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Places.</returns>
        public GeoResult ReverseGeocode(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<GeoResult>(MethodType.Get, "geo/reverse_geocode", parameters, jsonPath: "result", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Given a latitude and a longitude, searches for up to 20 places that can be used as a place_id when updating a status.</para>
        /// <para>This request is an informative call and will deliver generalized results about geography.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// <para>- <c>string</c> accuracy (optional)</para>
        /// <para>- <c>string</c> granularity (optional)</para>
        /// <para>- <c>int</c> max_results (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Places.</returns>
        public GeoResult ReverseGeocode(object parameters)
        {
            return this.Tokens.AccessApi<GeoResult>(MethodType.Get, "geo/reverse_geocode", parameters, jsonPath: "result", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Given a latitude and a longitude, searches for up to 20 places that can be used as a place_id when updating a status.</para>
        /// <para>This request is an informative call and will deliver generalized results about geography.</para>
        /// </summary>
        /// <param name="lat">required.</param>
        /// <param name="long">required.</param>
        /// <param name="accuracy">optional.</param>
        /// <param name="granularity">optional.</param>
        /// <param name="max_results">optional.</param>
        /// <returns>Places.</returns>
        public GeoResult ReverseGeocode(double lat, double @long, string accuracy = null, string granularity = null, int? max_results = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("lat", lat);
            parameters.Add("long", @long);
            if(accuracy != null) parameters.Add("accuracy", accuracy);
            if(granularity != null) parameters.Add("granularity", granularity);
            if(max_results != null) parameters.Add("max_results", max_results);
            return this.Tokens.AccessApi<GeoResult>(MethodType.Get, "geo/reverse_geocode", parameters, jsonPath: "result", urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Given a latitude and a longitude, searches for up to 20 places that can be used as a place_id when updating a status.</para>
        /// <para>This request is an informative call and will deliver generalized results about geography.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// <para>- <c>string</c> accuracy (optional)</para>
        /// <para>- <c>string</c> granularity (optional)</para>
        /// <para>- <c>int</c> max_results (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Places.</returns>
        public Task<GeoResult> ReverseGeocodeAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<GeoResult>(MethodType.Get, "geo/reverse_geocode", parameters, jsonPath: "result", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Given a latitude and a longitude, searches for up to 20 places that can be used as a place_id when updating a status.</para>
        /// <para>This request is an informative call and will deliver generalized results about geography.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// <para>- <c>string</c> accuracy (optional)</para>
        /// <para>- <c>string</c> granularity (optional)</para>
        /// <para>- <c>int</c> max_results (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>Places.</returns>
        public Task<GeoResult> ReverseGeocodeAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<GeoResult>(MethodType.Get, "geo/reverse_geocode", parameters, cancellationToken, jsonPath: "result", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Given a latitude and a longitude, searches for up to 20 places that can be used as a place_id when updating a status.</para>
        /// <para>This request is an informative call and will deliver generalized results about geography.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// <para>- <c>string</c> accuracy (optional)</para>
        /// <para>- <c>string</c> granularity (optional)</para>
        /// <para>- <c>int</c> max_results (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>Places.</returns>
        public Task<GeoResult> ReverseGeocodeAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<GeoResult>(MethodType.Get, "geo/reverse_geocode", parameters, cancellationToken, jsonPath: "result", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Given a latitude and a longitude, searches for up to 20 places that can be used as a place_id when updating a status.</para>
        /// <para>This request is an informative call and will deliver generalized results about geography.</para>
        /// </summary>
        /// <param name="lat">required.</param>
        /// <param name="long">required.</param>
        /// <param name="accuracy">optional.</param>
        /// <param name="granularity">optional.</param>
        /// <param name="max_results">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>Places.</returns>
        public Task<GeoResult> ReverseGeocodeAsync(double lat, double @long, string accuracy = null, string granularity = null, int? max_results = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("lat", lat);
            parameters.Add("long", @long);
            if(accuracy != null) parameters.Add("accuracy", accuracy);
            if(granularity != null) parameters.Add("granularity", granularity);
            if(max_results != null) parameters.Add("max_results", max_results);
            return this.Tokens.AccessApiAsync<GeoResult>(MethodType.Get, "geo/reverse_geocode", parameters, cancellationToken, jsonPath: "result", urlPrefix: "1.1");
        }

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET help.
    /// </summary>
    public partial class Help : ApiProviderBase
    {
        internal Help(TokensBase e) : base(e) { }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the current configuration used by Twitter including twitter.com slugs which are not usernames, maximum photo resolutions, and t.co URL lengths.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Configurations.</returns>
        public Configurations Configuration(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Configurations>(MethodType.Get, "help/configuration", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the current configuration used by Twitter including twitter.com slugs which are not usernames, maximum photo resolutions, and t.co URL lengths.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Configurations.</returns>
        public Configurations Configuration(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Configurations>(MethodType.Get, "help/configuration", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the current configuration used by Twitter including twitter.com slugs which are not usernames, maximum photo resolutions, and t.co URL lengths.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Configurations.</returns>
        public Configurations Configuration(object parameters)
        {
            return this.Tokens.AccessApi<Configurations>(MethodType.Get, "help/configuration", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the current configuration used by Twitter including twitter.com slugs which are not usernames, maximum photo resolutions, and t.co URL lengths.</para>
        /// </summary>
        /// <returns>Configurations.</returns>
        public Configurations Configuration()
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApi<Configurations>(MethodType.Get, "help/configuration", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns the current configuration used by Twitter including twitter.com slugs which are not usernames, maximum photo resolutions, and t.co URL lengths.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Configurations.</returns>
        public Task<Configurations> ConfigurationAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Configurations>(MethodType.Get, "help/configuration", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the current configuration used by Twitter including twitter.com slugs which are not usernames, maximum photo resolutions, and t.co URL lengths.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>Configurations.</returns>
        public Task<Configurations> ConfigurationAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Configurations>(MethodType.Get, "help/configuration", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the current configuration used by Twitter including twitter.com slugs which are not usernames, maximum photo resolutions, and t.co URL lengths.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>Configurations.</returns>
        public Task<Configurations> ConfigurationAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Configurations>(MethodType.Get, "help/configuration", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the current configuration used by Twitter including twitter.com slugs which are not usernames, maximum photo resolutions, and t.co URL lengths.</para>
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>Configurations.</returns>
        public Task<Configurations> ConfigurationAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiAsync<Configurations>(MethodType.Get, "help/configuration", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the list of languages supported by Twitter along with the language code supported by Twitter.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Languages.</returns>
        public ListedResponse<Language> Languages(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<Language>(MethodType.Get, "help/languages", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the list of languages supported by Twitter along with the language code supported by Twitter.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Languages.</returns>
        public ListedResponse<Language> Languages(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<Language>(MethodType.Get, "help/languages", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the list of languages supported by Twitter along with the language code supported by Twitter.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Languages.</returns>
        public ListedResponse<Language> Languages(object parameters)
        {
            return this.Tokens.AccessApiArray<Language>(MethodType.Get, "help/languages", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the list of languages supported by Twitter along with the language code supported by Twitter.</para>
        /// </summary>
        /// <returns>Languages.</returns>
        public ListedResponse<Language> Languages()
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiArray<Language>(MethodType.Get, "help/languages", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns the list of languages supported by Twitter along with the language code supported by Twitter.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Languages.</returns>
        public Task<ListedResponse<Language>> LanguagesAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<Language>(MethodType.Get, "help/languages", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the list of languages supported by Twitter along with the language code supported by Twitter.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>Languages.</returns>
        public Task<ListedResponse<Language>> LanguagesAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Language>(MethodType.Get, "help/languages", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the list of languages supported by Twitter along with the language code supported by Twitter.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>Languages.</returns>
        public Task<ListedResponse<Language>> LanguagesAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Language>(MethodType.Get, "help/languages", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the list of languages supported by Twitter along with the language code supported by Twitter.</para>
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>Languages.</returns>
        public Task<ListedResponse<Language>> LanguagesAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiArrayAsync<Language>(MethodType.Get, "help/languages", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns Twitter’s Privacy Policy.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The sentense.</returns>
        public StringResponse Privacy(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<StringResponse>(MethodType.Get, "help/privacy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns Twitter’s Privacy Policy.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The sentense.</returns>
        public StringResponse Privacy(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<StringResponse>(MethodType.Get, "help/privacy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns Twitter’s Privacy Policy.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The sentense.</returns>
        public StringResponse Privacy(object parameters)
        {
            return this.Tokens.AccessApi<StringResponse>(MethodType.Get, "help/privacy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns Twitter’s Privacy Policy.</para>
        /// </summary>
        /// <returns>The sentense.</returns>
        public StringResponse Privacy()
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApi<StringResponse>(MethodType.Get, "help/privacy", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns Twitter’s Privacy Policy.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The sentense.</returns>
        public Task<StringResponse> PrivacyAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<StringResponse>(MethodType.Get, "help/privacy", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns Twitter’s Privacy Policy.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The sentense.</returns>
        public Task<StringResponse> PrivacyAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<StringResponse>(MethodType.Get, "help/privacy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns Twitter’s Privacy Policy.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The sentense.</returns>
        public Task<StringResponse> PrivacyAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<StringResponse>(MethodType.Get, "help/privacy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns Twitter’s Privacy Policy.</para>
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The sentense.</returns>
        public Task<StringResponse> PrivacyAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiAsync<StringResponse>(MethodType.Get, "help/privacy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the Twitter Terms of Service.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The sentense.</returns>
        public StringResponse Tos(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<StringResponse>(MethodType.Get, "help/tos", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the Twitter Terms of Service.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The sentense.</returns>
        public StringResponse Tos(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<StringResponse>(MethodType.Get, "help/tos", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the Twitter Terms of Service.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The sentense.</returns>
        public StringResponse Tos(object parameters)
        {
            return this.Tokens.AccessApi<StringResponse>(MethodType.Get, "help/tos", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the Twitter Terms of Service.</para>
        /// </summary>
        /// <returns>The sentense.</returns>
        public StringResponse Tos()
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApi<StringResponse>(MethodType.Get, "help/tos", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns the Twitter Terms of Service.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The sentense.</returns>
        public Task<StringResponse> TosAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<StringResponse>(MethodType.Get, "help/tos", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the Twitter Terms of Service.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The sentense.</returns>
        public Task<StringResponse> TosAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<StringResponse>(MethodType.Get, "help/tos", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the Twitter Terms of Service.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The sentense.</returns>
        public Task<StringResponse> TosAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<StringResponse>(MethodType.Get, "help/tos", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the Twitter Terms of Service.</para>
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The sentense.</returns>
        public Task<StringResponse> TosAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiAsync<StringResponse>(MethodType.Get, "help/tos", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> resources (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> resources (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        [Obsolete("Use Application.RateLimitStatus.")]
        public DictionaryResponse<string, Dictionary<string,RateLimit>> RateLimitStatus(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiDictionary<string, Dictionary<string,RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, jsonPath: "resources", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> resources (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> resources (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        [Obsolete("Use Application.RateLimitStatus.")]
        public DictionaryResponse<string, Dictionary<string,RateLimit>> RateLimitStatus(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiDictionary<string, Dictionary<string,RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, jsonPath: "resources", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> resources (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> resources (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        [Obsolete("Use Application.RateLimitStatus.")]
        public DictionaryResponse<string, Dictionary<string,RateLimit>> RateLimitStatus(object parameters)
        {
            return this.Tokens.AccessApiDictionary<string, Dictionary<string,RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, jsonPath: "resources", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// </summary>
        /// <returns></returns>
        [Obsolete("Use Application.RateLimitStatus.")]
        public DictionaryResponse<string, Dictionary<string,RateLimit>> RateLimitStatus()
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiDictionary<string, Dictionary<string,RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, jsonPath: "resources", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// </summary>
        /// <param name="resources">any one is required.</param>
        /// <returns></returns>
        [Obsolete("Use Application.RateLimitStatus.")]
        public DictionaryResponse<string, Dictionary<string,RateLimit>> RateLimitStatus(string resources)
        {
            var parameters = new Dictionary<string, object>();
            if(resources == null) throw new ArgumentNullException("resources");
            parameters.Add("resources", resources);
            return this.Tokens.AccessApiDictionary<string, Dictionary<string,RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, jsonPath: "resources", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// </summary>
        /// <param name="resources">any one is required.</param>
        /// <returns></returns>
        [Obsolete("Use Application.RateLimitStatus.")]
        public DictionaryResponse<string, Dictionary<string,RateLimit>> RateLimitStatus(IEnumerable<string> resources)
        {
            var parameters = new Dictionary<string, object>();
            if(resources == null) throw new ArgumentNullException("resources");
            parameters.Add("resources", resources);
            return this.Tokens.AccessApiDictionary<string, Dictionary<string,RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, jsonPath: "resources", urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> resources (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> resources (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        [Obsolete("Use Application.RateLimitStatus.")]
        public Task<DictionaryResponse<string, Dictionary<string,RateLimit>>> RateLimitStatusAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiDictionaryAsync<string, Dictionary<string,RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, jsonPath: "resources", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> resources (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> resources (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        [Obsolete("Use Application.RateLimitStatus.")]
        public Task<DictionaryResponse<string, Dictionary<string,RateLimit>>> RateLimitStatusAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiDictionaryAsync<string, Dictionary<string,RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, cancellationToken, jsonPath: "resources", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> resources (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> resources (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        [Obsolete("Use Application.RateLimitStatus.")]
        public Task<DictionaryResponse<string, Dictionary<string,RateLimit>>> RateLimitStatusAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiDictionaryAsync<string, Dictionary<string,RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, cancellationToken, jsonPath: "resources", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        [Obsolete("Use Application.RateLimitStatus.")]
        public Task<DictionaryResponse<string, Dictionary<string,RateLimit>>> RateLimitStatusAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiDictionaryAsync<string, Dictionary<string,RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, cancellationToken, jsonPath: "resources", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// </summary>
        /// <param name="resources">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        [Obsolete("Use Application.RateLimitStatus.")]
        public Task<DictionaryResponse<string, Dictionary<string,RateLimit>>> RateLimitStatusAsync(string resources, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(resources == null) throw new ArgumentNullException("resources");
            parameters.Add("resources", resources);
            return this.Tokens.AccessApiDictionaryAsync<string, Dictionary<string,RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, cancellationToken, jsonPath: "resources", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// </summary>
        /// <param name="resources">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        [Obsolete("Use Application.RateLimitStatus.")]
        public Task<DictionaryResponse<string, Dictionary<string,RateLimit>>> RateLimitStatusAsync(IEnumerable<string> resources, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(resources == null) throw new ArgumentNullException("resources");
            parameters.Add("resources", resources);
            return this.Tokens.AccessApiDictionaryAsync<string, Dictionary<string,RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, cancellationToken, jsonPath: "resources", urlPrefix: "1.1");
        }

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET/POST lists.
    /// </summary>
    public partial class Lists : ApiProviderBase
    {
        internal Lists(TokensBase e) : base(e) { }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns all lists the authenticating or specified user subscribes to, including their own.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> reverse (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The lists.</returns>
        public ListedResponse<List> List(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<List>(MethodType.Get, "lists/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns all lists the authenticating or specified user subscribes to, including their own.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> reverse (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The lists.</returns>
        public ListedResponse<List> List(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<List>(MethodType.Get, "lists/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns all lists the authenticating or specified user subscribes to, including their own.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> reverse (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The lists.</returns>
        public ListedResponse<List> List(object parameters)
        {
            return this.Tokens.AccessApiArray<List>(MethodType.Get, "lists/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns all lists the authenticating or specified user subscribes to, including their own.</para>
        /// </summary>
        /// <param name="reverse">optional.</param>
        /// <returns>The lists.</returns>
        public ListedResponse<List> List(bool? reverse = null)
        {
            var parameters = new Dictionary<string, object>();
            if(reverse != null) parameters.Add("reverse", reverse);
            return this.Tokens.AccessApiArray<List>(MethodType.Get, "lists/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns all lists the authenticating or specified user subscribes to, including their own.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="reverse">optional.</param>
        /// <returns>The lists.</returns>
        public ListedResponse<List> List(long user_id, bool? reverse = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(reverse != null) parameters.Add("reverse", reverse);
            return this.Tokens.AccessApiArray<List>(MethodType.Get, "lists/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns all lists the authenticating or specified user subscribes to, including their own.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="reverse">optional.</param>
        /// <returns>The lists.</returns>
        public ListedResponse<List> List(string screen_name, bool? reverse = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(reverse != null) parameters.Add("reverse", reverse);
            return this.Tokens.AccessApiArray<List>(MethodType.Get, "lists/list", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns all lists the authenticating or specified user subscribes to, including their own.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> reverse (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The lists.</returns>
        public Task<ListedResponse<List>> ListAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<List>(MethodType.Get, "lists/list", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns all lists the authenticating or specified user subscribes to, including their own.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> reverse (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<ListedResponse<List>> ListAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<List>(MethodType.Get, "lists/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns all lists the authenticating or specified user subscribes to, including their own.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> reverse (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<ListedResponse<List>> ListAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<List>(MethodType.Get, "lists/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns all lists the authenticating or specified user subscribes to, including their own.</para>
        /// </summary>
        /// <param name="reverse">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<ListedResponse<List>> ListAsync(bool? reverse = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(reverse != null) parameters.Add("reverse", reverse);
            return this.Tokens.AccessApiArrayAsync<List>(MethodType.Get, "lists/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns all lists the authenticating or specified user subscribes to, including their own.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="reverse">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<ListedResponse<List>> ListAsync(long user_id, bool? reverse = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(reverse != null) parameters.Add("reverse", reverse);
            return this.Tokens.AccessApiArrayAsync<List>(MethodType.Get, "lists/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns all lists the authenticating or specified user subscribes to, including their own.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="reverse">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<ListedResponse<List>> ListAsync(string screen_name, bool? reverse = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(reverse != null) parameters.Add("reverse", reverse);
            return this.Tokens.AccessApiArrayAsync<List>(MethodType.Get, "lists/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> filter_to_owned_lists (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Memberships(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<List>>(MethodType.Get, "lists/memberships", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> filter_to_owned_lists (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Memberships(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<List>>(MethodType.Get, "lists/memberships", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> filter_to_owned_lists (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Memberships(object parameters)
        {
            return this.Tokens.AccessApi<Cursored<List>>(MethodType.Get, "lists/memberships", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="filter_to_owned_lists">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        public IEnumerable<List> EnumerateMemberships(EnumerateMode mode, int? count = null, long? cursor = null, bool? filter_to_owned_lists = null)
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(filter_to_owned_lists != null) parameters.Add("filter_to_owned_lists", filter_to_owned_lists);
            return Cursored.Enumerate<List>(this.Tokens, "lists/memberships", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="filter_to_owned_lists">optional.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Memberships(int? count = null, long? cursor = null, bool? filter_to_owned_lists = null)
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(filter_to_owned_lists != null) parameters.Add("filter_to_owned_lists", filter_to_owned_lists);
            return this.Tokens.AccessApi<Cursored<List>>(MethodType.Get, "lists/memberships", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="filter_to_owned_lists">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        public IEnumerable<List> EnumerateMemberships(EnumerateMode mode, long user_id, int? count = null, long? cursor = null, bool? filter_to_owned_lists = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(filter_to_owned_lists != null) parameters.Add("filter_to_owned_lists", filter_to_owned_lists);
            return Cursored.Enumerate<List>(this.Tokens, "lists/memberships", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="filter_to_owned_lists">optional.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Memberships(long user_id, int? count = null, long? cursor = null, bool? filter_to_owned_lists = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(filter_to_owned_lists != null) parameters.Add("filter_to_owned_lists", filter_to_owned_lists);
            return this.Tokens.AccessApi<Cursored<List>>(MethodType.Get, "lists/memberships", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="filter_to_owned_lists">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        public IEnumerable<List> EnumerateMemberships(EnumerateMode mode, string screen_name, int? count = null, long? cursor = null, bool? filter_to_owned_lists = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(filter_to_owned_lists != null) parameters.Add("filter_to_owned_lists", filter_to_owned_lists);
            return Cursored.Enumerate<List>(this.Tokens, "lists/memberships", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="filter_to_owned_lists">optional.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Memberships(string screen_name, int? count = null, long? cursor = null, bool? filter_to_owned_lists = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(filter_to_owned_lists != null) parameters.Add("filter_to_owned_lists", filter_to_owned_lists);
            return this.Tokens.AccessApi<Cursored<List>>(MethodType.Get, "lists/memberships", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> filter_to_owned_lists (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        public IEnumerable<List> EnumerateMemberships(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored.Enumerate<List>(this.Tokens, "lists/memberships", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> filter_to_owned_lists (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        public IEnumerable<List> EnumerateMemberships(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored.Enumerate<List>(this.Tokens, "lists/memberships", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> filter_to_owned_lists (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        public IEnumerable<List> EnumerateMemberships(EnumerateMode mode, object parameters)
        {
            return Cursored.Enumerate<List>(this.Tokens, "lists/memberships", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> filter_to_owned_lists (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> MembershipsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<List>>(MethodType.Get, "lists/memberships", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> filter_to_owned_lists (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> MembershipsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<List>>(MethodType.Get, "lists/memberships", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> filter_to_owned_lists (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> MembershipsAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<List>>(MethodType.Get, "lists/memberships", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="filter_to_owned_lists">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> MembershipsAsync(int? count = null, long? cursor = null, bool? filter_to_owned_lists = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(filter_to_owned_lists != null) parameters.Add("filter_to_owned_lists", filter_to_owned_lists);
            return this.Tokens.AccessApiAsync<Cursored<List>>(MethodType.Get, "lists/memberships", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="filter_to_owned_lists">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> MembershipsAsync(long user_id, int? count = null, long? cursor = null, bool? filter_to_owned_lists = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(filter_to_owned_lists != null) parameters.Add("filter_to_owned_lists", filter_to_owned_lists);
            return this.Tokens.AccessApiAsync<Cursored<List>>(MethodType.Get, "lists/memberships", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="filter_to_owned_lists">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> MembershipsAsync(string screen_name, int? count = null, long? cursor = null, bool? filter_to_owned_lists = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(filter_to_owned_lists != null) parameters.Add("filter_to_owned_lists", filter_to_owned_lists);
            return this.Tokens.AccessApiAsync<Cursored<List>>(MethodType.Get, "lists/memberships", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Ownerships(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<List>>(MethodType.Get, "lists/ownerships", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Ownerships(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<List>>(MethodType.Get, "lists/ownerships", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Ownerships(object parameters)
        {
            return this.Tokens.AccessApi<Cursored<List>>(MethodType.Get, "lists/ownerships", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        public IEnumerable<List> EnumerateOwnerships(EnumerateMode mode, int? count = null, long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return Cursored.Enumerate<List>(this.Tokens, "lists/ownerships", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Ownerships(int? count = null, long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApi<Cursored<List>>(MethodType.Get, "lists/ownerships", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        public IEnumerable<List> EnumerateOwnerships(EnumerateMode mode, long user_id, int? count = null, long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return Cursored.Enumerate<List>(this.Tokens, "lists/ownerships", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Ownerships(long user_id, int? count = null, long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApi<Cursored<List>>(MethodType.Get, "lists/ownerships", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        public IEnumerable<List> EnumerateOwnerships(EnumerateMode mode, string screen_name, int? count = null, long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return Cursored.Enumerate<List>(this.Tokens, "lists/ownerships", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Ownerships(string screen_name, int? count = null, long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApi<Cursored<List>>(MethodType.Get, "lists/ownerships", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        public IEnumerable<List> EnumerateOwnerships(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored.Enumerate<List>(this.Tokens, "lists/ownerships", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        public IEnumerable<List> EnumerateOwnerships(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored.Enumerate<List>(this.Tokens, "lists/ownerships", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        public IEnumerable<List> EnumerateOwnerships(EnumerateMode mode, object parameters)
        {
            return Cursored.Enumerate<List>(this.Tokens, "lists/ownerships", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> OwnershipsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<List>>(MethodType.Get, "lists/ownerships", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> OwnershipsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<List>>(MethodType.Get, "lists/ownerships", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> OwnershipsAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<List>>(MethodType.Get, "lists/ownerships", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> OwnershipsAsync(int? count = null, long? cursor = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApiAsync<Cursored<List>>(MethodType.Get, "lists/ownerships", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> OwnershipsAsync(long user_id, int? count = null, long? cursor = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApiAsync<Cursored<List>>(MethodType.Get, "lists/ownerships", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> OwnershipsAsync(string screen_name, int? count = null, long? cursor = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApiAsync<Cursored<List>>(MethodType.Get, "lists/ownerships", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Show(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Get, "lists/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Show(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Get, "lists/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Show(object parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Get, "lists/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Show(long list_id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Get, "lists/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Show(string slug, string owner_screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Get, "lists/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Show(string slug, long owner_id)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Get, "lists/show", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> ShowAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Get, "lists/show", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> ShowAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Get, "lists/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> ShowAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Get, "lists/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> ShowAsync(long list_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Get, "lists/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> ShowAsync(string slug, string owner_screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Get, "lists/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> ShowAsync(string slug, long owner_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Get, "lists/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Obtain a collection of the lists the specified user is subscribed to.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Subscriptions(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<List>>(MethodType.Get, "lists/subscriptions", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Obtain a collection of the lists the specified user is subscribed to.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Subscriptions(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<List>>(MethodType.Get, "lists/subscriptions", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Obtain a collection of the lists the specified user is subscribed to.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Subscriptions(object parameters)
        {
            return this.Tokens.AccessApi<Cursored<List>>(MethodType.Get, "lists/subscriptions", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Obtain a collection of the lists the specified user is subscribed to.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        public IEnumerable<List> EnumerateSubscriptions(EnumerateMode mode, long user_id, int? count = null, long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return Cursored.Enumerate<List>(this.Tokens, "lists/subscriptions", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Obtain a collection of the lists the specified user is subscribed to.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Subscriptions(long user_id, int? count = null, long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApi<Cursored<List>>(MethodType.Get, "lists/subscriptions", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Obtain a collection of the lists the specified user is subscribed to.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        public IEnumerable<List> EnumerateSubscriptions(EnumerateMode mode, string screen_name, int? count = null, long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return Cursored.Enumerate<List>(this.Tokens, "lists/subscriptions", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Obtain a collection of the lists the specified user is subscribed to.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Subscriptions(string screen_name, int? count = null, long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApi<Cursored<List>>(MethodType.Get, "lists/subscriptions", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Obtain a collection of the lists the specified user is subscribed to.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        public IEnumerable<List> EnumerateSubscriptions(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored.Enumerate<List>(this.Tokens, "lists/subscriptions", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Obtain a collection of the lists the specified user is subscribed to.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        public IEnumerable<List> EnumerateSubscriptions(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored.Enumerate<List>(this.Tokens, "lists/subscriptions", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Obtain a collection of the lists the specified user is subscribed to.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        public IEnumerable<List> EnumerateSubscriptions(EnumerateMode mode, object parameters)
        {
            return Cursored.Enumerate<List>(this.Tokens, "lists/subscriptions", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Obtain a collection of the lists the specified user is subscribed to.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> SubscriptionsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<List>>(MethodType.Get, "lists/subscriptions", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Obtain a collection of the lists the specified user is subscribed to.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> SubscriptionsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<List>>(MethodType.Get, "lists/subscriptions", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Obtain a collection of the lists the specified user is subscribed to.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> SubscriptionsAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<List>>(MethodType.Get, "lists/subscriptions", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Obtain a collection of the lists the specified user is subscribed to.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> SubscriptionsAsync(long user_id, int? count = null, long? cursor = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApiAsync<Cursored<List>>(MethodType.Get, "lists/subscriptions", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Obtain a collection of the lists the specified user is subscribed to.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> SubscriptionsAsync(string screen_name, int? count = null, long? cursor = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApiAsync<Cursored<List>>(MethodType.Get, "lists/subscriptions", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a timeline of tweets authored by members of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_rts (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> Statuses(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "lists/statuses", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a timeline of tweets authored by members of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_rts (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> Statuses(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "lists/statuses", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a timeline of tweets authored by members of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_rts (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> Statuses(object parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "lists/statuses", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a timeline of tweets authored by members of the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_rts">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> Statuses(long list_id, long? since_id = null, long? max_id = null, int? count = null, bool? include_entities = null, bool? include_rts = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(count != null) parameters.Add("count", count);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_rts != null) parameters.Add("include_rts", include_rts);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "lists/statuses", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a timeline of tweets authored by members of the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_rts">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> Statuses(string slug, string owner_screen_name, long? since_id = null, long? max_id = null, int? count = null, bool? include_entities = null, bool? include_rts = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(count != null) parameters.Add("count", count);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_rts != null) parameters.Add("include_rts", include_rts);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "lists/statuses", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a timeline of tweets authored by members of the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_rts">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> Statuses(string slug, long owner_id, long? since_id = null, long? max_id = null, int? count = null, bool? include_entities = null, bool? include_rts = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(count != null) parameters.Add("count", count);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_rts != null) parameters.Add("include_rts", include_rts);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "lists/statuses", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns a timeline of tweets authored by members of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_rts (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> StatusesAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "lists/statuses", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a timeline of tweets authored by members of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_rts (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> StatusesAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "lists/statuses", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a timeline of tweets authored by members of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_rts (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> StatusesAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "lists/statuses", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a timeline of tweets authored by members of the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_rts">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> StatusesAsync(long list_id, long? since_id = null, long? max_id = null, int? count = null, bool? include_entities = null, bool? include_rts = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(count != null) parameters.Add("count", count);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_rts != null) parameters.Add("include_rts", include_rts);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "lists/statuses", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a timeline of tweets authored by members of the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_rts">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> StatusesAsync(string slug, string owner_screen_name, long? since_id = null, long? max_id = null, int? count = null, bool? include_entities = null, bool? include_rts = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(count != null) parameters.Add("count", count);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_rts != null) parameters.Add("include_rts", include_rts);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "lists/statuses", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a timeline of tweets authored by members of the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_rts">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> StatusesAsync(string slug, long owner_id, long? since_id = null, long? max_id = null, int? count = null, bool? include_entities = null, bool? include_rts = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(count != null) parameters.Add("count", count);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_rts != null) parameters.Add("include_rts", include_rts);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "lists/statuses", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Creates a new list for the authenticated user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (required)</para>
        /// <para>- <c>string</c> mode (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Creates a new list for the authenticated user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (required)</para>
        /// <para>- <c>string</c> mode (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Creates a new list for the authenticated user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (required)</para>
        /// <para>- <c>string</c> mode (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(object parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Creates a new list for the authenticated user.</para>
        /// </summary>
        /// <param name="name">required.</param>
        /// <param name="mode">optional.</param>
        /// <param name="description">optional.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(string name, string mode = null, string description = null)
        {
            var parameters = new Dictionary<string, object>();
            if(name == null) throw new ArgumentNullException("name");
            parameters.Add("name", name);
            if(mode != null) parameters.Add("mode", mode);
            if(description != null) parameters.Add("description", description);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/create", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Creates a new list for the authenticated user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (required)</para>
        /// <para>- <c>string</c> mode (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/create", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Creates a new list for the authenticated user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (required)</para>
        /// <para>- <c>string</c> mode (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Creates a new list for the authenticated user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (required)</para>
        /// <para>- <c>string</c> mode (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Creates a new list for the authenticated user.</para>
        /// </summary>
        /// <param name="name">required.</param>
        /// <param name="mode">optional.</param>
        /// <param name="description">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(string name, string mode = null, string description = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(name == null) throw new ArgumentNullException("name");
            parameters.Add("name", name);
            if(mode != null) parameters.Add("mode", mode);
            if(description != null) parameters.Add("description", description);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Deletes the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The destroyed list.</returns>
        public ListResponse Destroy(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Deletes the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The destroyed list.</returns>
        public ListResponse Destroy(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Deletes the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The destroyed list.</returns>
        public ListResponse Destroy(object parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Deletes the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <returns>The destroyed list.</returns>
        public ListResponse Destroy(long list_id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Deletes the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <returns>The destroyed list.</returns>
        public ListResponse Destroy(string slug, string owner_screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Deletes the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <returns>The destroyed list.</returns>
        public ListResponse Destroy(string slug, long owner_id)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Deletes the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The destroyed list.</returns>
        public Task<ListResponse> DestroyAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/destroy", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Deletes the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The destroyed list.</returns>
        public Task<ListResponse> DestroyAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Deletes the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The destroyed list.</returns>
        public Task<ListResponse> DestroyAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Deletes the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The destroyed list.</returns>
        public Task<ListResponse> DestroyAsync(long list_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Deletes the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The destroyed list.</returns>
        public Task<ListResponse> DestroyAsync(string slug, string owner_screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Deletes the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The destroyed list.</returns>
        public Task<ListResponse> DestroyAsync(string slug, long owner_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Updates the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> mode (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Update(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/update", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Updates the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> mode (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Update(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/update", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Updates the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> mode (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Update(object parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/update", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Updates the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="name">optional.</param>
        /// <param name="mode">optional.</param>
        /// <param name="description">optional.</param>
        /// <returns>The list.</returns>
        public ListResponse Update(long list_id, string name = null, string mode = null, string description = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(name != null) parameters.Add("name", name);
            if(mode != null) parameters.Add("mode", mode);
            if(description != null) parameters.Add("description", description);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/update", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Updates the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="name">optional.</param>
        /// <param name="mode">optional.</param>
        /// <param name="description">optional.</param>
        /// <returns>The list.</returns>
        public ListResponse Update(string slug, string owner_screen_name, string name = null, string mode = null, string description = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            if(name != null) parameters.Add("name", name);
            if(mode != null) parameters.Add("mode", mode);
            if(description != null) parameters.Add("description", description);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/update", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Updates the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="name">optional.</param>
        /// <param name="mode">optional.</param>
        /// <param name="description">optional.</param>
        /// <returns>The list.</returns>
        public ListResponse Update(string slug, long owner_id, string name = null, string mode = null, string description = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(name != null) parameters.Add("name", name);
            if(mode != null) parameters.Add("mode", mode);
            if(description != null) parameters.Add("description", description);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/update", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Updates the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> mode (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> UpdateAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/update", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Updates the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> mode (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> UpdateAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/update", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Updates the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> mode (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> UpdateAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/update", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Updates the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="name">optional.</param>
        /// <param name="mode">optional.</param>
        /// <param name="description">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> UpdateAsync(long list_id, string name = null, string mode = null, string description = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(name != null) parameters.Add("name", name);
            if(mode != null) parameters.Add("mode", mode);
            if(description != null) parameters.Add("description", description);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/update", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Updates the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="name">optional.</param>
        /// <param name="mode">optional.</param>
        /// <param name="description">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> UpdateAsync(string slug, string owner_screen_name, string name = null, string mode = null, string description = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            if(name != null) parameters.Add("name", name);
            if(mode != null) parameters.Add("mode", mode);
            if(description != null) parameters.Add("description", description);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/update", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Updates the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="name">optional.</param>
        /// <param name="mode">optional.</param>
        /// <param name="description">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> UpdateAsync(string slug, long owner_id, string name = null, string mode = null, string description = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(name != null) parameters.Add("name", name);
            if(mode != null) parameters.Add("mode", mode);
            if(description != null) parameters.Add("description", description);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/update", parameters, cancellationToken, urlPrefix: "1.1");
        }

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET/POST lists/members.
    /// </summary>
    public partial class ListsMembers : ApiProviderBase
    {
        internal ListsMembers(TokensBase e) : base(e) { }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "lists/members", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "lists/members", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(object parameters)
        {
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "lists/members", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, long list_id, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return Cursored.Enumerate<User>(this.Tokens, "lists/members", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(long list_id, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "lists/members", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, string slug, string owner_screen_name, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return Cursored.Enumerate<User>(this.Tokens, "lists/members", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(string slug, string owner_screen_name, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "lists/members", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, string slug, long owner_id, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return Cursored.Enumerate<User>(this.Tokens, "lists/members", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(string slug, long owner_id, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "lists/members", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored.Enumerate<User>(this.Tokens, "lists/members", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored.Enumerate<User>(this.Tokens, "lists/members", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, object parameters)
        {
            return Cursored.Enumerate<User>(this.Tokens, "lists/members", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "lists/members", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "lists/members", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "lists/members", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(long list_id, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "lists/members", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(string slug, string owner_screen_name, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "lists/members", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(string slug, long owner_id, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "lists/members", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/members/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/members/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(object parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/members/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(long list_id, long user_id, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/members/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(long list_id, string screen_name, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/members/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(string slug, string owner_screen_name, long user_id, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/members/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(string slug, string owner_screen_name, string screen_name, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/members/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(string slug, long owner_id, long user_id, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/members/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(string slug, long owner_id, string screen_name, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/members/show", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/members/show", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/members/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/members/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(long list_id, long user_id, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/members/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(long list_id, string screen_name, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/members/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(string slug, string owner_screen_name, long user_id, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/members/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(string slug, string owner_screen_name, string screen_name, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/members/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(string slug, long owner_id, long user_id, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/members/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(string slug, long owner_id, string screen_name, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/members/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Add a member to a list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Add a member to a list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Add a member to a list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(object parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Add a member to a list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(long list_id, long user_id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Add a member to a list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(long list_id, string screen_name)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Add a member to a list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(string slug, string owner_screen_name, long user_id)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Add a member to a list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(string slug, string owner_screen_name, string screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Add a member to a list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(string slug, long owner_id, long user_id)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Add a member to a list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(string slug, long owner_id, string screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Add a member to a list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Add a member to a list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Add a member to a list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Add a member to a list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(long list_id, long user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Add a member to a list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(long list_id, string screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Add a member to a list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(string slug, string owner_screen_name, long user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Add a member to a list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(string slug, string owner_screen_name, string screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Add a member to a list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(string slug, long owner_id, long user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Add a member to a list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(string slug, long owner_id, string screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse CreateAll(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create_all", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse CreateAll(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create_all", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse CreateAll(object parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create_all", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse CreateAll(long list_id, IEnumerable<long> user_id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(user_id == null) throw new ArgumentNullException("user_id");
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create_all", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse CreateAll(long list_id, IEnumerable<string> screen_name)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create_all", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse CreateAll(string slug, string owner_screen_name, IEnumerable<long> user_id)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            if(user_id == null) throw new ArgumentNullException("user_id");
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create_all", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse CreateAll(string slug, string owner_screen_name, IEnumerable<string> screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create_all", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse CreateAll(string slug, long owner_id, IEnumerable<long> user_id)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(user_id == null) throw new ArgumentNullException("user_id");
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create_all", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse CreateAll(string slug, long owner_id, IEnumerable<string> screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create_all", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAllAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create_all", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAllAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create_all", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAllAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create_all", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAllAsync(long list_id, IEnumerable<long> user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(user_id == null) throw new ArgumentNullException("user_id");
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create_all", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAllAsync(long list_id, IEnumerable<string> screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create_all", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAllAsync(string slug, string owner_screen_name, IEnumerable<long> user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            if(user_id == null) throw new ArgumentNullException("user_id");
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create_all", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAllAsync(string slug, string owner_screen_name, IEnumerable<string> screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create_all", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAllAsync(string slug, long owner_id, IEnumerable<long> user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(user_id == null) throw new ArgumentNullException("user_id");
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create_all", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAllAsync(string slug, long owner_id, IEnumerable<string> screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create_all", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Removes the specified member from the list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Destroy(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Removes the specified member from the list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Destroy(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Removes the specified member from the list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Destroy(object parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Removes the specified member from the list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Destroy(long list_id, long user_id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Removes the specified member from the list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Destroy(long list_id, string screen_name)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Removes the specified member from the list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Destroy(string slug, string owner_screen_name, long user_id)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Removes the specified member from the list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Destroy(string slug, string owner_screen_name, string screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Removes the specified member from the list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Destroy(string slug, long owner_id, long user_id)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Removes the specified member from the list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Destroy(string slug, long owner_id, string screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Removes the specified member from the list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Removes the specified member from the list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Removes the specified member from the list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Removes the specified member from the list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAsync(long list_id, long user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Removes the specified member from the list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAsync(long list_id, string screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Removes the specified member from the list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAsync(string slug, string owner_screen_name, long user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Removes the specified member from the list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAsync(string slug, string owner_screen_name, string screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Removes the specified member from the list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAsync(string slug, long owner_id, long user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Removes the specified member from the list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAsync(string slug, long owner_id, string screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse DestroyAll(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse DestroyAll(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse DestroyAll(object parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse DestroyAll(long list_id, IEnumerable<long> user_id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(user_id == null) throw new ArgumentNullException("user_id");
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse DestroyAll(long list_id, IEnumerable<string> screen_name)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse DestroyAll(string slug, string owner_screen_name, IEnumerable<long> user_id)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            if(user_id == null) throw new ArgumentNullException("user_id");
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse DestroyAll(string slug, string owner_screen_name, IEnumerable<string> screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse DestroyAll(string slug, long owner_id, IEnumerable<long> user_id)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(user_id == null) throw new ArgumentNullException("user_id");
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse DestroyAll(string slug, long owner_id, IEnumerable<string> screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAllAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAllAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAllAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAllAsync(long list_id, IEnumerable<long> user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(user_id == null) throw new ArgumentNullException("user_id");
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAllAsync(long list_id, IEnumerable<string> screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAllAsync(string slug, string owner_screen_name, IEnumerable<long> user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            if(user_id == null) throw new ArgumentNullException("user_id");
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAllAsync(string slug, string owner_screen_name, IEnumerable<string> screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAllAsync(string slug, long owner_id, IEnumerable<long> user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(user_id == null) throw new ArgumentNullException("user_id");
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAllAsync(string slug, long owner_id, IEnumerable<string> screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters, cancellationToken, urlPrefix: "1.1");
        }

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET/POST lists/subscribers.
    /// </summary>
    public partial class ListsSubscribers : ApiProviderBase
    {
        internal ListsSubscribers(TokensBase e) : base(e) { }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "lists/subscribers", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "lists/subscribers", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(object parameters)
        {
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "lists/subscribers", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, long list_id, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return Cursored.Enumerate<User>(this.Tokens, "lists/subscribers", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(long list_id, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "lists/subscribers", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, string slug, string owner_screen_name, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return Cursored.Enumerate<User>(this.Tokens, "lists/subscribers", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(string slug, string owner_screen_name, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "lists/subscribers", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, string slug, long owner_id, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return Cursored.Enumerate<User>(this.Tokens, "lists/subscribers", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(string slug, long owner_id, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "lists/subscribers", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored.Enumerate<User>(this.Tokens, "lists/subscribers", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored.Enumerate<User>(this.Tokens, "lists/subscribers", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, object parameters)
        {
            return Cursored.Enumerate<User>(this.Tokens, "lists/subscribers", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "lists/subscribers", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "lists/subscribers", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "lists/subscribers", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(long list_id, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "lists/subscribers", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(string slug, string owner_screen_name, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "lists/subscribers", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(string slug, long owner_id, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "lists/subscribers", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(object parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(long list_id, long user_id, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(long list_id, string screen_name, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(string slug, string owner_screen_name, long user_id, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(string slug, string owner_screen_name, string screen_name, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(string slug, long owner_id, long user_id, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(string slug, long owner_id, string screen_name, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(long list_id, long user_id, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(long list_id, string screen_name, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(string slug, string owner_screen_name, long user_id, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(string slug, string owner_screen_name, string screen_name, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(string slug, long owner_id, long user_id, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(string slug, long owner_id, string screen_name, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Subscribes the authenticated user to the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/subscribers/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Subscribes the authenticated user to the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/subscribers/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Subscribes the authenticated user to the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(object parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/subscribers/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Subscribes the authenticated user to the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(long list_id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/subscribers/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Subscribes the authenticated user to the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(string slug, string owner_screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/subscribers/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Subscribes the authenticated user to the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(string slug, long owner_id)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/subscribers/create", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Subscribes the authenticated user to the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/subscribers/create", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Subscribes the authenticated user to the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/subscribers/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Subscribes the authenticated user to the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/subscribers/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Subscribes the authenticated user to the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(long list_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/subscribers/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Subscribes the authenticated user to the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(string slug, string owner_screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/subscribers/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Subscribes the authenticated user to the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(string slug, long owner_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/subscribers/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Unsubscribes the authenticated user from the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Destroy(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/subscribers/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Unsubscribes the authenticated user from the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Destroy(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/subscribers/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Unsubscribes the authenticated user from the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Destroy(object parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/subscribers/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Unsubscribes the authenticated user from the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Destroy(long list_id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/subscribers/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Unsubscribes the authenticated user from the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Destroy(string slug, string owner_screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/subscribers/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Unsubscribes the authenticated user from the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Destroy(string slug, long owner_id)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/subscribers/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Unsubscribes the authenticated user from the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/subscribers/destroy", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Unsubscribes the authenticated user from the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/subscribers/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Unsubscribes the authenticated user from the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/subscribers/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Unsubscribes the authenticated user from the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAsync(long list_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/subscribers/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Unsubscribes the authenticated user from the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAsync(string slug, string owner_screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            parameters.Add("owner_screen_name", owner_screen_name);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/subscribers/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Unsubscribes the authenticated user from the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAsync(string slug, long owner_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/subscribers/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of POST media.
    /// </summary>
    public partial class Media : ApiProviderBase
    {
        internal Media(TokensBase e) : base(e) { }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Upload media (images) to Twitter for use in a Tweet or Twitter-hosted Card.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> media (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> media (any one is required)</para>
        /// <para>- <c>FileInfo</c> media (any one is required)</para>
        /// <para>- <c>string</c> media_data (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> additional_owners (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The result for the uploaded media.</returns>
        public MediaUploadResult Upload(params Expression<Func<string, object>>[] parameters)
        {
            return this.UploadImpl(InternalUtils.ExpressionsToDictionary(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Upload media (images) to Twitter for use in a Tweet or Twitter-hosted Card.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> media (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> media (any one is required)</para>
        /// <para>- <c>FileInfo</c> media (any one is required)</para>
        /// <para>- <c>string</c> media_data (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> additional_owners (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The result for the uploaded media.</returns>
        public MediaUploadResult Upload(IDictionary<string, object> parameters)
        {
            return this.UploadImpl(parameters, "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Upload media (images) to Twitter for use in a Tweet or Twitter-hosted Card.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> media (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> media (any one is required)</para>
        /// <para>- <c>FileInfo</c> media (any one is required)</para>
        /// <para>- <c>string</c> media_data (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> additional_owners (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The result for the uploaded media.</returns>
        public MediaUploadResult Upload(object parameters)
        {
            return this.UploadImpl(InternalUtils.ResolveObject(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Upload media (images) to Twitter for use in a Tweet or Twitter-hosted Card.</para>
        /// </summary>
        /// <param name="media">any one is required.</param>
        /// <param name="additional_owners">optional.</param>
        /// <returns>The result for the uploaded media.</returns>
        public MediaUploadResult Upload(Stream media, IEnumerable<long> additional_owners = null)
        {
            var parameters = new Dictionary<string, object>();
            if(media == null) throw new ArgumentNullException("media");
            parameters.Add("media", media);
            if(additional_owners != null) parameters.Add("additional_owners", additional_owners);
            return this.UploadImpl(parameters, "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Upload media (images) to Twitter for use in a Tweet or Twitter-hosted Card.</para>
        /// </summary>
        /// <param name="media">any one is required.</param>
        /// <param name="additional_owners">optional.</param>
        /// <returns>The result for the uploaded media.</returns>
        public MediaUploadResult Upload(IEnumerable<byte> media, IEnumerable<long> additional_owners = null)
        {
            var parameters = new Dictionary<string, object>();
            if(media == null) throw new ArgumentNullException("media");
            parameters.Add("media", media);
            if(additional_owners != null) parameters.Add("additional_owners", additional_owners);
            return this.UploadImpl(parameters, "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Upload media (images) to Twitter for use in a Tweet or Twitter-hosted Card.</para>
        /// </summary>
        /// <param name="media">any one is required.</param>
        /// <param name="additional_owners">optional.</param>
        /// <returns>The result for the uploaded media.</returns>
        public MediaUploadResult Upload(FileInfo media, IEnumerable<long> additional_owners = null)
        {
            var parameters = new Dictionary<string, object>();
            if(media == null) throw new ArgumentNullException("media");
            parameters.Add("media", media);
            if(additional_owners != null) parameters.Add("additional_owners", additional_owners);
            return this.UploadImpl(parameters, "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Upload media (images) to Twitter for use in a Tweet or Twitter-hosted Card.</para>
        /// </summary>
        /// <param name="media_data">any one is required.</param>
        /// <param name="additional_owners">optional.</param>
        /// <returns>The result for the uploaded media.</returns>
        public MediaUploadResult Upload(string media_data, IEnumerable<long> additional_owners = null)
        {
            var parameters = new Dictionary<string, object>();
            if(media_data == null) throw new ArgumentNullException("media_data");
            parameters.Add("media_data", media_data);
            if(additional_owners != null) parameters.Add("additional_owners", additional_owners);
            return this.UploadImpl(parameters, "1.1", null);
        }
        #endif

        /// <summary>
        /// <para>Upload media (images) to Twitter for use in a Tweet or Twitter-hosted Card.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> media (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> media (any one is required)</para>
        /// <para>- <c>FileInfo</c> media (any one is required)</para>
        /// <para>- <c>string</c> media_data (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> additional_owners (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The result for the uploaded media.</returns>
        public Task<MediaUploadResult> UploadAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.UploadAsyncImpl(InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, "1.1", null);
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Initialize an upload.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> total_bytes (required)</para>
        /// <para>- <c>string</c> media_type (any one is required)</para>
        /// <para>- <c>UploadMediaType</c> media_type (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> additional_owners (optional)</para>
        /// <para>- <c>string</c> media_category (optional)</para>
        /// <para>- <c>bool</c> shared (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The result of INIT command.</returns>
        public UploadInitCommandResult UploadInitCommand(params Expression<Func<string, object>>[] parameters)
        {
            return this.UploadInitCommandImpl(InternalUtils.ExpressionsToDictionary(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Initialize an upload.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> total_bytes (required)</para>
        /// <para>- <c>string</c> media_type (any one is required)</para>
        /// <para>- <c>UploadMediaType</c> media_type (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> additional_owners (optional)</para>
        /// <para>- <c>string</c> media_category (optional)</para>
        /// <para>- <c>bool</c> shared (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The result of INIT command.</returns>
        public UploadInitCommandResult UploadInitCommand(IDictionary<string, object> parameters)
        {
            return this.UploadInitCommandImpl(parameters, "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Initialize an upload.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> total_bytes (required)</para>
        /// <para>- <c>string</c> media_type (any one is required)</para>
        /// <para>- <c>UploadMediaType</c> media_type (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> additional_owners (optional)</para>
        /// <para>- <c>string</c> media_category (optional)</para>
        /// <para>- <c>bool</c> shared (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The result of INIT command.</returns>
        public UploadInitCommandResult UploadInitCommand(object parameters)
        {
            return this.UploadInitCommandImpl(InternalUtils.ResolveObject(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Initialize an upload.</para>
        /// </summary>
        /// <param name="total_bytes">required.</param>
        /// <param name="media_type">any one is required.</param>
        /// <param name="additional_owners">optional.</param>
        /// <param name="media_category">optional.</param>
        /// <param name="shared">optional.</param>
        /// <returns>The result of INIT command.</returns>
        public UploadInitCommandResult UploadInitCommand(int total_bytes, string media_type, IEnumerable<long> additional_owners = null, string media_category = null, bool? shared = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("total_bytes", total_bytes);
            if(media_type == null) throw new ArgumentNullException("media_type");
            parameters.Add("media_type", media_type);
            if(additional_owners != null) parameters.Add("additional_owners", additional_owners);
            if(media_category != null) parameters.Add("media_category", media_category);
            if(shared != null) parameters.Add("shared", shared);
            return this.UploadInitCommandImpl(parameters, "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Initialize an upload.</para>
        /// </summary>
        /// <param name="total_bytes">required.</param>
        /// <param name="media_type">any one is required.</param>
        /// <param name="additional_owners">optional.</param>
        /// <param name="media_category">optional.</param>
        /// <param name="shared">optional.</param>
        /// <returns>The result of INIT command.</returns>
        public UploadInitCommandResult UploadInitCommand(int total_bytes, UploadMediaType media_type, IEnumerable<long> additional_owners = null, string media_category = null, bool? shared = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("total_bytes", total_bytes);
            parameters.Add("media_type", media_type);
            if(additional_owners != null) parameters.Add("additional_owners", additional_owners);
            if(media_category != null) parameters.Add("media_category", media_category);
            if(shared != null) parameters.Add("shared", shared);
            return this.UploadInitCommandImpl(parameters, "1.1", null);
        }
        #endif

        /// <summary>
        /// <para>Initialize an upload.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> total_bytes (required)</para>
        /// <para>- <c>string</c> media_type (any one is required)</para>
        /// <para>- <c>UploadMediaType</c> media_type (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> additional_owners (optional)</para>
        /// <para>- <c>string</c> media_category (optional)</para>
        /// <para>- <c>bool</c> shared (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The result of INIT command.</returns>
        public Task<UploadInitCommandResult> UploadInitCommandAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.UploadInitCommandAsyncImpl(InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, "1.1", null);
        }

        /// <summary>
        /// <para>Initialize an upload.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> total_bytes (required)</para>
        /// <para>- <c>string</c> media_type (any one is required)</para>
        /// <para>- <c>UploadMediaType</c> media_type (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> additional_owners (optional)</para>
        /// <para>- <c>string</c> media_category (optional)</para>
        /// <para>- <c>bool</c> shared (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The result of INIT command.</returns>
        public Task<UploadInitCommandResult> UploadInitCommandAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.UploadInitCommandAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Initialize an upload.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> total_bytes (required)</para>
        /// <para>- <c>string</c> media_type (any one is required)</para>
        /// <para>- <c>UploadMediaType</c> media_type (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> additional_owners (optional)</para>
        /// <para>- <c>string</c> media_category (optional)</para>
        /// <para>- <c>bool</c> shared (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The result of INIT command.</returns>
        public Task<UploadInitCommandResult> UploadInitCommandAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.UploadInitCommandAsyncImpl(InternalUtils.ResolveObject(parameters), cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Initialize an upload.</para>
        /// </summary>
        /// <param name="total_bytes">required.</param>
        /// <param name="media_type">any one is required.</param>
        /// <param name="additional_owners">optional.</param>
        /// <param name="media_category">optional.</param>
        /// <param name="shared">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The result of INIT command.</returns>
        public Task<UploadInitCommandResult> UploadInitCommandAsync(int total_bytes, string media_type, IEnumerable<long> additional_owners = null, string media_category = null, bool? shared = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("total_bytes", total_bytes);
            if(media_type == null) throw new ArgumentNullException("media_type");
            parameters.Add("media_type", media_type);
            if(additional_owners != null) parameters.Add("additional_owners", additional_owners);
            if(media_category != null) parameters.Add("media_category", media_category);
            if(shared != null) parameters.Add("shared", shared);
            return this.UploadInitCommandAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Initialize an upload.</para>
        /// </summary>
        /// <param name="total_bytes">required.</param>
        /// <param name="media_type">any one is required.</param>
        /// <param name="additional_owners">optional.</param>
        /// <param name="media_category">optional.</param>
        /// <param name="shared">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The result of INIT command.</returns>
        public Task<UploadInitCommandResult> UploadInitCommandAsync(int total_bytes, UploadMediaType media_type, IEnumerable<long> additional_owners = null, string media_category = null, bool? shared = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("total_bytes", total_bytes);
            parameters.Add("media_type", media_type);
            if(additional_owners != null) parameters.Add("additional_owners", additional_owners);
            if(media_category != null) parameters.Add("media_category", media_category);
            if(shared != null) parameters.Add("shared", shared);
            return this.UploadInitCommandAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Upload(s) of chunked data.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> media_id (required)</para>
        /// <para>- <c>int</c> segment_index (required)</para>
        /// <para>- <c>Stream</c> media (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> media (any one is required)</para>
        /// <para>- <c>FileInfo</c> media (any one is required)</para>
        /// <para>- <c>string</c> media_data (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void UploadAppendCommand(params Expression<Func<string, object>>[] parameters)
        {
            this.UploadAppendCommandImpl(InternalUtils.ExpressionsToDictionary(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Upload(s) of chunked data.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> media_id (required)</para>
        /// <para>- <c>int</c> segment_index (required)</para>
        /// <para>- <c>Stream</c> media (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> media (any one is required)</para>
        /// <para>- <c>FileInfo</c> media (any one is required)</para>
        /// <para>- <c>string</c> media_data (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void UploadAppendCommand(IDictionary<string, object> parameters)
        {
            this.UploadAppendCommandImpl(parameters, "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Upload(s) of chunked data.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> media_id (required)</para>
        /// <para>- <c>int</c> segment_index (required)</para>
        /// <para>- <c>Stream</c> media (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> media (any one is required)</para>
        /// <para>- <c>FileInfo</c> media (any one is required)</para>
        /// <para>- <c>string</c> media_data (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void UploadAppendCommand(object parameters)
        {
            this.UploadAppendCommandImpl(InternalUtils.ResolveObject(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Upload(s) of chunked data.</para>
        /// </summary>
        /// <param name="media_id">required.</param>
        /// <param name="segment_index">required.</param>
        /// <param name="media">any one is required.</param>
        /// <returns></returns>
        public void UploadAppendCommand(long media_id, int segment_index, Stream media)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("media_id", media_id);
            parameters.Add("segment_index", segment_index);
            if(media == null) throw new ArgumentNullException("media");
            parameters.Add("media", media);
            this.UploadAppendCommandImpl(parameters, "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Upload(s) of chunked data.</para>
        /// </summary>
        /// <param name="media_id">required.</param>
        /// <param name="segment_index">required.</param>
        /// <param name="media">any one is required.</param>
        /// <returns></returns>
        public void UploadAppendCommand(long media_id, int segment_index, IEnumerable<byte> media)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("media_id", media_id);
            parameters.Add("segment_index", segment_index);
            if(media == null) throw new ArgumentNullException("media");
            parameters.Add("media", media);
            this.UploadAppendCommandImpl(parameters, "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Upload(s) of chunked data.</para>
        /// </summary>
        /// <param name="media_id">required.</param>
        /// <param name="segment_index">required.</param>
        /// <param name="media">any one is required.</param>
        /// <returns></returns>
        public void UploadAppendCommand(long media_id, int segment_index, FileInfo media)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("media_id", media_id);
            parameters.Add("segment_index", segment_index);
            if(media == null) throw new ArgumentNullException("media");
            parameters.Add("media", media);
            this.UploadAppendCommandImpl(parameters, "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Upload(s) of chunked data.</para>
        /// </summary>
        /// <param name="media_id">required.</param>
        /// <param name="segment_index">required.</param>
        /// <param name="media_data">any one is required.</param>
        /// <returns></returns>
        public void UploadAppendCommand(long media_id, int segment_index, string media_data)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("media_id", media_id);
            parameters.Add("segment_index", segment_index);
            if(media_data == null) throw new ArgumentNullException("media_data");
            parameters.Add("media_data", media_data);
            this.UploadAppendCommandImpl(parameters, "1.1", null);
        }
        #endif

        /// <summary>
        /// <para>Upload(s) of chunked data.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> media_id (required)</para>
        /// <para>- <c>int</c> segment_index (required)</para>
        /// <para>- <c>Stream</c> media (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> media (any one is required)</para>
        /// <para>- <c>FileInfo</c> media (any one is required)</para>
        /// <para>- <c>string</c> media_data (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public Task UploadAppendCommandAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.UploadAppendCommandAsyncImpl(InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, "1.1", null);
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Complete the upload.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> media_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The result for the uploaded media.</returns>
        public UploadFinalizeCommandResult UploadFinalizeCommand(params Expression<Func<string, object>>[] parameters)
        {
            return this.UploadFinalizeCommandImpl(InternalUtils.ExpressionsToDictionary(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Complete the upload.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> media_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The result for the uploaded media.</returns>
        public UploadFinalizeCommandResult UploadFinalizeCommand(IDictionary<string, object> parameters)
        {
            return this.UploadFinalizeCommandImpl(parameters, "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Complete the upload.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> media_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The result for the uploaded media.</returns>
        public UploadFinalizeCommandResult UploadFinalizeCommand(object parameters)
        {
            return this.UploadFinalizeCommandImpl(InternalUtils.ResolveObject(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Complete the upload.</para>
        /// </summary>
        /// <param name="media_id">required.</param>
        /// <returns>The result for the uploaded media.</returns>
        public UploadFinalizeCommandResult UploadFinalizeCommand(long media_id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("media_id", media_id);
            return this.UploadFinalizeCommandImpl(parameters, "1.1", null);
        }
        #endif

        /// <summary>
        /// <para>Complete the upload.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> media_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The result for the uploaded media.</returns>
        public Task<UploadFinalizeCommandResult> UploadFinalizeCommandAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.UploadFinalizeCommandAsyncImpl(InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, "1.1", null);
        }

        /// <summary>
        /// <para>Complete the upload.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> media_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The result for the uploaded media.</returns>
        public Task<UploadFinalizeCommandResult> UploadFinalizeCommandAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.UploadFinalizeCommandAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Complete the upload.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> media_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The result for the uploaded media.</returns>
        public Task<UploadFinalizeCommandResult> UploadFinalizeCommandAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.UploadFinalizeCommandAsyncImpl(InternalUtils.ResolveObject(parameters), cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Complete the upload.</para>
        /// </summary>
        /// <param name="media_id">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The result for the uploaded media.</returns>
        public Task<UploadFinalizeCommandResult> UploadFinalizeCommandAsync(long media_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("media_id", media_id);
            return this.UploadFinalizeCommandAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Check the processing status of the upload (for async video uploads only).</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> media_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The status of the upload.</returns>
        public UploadFinalizeCommandResult UploadStatusCommand(params Expression<Func<string, object>>[] parameters)
        {
            return this.UploadStatusCommandImpl(InternalUtils.ExpressionsToDictionary(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Check the processing status of the upload (for async video uploads only).</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> media_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The status of the upload.</returns>
        public UploadFinalizeCommandResult UploadStatusCommand(IDictionary<string, object> parameters)
        {
            return this.UploadStatusCommandImpl(parameters, "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Check the processing status of the upload (for async video uploads only).</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> media_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The status of the upload.</returns>
        public UploadFinalizeCommandResult UploadStatusCommand(object parameters)
        {
            return this.UploadStatusCommandImpl(InternalUtils.ResolveObject(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Check the processing status of the upload (for async video uploads only).</para>
        /// </summary>
        /// <param name="media_id">required.</param>
        /// <returns>The status of the upload.</returns>
        public UploadFinalizeCommandResult UploadStatusCommand(long media_id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("media_id", media_id);
            return this.UploadStatusCommandImpl(parameters, "1.1", null);
        }
        #endif

        /// <summary>
        /// <para>Check the processing status of the upload (for async video uploads only).</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> media_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The status of the upload.</returns>
        public Task<UploadFinalizeCommandResult> UploadStatusCommandAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.UploadStatusCommandAsyncImpl(InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, "1.1", null);
        }

        /// <summary>
        /// <para>Check the processing status of the upload (for async video uploads only).</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> media_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The status of the upload.</returns>
        public Task<UploadFinalizeCommandResult> UploadStatusCommandAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.UploadStatusCommandAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Check the processing status of the upload (for async video uploads only).</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> media_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The status of the upload.</returns>
        public Task<UploadFinalizeCommandResult> UploadStatusCommandAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.UploadStatusCommandAsyncImpl(InternalUtils.ResolveObject(parameters), cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Check the processing status of the upload (for async video uploads only).</para>
        /// </summary>
        /// <param name="media_id">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The status of the upload.</returns>
        public Task<UploadFinalizeCommandResult> UploadStatusCommandAsync(long media_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("media_id", media_id);
            return this.UploadStatusCommandAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of POST media/metadata.
    /// </summary>
    public partial class MediaMetadata : ApiProviderBase
    {
        internal MediaMetadata(TokensBase e) : base(e) { }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Provides additional information about the uploaded media_id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> media_id (required)</para>
        /// <para>- <c>string</c> alt_text (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void Create(params Expression<Func<string, object>>[] parameters)
        {
            var jm = new string[5];
            jm[0] = "{";
            jm[1] = "\"media_id\": $media_id,";
            jm[2] = "\"alt_text\": {";
            jm[3] = "\"text\": $alt_text";
            jm[4] = "}}";
            this.CreateImpl(InternalUtils.ExpressionsToDictionary(parameters), jm, "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Provides additional information about the uploaded media_id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> media_id (required)</para>
        /// <para>- <c>string</c> alt_text (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void Create(IDictionary<string, object> parameters)
        {
            var jm = new string[5];
            jm[0] = "{";
            jm[1] = "\"media_id\": $media_id,";
            jm[2] = "\"alt_text\": {";
            jm[3] = "\"text\": $alt_text";
            jm[4] = "}}";
            this.CreateImpl(parameters, jm, "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Provides additional information about the uploaded media_id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> media_id (required)</para>
        /// <para>- <c>string</c> alt_text (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void Create(object parameters)
        {
            var jm = new string[5];
            jm[0] = "{";
            jm[1] = "\"media_id\": $media_id,";
            jm[2] = "\"alt_text\": {";
            jm[3] = "\"text\": $alt_text";
            jm[4] = "}}";
            this.CreateImpl(InternalUtils.ResolveObject(parameters), jm, "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Provides additional information about the uploaded media_id.</para>
        /// </summary>
        /// <param name="media_id">required.</param>
        /// <param name="alt_text">required.</param>
        /// <returns></returns>
        public void Create(string media_id, string alt_text)
        {
            var jm = new string[5];
            jm[0] = "{";
            jm[1] = "\"media_id\": $media_id,";
            jm[2] = "\"alt_text\": {";
            jm[3] = "\"text\": $alt_text";
            jm[4] = "}}";
            var parameters = new Dictionary<string, object>();
            if(media_id == null) throw new ArgumentNullException("media_id");
            parameters.Add("media_id", media_id);
            if(alt_text == null) throw new ArgumentNullException("alt_text");
            parameters.Add("alt_text", alt_text);
            this.CreateImpl(parameters, jm, "1.1", null);
        }
        #endif

        /// <summary>
        /// <para>Provides additional information about the uploaded media_id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> media_id (required)</para>
        /// <para>- <c>string</c> alt_text (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public Task CreateAsync(params Expression<Func<string, object>>[] parameters)
        {
            var jm = new string[5];
            jm[0] = "{";
            jm[1] = "\"media_id\": $media_id,";
            jm[2] = "\"alt_text\": {";
            jm[3] = "\"text\": $alt_text";
            jm[4] = "}}";
            return this.CreateAsyncImpl(InternalUtils.ExpressionsToDictionary(parameters), jm, CancellationToken.None, "1.1", null);
        }

        /// <summary>
        /// <para>Provides additional information about the uploaded media_id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> media_id (required)</para>
        /// <para>- <c>string</c> alt_text (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task CreateAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            var jm = new string[5];
            jm[0] = "{";
            jm[1] = "\"media_id\": $media_id,";
            jm[2] = "\"alt_text\": {";
            jm[3] = "\"text\": $alt_text";
            jm[4] = "}}";
            return this.CreateAsyncImpl(parameters, jm, cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Provides additional information about the uploaded media_id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> media_id (required)</para>
        /// <para>- <c>string</c> alt_text (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task CreateAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            var jm = new string[5];
            jm[0] = "{";
            jm[1] = "\"media_id\": $media_id,";
            jm[2] = "\"alt_text\": {";
            jm[3] = "\"text\": $alt_text";
            jm[4] = "}}";
            return this.CreateAsyncImpl(InternalUtils.ResolveObject(parameters), jm, cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Provides additional information about the uploaded media_id.</para>
        /// </summary>
        /// <param name="media_id">required.</param>
        /// <param name="alt_text">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task CreateAsync(string media_id, string alt_text, CancellationToken cancellationToken = default(CancellationToken))
        {
            var jm = new string[5];
            jm[0] = "{";
            jm[1] = "\"media_id\": $media_id,";
            jm[2] = "\"alt_text\": {";
            jm[3] = "\"text\": $alt_text";
            jm[4] = "}}";
            var parameters = new Dictionary<string, object>();
            if(media_id == null) throw new ArgumentNullException("media_id");
            parameters.Add("media_id", media_id);
            if(alt_text == null) throw new ArgumentNullException("alt_text");
            parameters.Add("alt_text", alt_text);
            return this.CreateAsyncImpl(parameters, jm, cancellationToken, "1.1", null);
        }

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET/POST mutes/users.
    /// </summary>
    public partial class MutesUsers : ApiProviderBase
    {
        internal MutesUsers(TokensBase e) : base(e) { }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<long> Ids(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "mutes/users/ids", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<long> Ids(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "mutes/users/ids", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<long> Ids(object parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "mutes/users/ids", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user has muted.</para>
        /// </summary>
        /// <param name="cursor">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<long> EnumerateIds(EnumerateMode mode, long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            return Cursored.Enumerate<long>(this.Tokens, "mutes/users/ids", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user has muted.</para>
        /// </summary>
        /// <param name="cursor">optional.</param>
        /// <returns>The users.</returns>
        public Cursored<long> Ids(long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "mutes/users/ids", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<long> EnumerateIds(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored.Enumerate<long>(this.Tokens, "mutes/users/ids", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<long> EnumerateIds(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored.Enumerate<long>(this.Tokens, "mutes/users/ids", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<long> EnumerateIds(EnumerateMode mode, object parameters)
        {
            return Cursored.Enumerate<long>(this.Tokens, "mutes/users/ids", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<long>> IdsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "mutes/users/ids", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<long>> IdsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "mutes/users/ids", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<long>> IdsAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "mutes/users/ids", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user has muted.</para>
        /// </summary>
        /// <param name="cursor">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<long>> IdsAsync(long? cursor = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "mutes/users/ids", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns an array of user objects the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "mutes/users/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns an array of user objects the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "mutes/users/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns an array of user objects the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(object parameters)
        {
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "mutes/users/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns an array of user objects the authenticating user has muted.</para>
        /// </summary>
        /// <param name="cursor">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, long? cursor = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return Cursored.Enumerate<User>(this.Tokens, "mutes/users/list", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns an array of user objects the authenticating user has muted.</para>
        /// </summary>
        /// <param name="cursor">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(long? cursor = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "mutes/users/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns an array of user objects the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored.Enumerate<User>(this.Tokens, "mutes/users/list", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns an array of user objects the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored.Enumerate<User>(this.Tokens, "mutes/users/list", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns an array of user objects the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, object parameters)
        {
            return Cursored.Enumerate<User>(this.Tokens, "mutes/users/list", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns an array of user objects the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "mutes/users/list", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns an array of user objects the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "mutes/users/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns an array of user objects the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "mutes/users/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns an array of user objects the authenticating user has muted.</para>
        /// </summary>
        /// <param name="cursor">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(long? cursor = null, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "mutes/users/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Mutes the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The muted user.</returns>
        public UserResponse Create(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "mutes/users/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Mutes the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The muted user.</returns>
        public UserResponse Create(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "mutes/users/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Mutes the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The muted user.</returns>
        public UserResponse Create(object parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "mutes/users/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Mutes the user specified in the ID parameter for the authenticating user.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The muted user.</returns>
        public UserResponse Create(string screen_name, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "mutes/users/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Mutes the user specified in the ID parameter for the authenticating user.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The muted user.</returns>
        public UserResponse Create(long user_id, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "mutes/users/create", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Mutes the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The muted user.</returns>
        public Task<UserResponse> CreateAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "mutes/users/create", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Mutes the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The muted user.</returns>
        public Task<UserResponse> CreateAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "mutes/users/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Mutes the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The muted user.</returns>
        public Task<UserResponse> CreateAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "mutes/users/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Mutes the user specified in the ID parameter for the authenticating user.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The muted user.</returns>
        public Task<UserResponse> CreateAsync(string screen_name, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "mutes/users/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Mutes the user specified in the ID parameter for the authenticating user.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The muted user.</returns>
        public Task<UserResponse> CreateAsync(long user_id, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "mutes/users/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Un-mutes the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The unmuted user.</returns>
        public UserResponse Destroy(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "mutes/users/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Un-mutes the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The unmuted user.</returns>
        public UserResponse Destroy(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "mutes/users/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Un-mutes the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The unmuted user.</returns>
        public UserResponse Destroy(object parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "mutes/users/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Un-mutes the user specified in the ID parameter for the authenticating user.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The unmuted user.</returns>
        public UserResponse Destroy(string screen_name, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "mutes/users/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Un-mutes the user specified in the ID parameter for the authenticating user.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The unmuted user.</returns>
        public UserResponse Destroy(long user_id, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "mutes/users/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Un-mutes the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The unmuted user.</returns>
        public Task<UserResponse> DestroyAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "mutes/users/destroy", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Un-mutes the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The unmuted user.</returns>
        public Task<UserResponse> DestroyAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "mutes/users/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Un-mutes the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The unmuted user.</returns>
        public Task<UserResponse> DestroyAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "mutes/users/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Un-mutes the user specified in the ID parameter for the authenticating user.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The unmuted user.</returns>
        public Task<UserResponse> DestroyAsync(string screen_name, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "mutes/users/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Un-mutes the user specified in the ID parameter for the authenticating user.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The unmuted user.</returns>
        public Task<UserResponse> DestroyAsync(long user_id, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "mutes/users/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET/POST saved_searches.
    /// </summary>
    public partial class SavedSearches : ApiProviderBase
    {
        internal SavedSearches(TokensBase e) : base(e) { }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the authenticated user’s saved search queries.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The saved searches.</returns>
        public ListedResponse<SearchQuery> List(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<SearchQuery>(MethodType.Get, "saved_searches/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the authenticated user’s saved search queries.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The saved searches.</returns>
        public ListedResponse<SearchQuery> List(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<SearchQuery>(MethodType.Get, "saved_searches/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the authenticated user’s saved search queries.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The saved searches.</returns>
        public ListedResponse<SearchQuery> List(object parameters)
        {
            return this.Tokens.AccessApiArray<SearchQuery>(MethodType.Get, "saved_searches/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the authenticated user’s saved search queries.</para>
        /// </summary>
        /// <returns>The saved searches.</returns>
        public ListedResponse<SearchQuery> List()
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiArray<SearchQuery>(MethodType.Get, "saved_searches/list", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns the authenticated user’s saved search queries.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The saved searches.</returns>
        public Task<ListedResponse<SearchQuery>> ListAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<SearchQuery>(MethodType.Get, "saved_searches/list", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the authenticated user’s saved search queries.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The saved searches.</returns>
        public Task<ListedResponse<SearchQuery>> ListAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<SearchQuery>(MethodType.Get, "saved_searches/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the authenticated user’s saved search queries.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The saved searches.</returns>
        public Task<ListedResponse<SearchQuery>> ListAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<SearchQuery>(MethodType.Get, "saved_searches/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the authenticated user’s saved search queries.</para>
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The saved searches.</returns>
        public Task<ListedResponse<SearchQuery>> ListAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiArrayAsync<SearchQuery>(MethodType.Get, "saved_searches/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Retrieve the information for the saved search represented by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The saved search.</returns>
        public SearchQueryResponse Show(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApi<SearchQueryResponse>(MethodType.Get, "saved_searches/show/{id}", new [] { "id" }, InternalUtils.ExpressionsToDictionary(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Retrieve the information for the saved search represented by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The saved search.</returns>
        public SearchQueryResponse Show(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessParameterReservedApi<SearchQueryResponse>(MethodType.Get, "saved_searches/show/{id}", new [] { "id" }, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Retrieve the information for the saved search represented by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The saved search.</returns>
        public SearchQueryResponse Show(object parameters)
        {
            return this.Tokens.AccessParameterReservedApi<SearchQueryResponse>(MethodType.Get, "saved_searches/show/{id}", new [] { "id" }, InternalUtils.ResolveObject(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Retrieve the information for the saved search represented by the given id.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <returns>The saved search.</returns>
        public SearchQueryResponse Show(long id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            return this.Tokens.AccessParameterReservedApi<SearchQueryResponse>(MethodType.Get, "saved_searches/show/{id}", new [] { "id" }, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Retrieve the information for the saved search represented by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The saved search.</returns>
        public Task<SearchQueryResponse> ShowAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiAsync<SearchQueryResponse>(MethodType.Get, "saved_searches/show/{id}", new [] { "id" }, InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Retrieve the information for the saved search represented by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The saved search.</returns>
        public Task<SearchQueryResponse> ShowAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<SearchQueryResponse>(MethodType.Get, "saved_searches/show/{id}", new [] { "id" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Retrieve the information for the saved search represented by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The saved search.</returns>
        public Task<SearchQueryResponse> ShowAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<SearchQueryResponse>(MethodType.Get, "saved_searches/show/{id}", new [] { "id" }, InternalUtils.ResolveObject(parameters), cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Retrieve the information for the saved search represented by the given id.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The saved search.</returns>
        public Task<SearchQueryResponse> ShowAsync(long id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            return this.Tokens.AccessParameterReservedApiAsync<SearchQueryResponse>(MethodType.Get, "saved_searches/show/{id}", new [] { "id" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Create a new saved search for the authenticated user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> query (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The saved search.</returns>
        public SearchQueryResponse Create(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<SearchQueryResponse>(MethodType.Post, "saved_searches/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Create a new saved search for the authenticated user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> query (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The saved search.</returns>
        public SearchQueryResponse Create(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<SearchQueryResponse>(MethodType.Post, "saved_searches/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Create a new saved search for the authenticated user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> query (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The saved search.</returns>
        public SearchQueryResponse Create(object parameters)
        {
            return this.Tokens.AccessApi<SearchQueryResponse>(MethodType.Post, "saved_searches/create", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Create a new saved search for the authenticated user.</para>
        /// </summary>
        /// <param name="query">required.</param>
        /// <returns>The saved search.</returns>
        public SearchQueryResponse Create(string query)
        {
            var parameters = new Dictionary<string, object>();
            if(query == null) throw new ArgumentNullException("query");
            parameters.Add("query", query);
            return this.Tokens.AccessApi<SearchQueryResponse>(MethodType.Post, "saved_searches/create", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Create a new saved search for the authenticated user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> query (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The saved search.</returns>
        public Task<SearchQueryResponse> CreateAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<SearchQueryResponse>(MethodType.Post, "saved_searches/create", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Create a new saved search for the authenticated user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> query (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The saved search.</returns>
        public Task<SearchQueryResponse> CreateAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<SearchQueryResponse>(MethodType.Post, "saved_searches/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Create a new saved search for the authenticated user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> query (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The saved search.</returns>
        public Task<SearchQueryResponse> CreateAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<SearchQueryResponse>(MethodType.Post, "saved_searches/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Create a new saved search for the authenticated user.</para>
        /// </summary>
        /// <param name="query">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The saved search.</returns>
        public Task<SearchQueryResponse> CreateAsync(string query, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(query == null) throw new ArgumentNullException("query");
            parameters.Add("query", query);
            return this.Tokens.AccessApiAsync<SearchQueryResponse>(MethodType.Post, "saved_searches/create", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Destroys a saved search for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The saved search.</returns>
        public SearchQueryResponse Destroy(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApi<SearchQueryResponse>(MethodType.Post, "saved_searches/destroy/{id}", new [] { "id" }, InternalUtils.ExpressionsToDictionary(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Destroys a saved search for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The saved search.</returns>
        public SearchQueryResponse Destroy(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessParameterReservedApi<SearchQueryResponse>(MethodType.Post, "saved_searches/destroy/{id}", new [] { "id" }, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Destroys a saved search for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The saved search.</returns>
        public SearchQueryResponse Destroy(object parameters)
        {
            return this.Tokens.AccessParameterReservedApi<SearchQueryResponse>(MethodType.Post, "saved_searches/destroy/{id}", new [] { "id" }, InternalUtils.ResolveObject(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Destroys a saved search for the authenticating user.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <returns>The saved search.</returns>
        public SearchQueryResponse Destroy(long id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            return this.Tokens.AccessParameterReservedApi<SearchQueryResponse>(MethodType.Post, "saved_searches/destroy/{id}", new [] { "id" }, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Destroys a saved search for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The saved search.</returns>
        public Task<SearchQueryResponse> DestroyAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiAsync<SearchQueryResponse>(MethodType.Post, "saved_searches/destroy/{id}", new [] { "id" }, InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Destroys a saved search for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The saved search.</returns>
        public Task<SearchQueryResponse> DestroyAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<SearchQueryResponse>(MethodType.Post, "saved_searches/destroy/{id}", new [] { "id" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Destroys a saved search for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The saved search.</returns>
        public Task<SearchQueryResponse> DestroyAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<SearchQueryResponse>(MethodType.Post, "saved_searches/destroy/{id}", new [] { "id" }, InternalUtils.ResolveObject(parameters), cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Destroys a saved search for the authenticating user.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The saved search.</returns>
        public Task<SearchQueryResponse> DestroyAsync(long id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            return this.Tokens.AccessParameterReservedApiAsync<SearchQueryResponse>(MethodType.Post, "saved_searches/destroy/{id}", new [] { "id" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET search.
    /// </summary>
    public partial class Search : ApiProviderBase
    {
        internal Search(TokensBase e) : base(e) { }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of relevant Tweets matching a specified query.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> q (required)</para>
        /// <para>- <c>string</c> geocode (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// <para>- <c>string</c> locale (optional)</para>
        /// <para>- <c>string</c> result_type (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> until (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public SearchResult Tweets(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<SearchResult>(MethodType.Get, "search/tweets", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of relevant Tweets matching a specified query.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> q (required)</para>
        /// <para>- <c>string</c> geocode (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// <para>- <c>string</c> locale (optional)</para>
        /// <para>- <c>string</c> result_type (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> until (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public SearchResult Tweets(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<SearchResult>(MethodType.Get, "search/tweets", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of relevant Tweets matching a specified query.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> q (required)</para>
        /// <para>- <c>string</c> geocode (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// <para>- <c>string</c> locale (optional)</para>
        /// <para>- <c>string</c> result_type (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> until (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public SearchResult Tweets(object parameters)
        {
            return this.Tokens.AccessApi<SearchResult>(MethodType.Get, "search/tweets", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of relevant Tweets matching a specified query.</para>
        /// </summary>
        /// <param name="q">required.</param>
        /// <param name="geocode">optional.</param>
        /// <param name="lang">optional.</param>
        /// <param name="locale">optional.</param>
        /// <param name="result_type">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="until">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The statuses.</returns>
        public SearchResult Tweets(string q, string geocode = null, string lang = null, string locale = null, string result_type = null, int? count = null, string until = null, long? since_id = null, long? max_id = null, bool? include_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(q == null) throw new ArgumentNullException("q");
            parameters.Add("q", q);
            if(geocode != null) parameters.Add("geocode", geocode);
            if(lang != null) parameters.Add("lang", lang);
            if(locale != null) parameters.Add("locale", locale);
            if(result_type != null) parameters.Add("result_type", result_type);
            if(count != null) parameters.Add("count", count);
            if(until != null) parameters.Add("until", until);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<SearchResult>(MethodType.Get, "search/tweets", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns a collection of relevant Tweets matching a specified query.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> q (required)</para>
        /// <para>- <c>string</c> geocode (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// <para>- <c>string</c> locale (optional)</para>
        /// <para>- <c>string</c> result_type (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> until (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public Task<SearchResult> TweetsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<SearchResult>(MethodType.Get, "search/tweets", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of relevant Tweets matching a specified query.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> q (required)</para>
        /// <para>- <c>string</c> geocode (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// <para>- <c>string</c> locale (optional)</para>
        /// <para>- <c>string</c> result_type (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> until (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<SearchResult> TweetsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<SearchResult>(MethodType.Get, "search/tweets", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of relevant Tweets matching a specified query.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> q (required)</para>
        /// <para>- <c>string</c> geocode (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// <para>- <c>string</c> locale (optional)</para>
        /// <para>- <c>string</c> result_type (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> until (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<SearchResult> TweetsAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<SearchResult>(MethodType.Get, "search/tweets", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of relevant Tweets matching a specified query.</para>
        /// </summary>
        /// <param name="q">required.</param>
        /// <param name="geocode">optional.</param>
        /// <param name="lang">optional.</param>
        /// <param name="locale">optional.</param>
        /// <param name="result_type">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="until">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<SearchResult> TweetsAsync(string q, string geocode = null, string lang = null, string locale = null, string result_type = null, int? count = null, string until = null, long? since_id = null, long? max_id = null, bool? include_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(q == null) throw new ArgumentNullException("q");
            parameters.Add("q", q);
            if(geocode != null) parameters.Add("geocode", geocode);
            if(lang != null) parameters.Add("lang", lang);
            if(locale != null) parameters.Add("locale", locale);
            if(result_type != null) parameters.Add("result_type", result_type);
            if(count != null) parameters.Add("count", count);
            if(until != null) parameters.Add("until", until);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<SearchResult>(MethodType.Get, "search/tweets", parameters, cancellationToken, urlPrefix: "1.1");
        }

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET/POST statuses.
    /// </summary>
    public partial class Statuses : ApiProviderBase
    {
        internal Statuses(TokensBase e) : base(e) { }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the most recent mentions (tweets containing a users's &#64;screen_name) for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> MentionsTimeline(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/mentions_timeline", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the most recent mentions (tweets containing a users's &#64;screen_name) for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> MentionsTimeline(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/mentions_timeline", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the most recent mentions (tweets containing a users's &#64;screen_name) for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> MentionsTimeline(object parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/mentions_timeline", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the most recent mentions (tweets containing a users's &#64;screen_name) for the authenticating user.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="contributor_details">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> MentionsTimeline(int? count = null, long? since_id = null, long? max_id = null, bool? trim_user = null, bool? contributor_details = null, bool? include_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(contributor_details != null) parameters.Add("contributor_details", contributor_details);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/mentions_timeline", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns the most recent mentions (tweets containing a users's &#64;screen_name) for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> MentionsTimelineAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/mentions_timeline", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the most recent mentions (tweets containing a users's &#64;screen_name) for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> MentionsTimelineAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/mentions_timeline", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the most recent mentions (tweets containing a users's &#64;screen_name) for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> MentionsTimelineAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/mentions_timeline", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the most recent mentions (tweets containing a users's &#64;screen_name) for the authenticating user.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="contributor_details">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> MentionsTimelineAsync(int? count = null, long? since_id = null, long? max_id = null, bool? trim_user = null, bool? contributor_details = null, bool? include_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(contributor_details != null) parameters.Add("contributor_details", contributor_details);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/mentions_timeline", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of the most recent Tweets posted by the user indicated by the screen_name or user_id parameters.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> exclude_replies (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_rts (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> UserTimeline(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/user_timeline", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of the most recent Tweets posted by the user indicated by the screen_name or user_id parameters.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> exclude_replies (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_rts (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> UserTimeline(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/user_timeline", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of the most recent Tweets posted by the user indicated by the screen_name or user_id parameters.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> exclude_replies (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_rts (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> UserTimeline(object parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/user_timeline", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of the most recent Tweets posted by the user indicated by the screen_name or user_id parameters.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="exclude_replies">optional.</param>
        /// <param name="contributor_details">optional.</param>
        /// <param name="include_rts">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> UserTimeline(int? count = null, long? since_id = null, long? max_id = null, bool? trim_user = null, bool? exclude_replies = null, bool? contributor_details = null, bool? include_rts = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(exclude_replies != null) parameters.Add("exclude_replies", exclude_replies);
            if(contributor_details != null) parameters.Add("contributor_details", contributor_details);
            if(include_rts != null) parameters.Add("include_rts", include_rts);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/user_timeline", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of the most recent Tweets posted by the user indicated by the screen_name or user_id parameters.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="exclude_replies">optional.</param>
        /// <param name="contributor_details">optional.</param>
        /// <param name="include_rts">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> UserTimeline(long user_id, int? count = null, long? since_id = null, long? max_id = null, bool? trim_user = null, bool? exclude_replies = null, bool? contributor_details = null, bool? include_rts = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(count != null) parameters.Add("count", count);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(exclude_replies != null) parameters.Add("exclude_replies", exclude_replies);
            if(contributor_details != null) parameters.Add("contributor_details", contributor_details);
            if(include_rts != null) parameters.Add("include_rts", include_rts);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/user_timeline", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of the most recent Tweets posted by the user indicated by the screen_name or user_id parameters.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="exclude_replies">optional.</param>
        /// <param name="contributor_details">optional.</param>
        /// <param name="include_rts">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> UserTimeline(string screen_name, int? count = null, long? since_id = null, long? max_id = null, bool? trim_user = null, bool? exclude_replies = null, bool? contributor_details = null, bool? include_rts = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(count != null) parameters.Add("count", count);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(exclude_replies != null) parameters.Add("exclude_replies", exclude_replies);
            if(contributor_details != null) parameters.Add("contributor_details", contributor_details);
            if(include_rts != null) parameters.Add("include_rts", include_rts);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/user_timeline", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns a collection of the most recent Tweets posted by the user indicated by the screen_name or user_id parameters.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> exclude_replies (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_rts (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> UserTimelineAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/user_timeline", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of the most recent Tweets posted by the user indicated by the screen_name or user_id parameters.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> exclude_replies (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_rts (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> UserTimelineAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/user_timeline", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of the most recent Tweets posted by the user indicated by the screen_name or user_id parameters.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> exclude_replies (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_rts (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> UserTimelineAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/user_timeline", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of the most recent Tweets posted by the user indicated by the screen_name or user_id parameters.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="exclude_replies">optional.</param>
        /// <param name="contributor_details">optional.</param>
        /// <param name="include_rts">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> UserTimelineAsync(int? count = null, long? since_id = null, long? max_id = null, bool? trim_user = null, bool? exclude_replies = null, bool? contributor_details = null, bool? include_rts = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(exclude_replies != null) parameters.Add("exclude_replies", exclude_replies);
            if(contributor_details != null) parameters.Add("contributor_details", contributor_details);
            if(include_rts != null) parameters.Add("include_rts", include_rts);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/user_timeline", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of the most recent Tweets posted by the user indicated by the screen_name or user_id parameters.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="exclude_replies">optional.</param>
        /// <param name="contributor_details">optional.</param>
        /// <param name="include_rts">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> UserTimelineAsync(long user_id, int? count = null, long? since_id = null, long? max_id = null, bool? trim_user = null, bool? exclude_replies = null, bool? contributor_details = null, bool? include_rts = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(count != null) parameters.Add("count", count);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(exclude_replies != null) parameters.Add("exclude_replies", exclude_replies);
            if(contributor_details != null) parameters.Add("contributor_details", contributor_details);
            if(include_rts != null) parameters.Add("include_rts", include_rts);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/user_timeline", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of the most recent Tweets posted by the user indicated by the screen_name or user_id parameters.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="exclude_replies">optional.</param>
        /// <param name="contributor_details">optional.</param>
        /// <param name="include_rts">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> UserTimelineAsync(string screen_name, int? count = null, long? since_id = null, long? max_id = null, bool? trim_user = null, bool? exclude_replies = null, bool? contributor_details = null, bool? include_rts = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(count != null) parameters.Add("count", count);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(exclude_replies != null) parameters.Add("exclude_replies", exclude_replies);
            if(contributor_details != null) parameters.Add("contributor_details", contributor_details);
            if(include_rts != null) parameters.Add("include_rts", include_rts);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/user_timeline", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of the most recent Tweets and retweets posted by the authenticating user and the users they follow.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> exclude_replies (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> HomeTimeline(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/home_timeline", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of the most recent Tweets and retweets posted by the authenticating user and the users they follow.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> exclude_replies (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> HomeTimeline(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/home_timeline", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of the most recent Tweets and retweets posted by the authenticating user and the users they follow.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> exclude_replies (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> HomeTimeline(object parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/home_timeline", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of the most recent Tweets and retweets posted by the authenticating user and the users they follow.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="exclude_replies">optional.</param>
        /// <param name="contributor_details">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> HomeTimeline(int? count = null, long? since_id = null, long? max_id = null, bool? trim_user = null, bool? exclude_replies = null, bool? contributor_details = null, bool? include_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(exclude_replies != null) parameters.Add("exclude_replies", exclude_replies);
            if(contributor_details != null) parameters.Add("contributor_details", contributor_details);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/home_timeline", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns a collection of the most recent Tweets and retweets posted by the authenticating user and the users they follow.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> exclude_replies (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> HomeTimelineAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/home_timeline", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of the most recent Tweets and retweets posted by the authenticating user and the users they follow.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> exclude_replies (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> HomeTimelineAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/home_timeline", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of the most recent Tweets and retweets posted by the authenticating user and the users they follow.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> exclude_replies (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> HomeTimelineAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/home_timeline", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of the most recent Tweets and retweets posted by the authenticating user and the users they follow.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="exclude_replies">optional.</param>
        /// <param name="contributor_details">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> HomeTimelineAsync(int? count = null, long? since_id = null, long? max_id = null, bool? trim_user = null, bool? exclude_replies = null, bool? contributor_details = null, bool? include_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(exclude_replies != null) parameters.Add("exclude_replies", exclude_replies);
            if(contributor_details != null) parameters.Add("contributor_details", contributor_details);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/home_timeline", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the most recent tweets authored by the authenticating user that have recently been retweeted by others.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_user_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> RetweetsOfMe(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/retweets_of_me", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the most recent tweets authored by the authenticating user that have recently been retweeted by others.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_user_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> RetweetsOfMe(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/retweets_of_me", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the most recent tweets authored by the authenticating user that have recently been retweeted by others.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_user_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> RetweetsOfMe(object parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/retweets_of_me", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the most recent tweets authored by the authenticating user that have recently been retweeted by others.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_user_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> RetweetsOfMe(int? count = null, long? since_id = null, long? max_id = null, bool? trim_user = null, bool? include_entities = null, bool? include_user_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_user_entities != null) parameters.Add("include_user_entities", include_user_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/retweets_of_me", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns the most recent tweets authored by the authenticating user that have recently been retweeted by others.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_user_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> RetweetsOfMeAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/retweets_of_me", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the most recent tweets authored by the authenticating user that have recently been retweeted by others.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_user_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> RetweetsOfMeAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/retweets_of_me", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the most recent tweets authored by the authenticating user that have recently been retweeted by others.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_user_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> RetweetsOfMeAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/retweets_of_me", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the most recent tweets authored by the authenticating user that have recently been retweeted by others.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_user_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> RetweetsOfMeAsync(int? count = null, long? since_id = null, long? max_id = null, bool? trim_user = null, bool? include_entities = null, bool? include_user_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_user_entities != null) parameters.Add("include_user_entities", include_user_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/retweets_of_me", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns information allowing the creation of an embedded representation of a Tweet on third party sites.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (any one is required)</para>
        /// <para>- <c>string</c> url (any one is required)</para>
        /// <para>- <c>int</c> maxwidth (optional)</para>
        /// <para>- <c>bool</c> hide_media (optional)</para>
        /// <para>- <c>bool</c> hide_thread (optional)</para>
        /// <para>- <c>bool</c> omit_script (optional)</para>
        /// <para>- <c>string</c> align (optional)</para>
        /// <para>- <c>string</c> related (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// <para>- <c>string</c> widget_type (optional)</para>
        /// <para>- <c>bool</c> hide_tweet (optional)</para>
        /// <para>- <c>string</c> theme (optional)</para>
        /// <para>- <c>string</c> link_color (optional)</para>
        /// <para>- <c>bool</c> dnt (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The HTML code and more.</returns>
        public Embed Oembed(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Embed>(MethodType.Get, "statuses/oembed", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns information allowing the creation of an embedded representation of a Tweet on third party sites.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (any one is required)</para>
        /// <para>- <c>string</c> url (any one is required)</para>
        /// <para>- <c>int</c> maxwidth (optional)</para>
        /// <para>- <c>bool</c> hide_media (optional)</para>
        /// <para>- <c>bool</c> hide_thread (optional)</para>
        /// <para>- <c>bool</c> omit_script (optional)</para>
        /// <para>- <c>string</c> align (optional)</para>
        /// <para>- <c>string</c> related (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// <para>- <c>string</c> widget_type (optional)</para>
        /// <para>- <c>bool</c> hide_tweet (optional)</para>
        /// <para>- <c>string</c> theme (optional)</para>
        /// <para>- <c>string</c> link_color (optional)</para>
        /// <para>- <c>bool</c> dnt (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The HTML code and more.</returns>
        public Embed Oembed(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Embed>(MethodType.Get, "statuses/oembed", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns information allowing the creation of an embedded representation of a Tweet on third party sites.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (any one is required)</para>
        /// <para>- <c>string</c> url (any one is required)</para>
        /// <para>- <c>int</c> maxwidth (optional)</para>
        /// <para>- <c>bool</c> hide_media (optional)</para>
        /// <para>- <c>bool</c> hide_thread (optional)</para>
        /// <para>- <c>bool</c> omit_script (optional)</para>
        /// <para>- <c>string</c> align (optional)</para>
        /// <para>- <c>string</c> related (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// <para>- <c>string</c> widget_type (optional)</para>
        /// <para>- <c>bool</c> hide_tweet (optional)</para>
        /// <para>- <c>string</c> theme (optional)</para>
        /// <para>- <c>string</c> link_color (optional)</para>
        /// <para>- <c>bool</c> dnt (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The HTML code and more.</returns>
        public Embed Oembed(object parameters)
        {
            return this.Tokens.AccessApi<Embed>(MethodType.Get, "statuses/oembed", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns information allowing the creation of an embedded representation of a Tweet on third party sites.</para>
        /// </summary>
        /// <param name="id">any one is required.</param>
        /// <param name="maxwidth">optional.</param>
        /// <param name="hide_media">optional.</param>
        /// <param name="hide_thread">optional.</param>
        /// <param name="omit_script">optional.</param>
        /// <param name="align">optional.</param>
        /// <param name="related">optional.</param>
        /// <param name="lang">optional.</param>
        /// <param name="widget_type">optional.</param>
        /// <param name="hide_tweet">optional.</param>
        /// <param name="theme">optional.</param>
        /// <param name="link_color">optional.</param>
        /// <param name="dnt">optional.</param>
        /// <returns>The HTML code and more.</returns>
        public Embed Oembed(long id, int? maxwidth = null, bool? hide_media = null, bool? hide_thread = null, bool? omit_script = null, string align = null, string related = null, string lang = null, string widget_type = null, bool? hide_tweet = null, string theme = null, string link_color = null, bool? dnt = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(maxwidth != null) parameters.Add("maxwidth", maxwidth);
            if(hide_media != null) parameters.Add("hide_media", hide_media);
            if(hide_thread != null) parameters.Add("hide_thread", hide_thread);
            if(omit_script != null) parameters.Add("omit_script", omit_script);
            if(align != null) parameters.Add("align", align);
            if(related != null) parameters.Add("related", related);
            if(lang != null) parameters.Add("lang", lang);
            if(widget_type != null) parameters.Add("widget_type", widget_type);
            if(hide_tweet != null) parameters.Add("hide_tweet", hide_tweet);
            if(theme != null) parameters.Add("theme", theme);
            if(link_color != null) parameters.Add("link_color", link_color);
            if(dnt != null) parameters.Add("dnt", dnt);
            return this.Tokens.AccessApi<Embed>(MethodType.Get, "statuses/oembed", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns information allowing the creation of an embedded representation of a Tweet on third party sites.</para>
        /// </summary>
        /// <param name="url">any one is required.</param>
        /// <param name="maxwidth">optional.</param>
        /// <param name="hide_media">optional.</param>
        /// <param name="hide_thread">optional.</param>
        /// <param name="omit_script">optional.</param>
        /// <param name="align">optional.</param>
        /// <param name="related">optional.</param>
        /// <param name="lang">optional.</param>
        /// <param name="widget_type">optional.</param>
        /// <param name="hide_tweet">optional.</param>
        /// <param name="theme">optional.</param>
        /// <param name="link_color">optional.</param>
        /// <param name="dnt">optional.</param>
        /// <returns>The HTML code and more.</returns>
        public Embed Oembed(string url, int? maxwidth = null, bool? hide_media = null, bool? hide_thread = null, bool? omit_script = null, string align = null, string related = null, string lang = null, string widget_type = null, bool? hide_tweet = null, string theme = null, string link_color = null, bool? dnt = null)
        {
            var parameters = new Dictionary<string, object>();
            if(url == null) throw new ArgumentNullException("url");
            parameters.Add("url", url);
            if(maxwidth != null) parameters.Add("maxwidth", maxwidth);
            if(hide_media != null) parameters.Add("hide_media", hide_media);
            if(hide_thread != null) parameters.Add("hide_thread", hide_thread);
            if(omit_script != null) parameters.Add("omit_script", omit_script);
            if(align != null) parameters.Add("align", align);
            if(related != null) parameters.Add("related", related);
            if(lang != null) parameters.Add("lang", lang);
            if(widget_type != null) parameters.Add("widget_type", widget_type);
            if(hide_tweet != null) parameters.Add("hide_tweet", hide_tweet);
            if(theme != null) parameters.Add("theme", theme);
            if(link_color != null) parameters.Add("link_color", link_color);
            if(dnt != null) parameters.Add("dnt", dnt);
            return this.Tokens.AccessApi<Embed>(MethodType.Get, "statuses/oembed", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns information allowing the creation of an embedded representation of a Tweet on third party sites.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (any one is required)</para>
        /// <para>- <c>string</c> url (any one is required)</para>
        /// <para>- <c>int</c> maxwidth (optional)</para>
        /// <para>- <c>bool</c> hide_media (optional)</para>
        /// <para>- <c>bool</c> hide_thread (optional)</para>
        /// <para>- <c>bool</c> omit_script (optional)</para>
        /// <para>- <c>string</c> align (optional)</para>
        /// <para>- <c>string</c> related (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// <para>- <c>string</c> widget_type (optional)</para>
        /// <para>- <c>bool</c> hide_tweet (optional)</para>
        /// <para>- <c>string</c> theme (optional)</para>
        /// <para>- <c>string</c> link_color (optional)</para>
        /// <para>- <c>bool</c> dnt (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The HTML code and more.</returns>
        public Task<Embed> OembedAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Embed>(MethodType.Get, "statuses/oembed", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns information allowing the creation of an embedded representation of a Tweet on third party sites.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (any one is required)</para>
        /// <para>- <c>string</c> url (any one is required)</para>
        /// <para>- <c>int</c> maxwidth (optional)</para>
        /// <para>- <c>bool</c> hide_media (optional)</para>
        /// <para>- <c>bool</c> hide_thread (optional)</para>
        /// <para>- <c>bool</c> omit_script (optional)</para>
        /// <para>- <c>string</c> align (optional)</para>
        /// <para>- <c>string</c> related (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// <para>- <c>string</c> widget_type (optional)</para>
        /// <para>- <c>bool</c> hide_tweet (optional)</para>
        /// <para>- <c>string</c> theme (optional)</para>
        /// <para>- <c>string</c> link_color (optional)</para>
        /// <para>- <c>bool</c> dnt (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The HTML code and more.</returns>
        public Task<Embed> OembedAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Embed>(MethodType.Get, "statuses/oembed", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns information allowing the creation of an embedded representation of a Tweet on third party sites.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (any one is required)</para>
        /// <para>- <c>string</c> url (any one is required)</para>
        /// <para>- <c>int</c> maxwidth (optional)</para>
        /// <para>- <c>bool</c> hide_media (optional)</para>
        /// <para>- <c>bool</c> hide_thread (optional)</para>
        /// <para>- <c>bool</c> omit_script (optional)</para>
        /// <para>- <c>string</c> align (optional)</para>
        /// <para>- <c>string</c> related (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// <para>- <c>string</c> widget_type (optional)</para>
        /// <para>- <c>bool</c> hide_tweet (optional)</para>
        /// <para>- <c>string</c> theme (optional)</para>
        /// <para>- <c>string</c> link_color (optional)</para>
        /// <para>- <c>bool</c> dnt (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The HTML code and more.</returns>
        public Task<Embed> OembedAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Embed>(MethodType.Get, "statuses/oembed", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns information allowing the creation of an embedded representation of a Tweet on third party sites.</para>
        /// </summary>
        /// <param name="id">any one is required.</param>
        /// <param name="maxwidth">optional.</param>
        /// <param name="hide_media">optional.</param>
        /// <param name="hide_thread">optional.</param>
        /// <param name="omit_script">optional.</param>
        /// <param name="align">optional.</param>
        /// <param name="related">optional.</param>
        /// <param name="lang">optional.</param>
        /// <param name="widget_type">optional.</param>
        /// <param name="hide_tweet">optional.</param>
        /// <param name="theme">optional.</param>
        /// <param name="link_color">optional.</param>
        /// <param name="dnt">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The HTML code and more.</returns>
        public Task<Embed> OembedAsync(long id, int? maxwidth = null, bool? hide_media = null, bool? hide_thread = null, bool? omit_script = null, string align = null, string related = null, string lang = null, string widget_type = null, bool? hide_tweet = null, string theme = null, string link_color = null, bool? dnt = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(maxwidth != null) parameters.Add("maxwidth", maxwidth);
            if(hide_media != null) parameters.Add("hide_media", hide_media);
            if(hide_thread != null) parameters.Add("hide_thread", hide_thread);
            if(omit_script != null) parameters.Add("omit_script", omit_script);
            if(align != null) parameters.Add("align", align);
            if(related != null) parameters.Add("related", related);
            if(lang != null) parameters.Add("lang", lang);
            if(widget_type != null) parameters.Add("widget_type", widget_type);
            if(hide_tweet != null) parameters.Add("hide_tweet", hide_tweet);
            if(theme != null) parameters.Add("theme", theme);
            if(link_color != null) parameters.Add("link_color", link_color);
            if(dnt != null) parameters.Add("dnt", dnt);
            return this.Tokens.AccessApiAsync<Embed>(MethodType.Get, "statuses/oembed", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns information allowing the creation of an embedded representation of a Tweet on third party sites.</para>
        /// </summary>
        /// <param name="url">any one is required.</param>
        /// <param name="maxwidth">optional.</param>
        /// <param name="hide_media">optional.</param>
        /// <param name="hide_thread">optional.</param>
        /// <param name="omit_script">optional.</param>
        /// <param name="align">optional.</param>
        /// <param name="related">optional.</param>
        /// <param name="lang">optional.</param>
        /// <param name="widget_type">optional.</param>
        /// <param name="hide_tweet">optional.</param>
        /// <param name="theme">optional.</param>
        /// <param name="link_color">optional.</param>
        /// <param name="dnt">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The HTML code and more.</returns>
        public Task<Embed> OembedAsync(string url, int? maxwidth = null, bool? hide_media = null, bool? hide_thread = null, bool? omit_script = null, string align = null, string related = null, string lang = null, string widget_type = null, bool? hide_tweet = null, string theme = null, string link_color = null, bool? dnt = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(url == null) throw new ArgumentNullException("url");
            parameters.Add("url", url);
            if(maxwidth != null) parameters.Add("maxwidth", maxwidth);
            if(hide_media != null) parameters.Add("hide_media", hide_media);
            if(hide_thread != null) parameters.Add("hide_thread", hide_thread);
            if(omit_script != null) parameters.Add("omit_script", omit_script);
            if(align != null) parameters.Add("align", align);
            if(related != null) parameters.Add("related", related);
            if(lang != null) parameters.Add("lang", lang);
            if(widget_type != null) parameters.Add("widget_type", widget_type);
            if(hide_tweet != null) parameters.Add("hide_tweet", hide_tweet);
            if(theme != null) parameters.Add("theme", theme);
            if(link_color != null) parameters.Add("link_color", link_color);
            if(dnt != null) parameters.Add("dnt", dnt);
            return this.Tokens.AccessApiAsync<Embed>(MethodType.Get, "statuses/oembed", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a single Tweet, specified by the id parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_my_retweet (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The status.</returns>
        public StatusResponse Show(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApi<StatusResponse>(MethodType.Get, "statuses/show/{id}", new [] { "id" }, InternalUtils.ExpressionsToDictionary(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a single Tweet, specified by the id parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_my_retweet (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The status.</returns>
        public StatusResponse Show(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessParameterReservedApi<StatusResponse>(MethodType.Get, "statuses/show/{id}", new [] { "id" }, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a single Tweet, specified by the id parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_my_retweet (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The status.</returns>
        public StatusResponse Show(object parameters)
        {
            return this.Tokens.AccessParameterReservedApi<StatusResponse>(MethodType.Get, "statuses/show/{id}", new [] { "id" }, InternalUtils.ResolveObject(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a single Tweet, specified by the id parameter.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="include_my_retweet">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The status.</returns>
        public StatusResponse Show(long id, bool? trim_user = null, bool? include_my_retweet = null, bool? include_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(include_my_retweet != null) parameters.Add("include_my_retweet", include_my_retweet);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessParameterReservedApi<StatusResponse>(MethodType.Get, "statuses/show/{id}", new [] { "id" }, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns a single Tweet, specified by the id parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_my_retweet (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The status.</returns>
        public Task<StatusResponse> ShowAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiAsync<StatusResponse>(MethodType.Get, "statuses/show/{id}", new [] { "id" }, InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a single Tweet, specified by the id parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_my_retweet (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The status.</returns>
        public Task<StatusResponse> ShowAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<StatusResponse>(MethodType.Get, "statuses/show/{id}", new [] { "id" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a single Tweet, specified by the id parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_my_retweet (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The status.</returns>
        public Task<StatusResponse> ShowAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<StatusResponse>(MethodType.Get, "statuses/show/{id}", new [] { "id" }, InternalUtils.ResolveObject(parameters), cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a single Tweet, specified by the id parameter.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="include_my_retweet">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The status.</returns>
        public Task<StatusResponse> ShowAsync(long id, bool? trim_user = null, bool? include_my_retweet = null, bool? include_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(include_my_retweet != null) parameters.Add("include_my_retweet", include_my_retweet);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessParameterReservedApiAsync<StatusResponse>(MethodType.Get, "statuses/show/{id}", new [] { "id" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns up to 100 of the first retweets of a given tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> Retweets(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiArray<Status>(MethodType.Get, "statuses/retweets/{id}", new [] { "id" }, InternalUtils.ExpressionsToDictionary(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns up to 100 of the first retweets of a given tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> Retweets(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessParameterReservedApiArray<Status>(MethodType.Get, "statuses/retweets/{id}", new [] { "id" }, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns up to 100 of the first retweets of a given tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> Retweets(object parameters)
        {
            return this.Tokens.AccessParameterReservedApiArray<Status>(MethodType.Get, "statuses/retweets/{id}", new [] { "id" }, InternalUtils.ResolveObject(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns up to 100 of the first retweets of a given tweet.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="count">optional.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> Retweets(long id, int? count = null, bool? trim_user = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(count != null) parameters.Add("count", count);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessParameterReservedApiArray<Status>(MethodType.Get, "statuses/retweets/{id}", new [] { "id" }, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns up to 100 of the first retweets of a given tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> RetweetsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiArrayAsync<Status>(MethodType.Get, "statuses/retweets/{id}", new [] { "id" }, InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns up to 100 of the first retweets of a given tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> RetweetsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiArrayAsync<Status>(MethodType.Get, "statuses/retweets/{id}", new [] { "id" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns up to 100 of the first retweets of a given tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> RetweetsAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiArrayAsync<Status>(MethodType.Get, "statuses/retweets/{id}", new [] { "id" }, InternalUtils.ResolveObject(parameters), cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns up to 100 of the first retweets of a given tweet.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="count">optional.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> RetweetsAsync(long id, int? count = null, bool? trim_user = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(count != null) parameters.Add("count", count);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessParameterReservedApiArrayAsync<Status>(MethodType.Get, "statuses/retweets/{id}", new [] { "id" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns fully-hydrated tweet objects for up to 100 tweets per request, as specified by comma-separated values passed to the id parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> Lookup(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/lookup", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns fully-hydrated tweet objects for up to 100 tweets per request, as specified by comma-separated values passed to the id parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> Lookup(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/lookup", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns fully-hydrated tweet objects for up to 100 tweets per request, as specified by comma-separated values passed to the id parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> Lookup(object parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/lookup", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns fully-hydrated tweet objects for up to 100 tweets per request, as specified by comma-separated values passed to the id parameter.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> Lookup(IEnumerable<long> id, bool? trim_user = null, bool? include_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/lookup", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns fully-hydrated tweet objects for up to 100 tweets per request, as specified by comma-separated values passed to the id parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> LookupAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/lookup", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns fully-hydrated tweet objects for up to 100 tweets per request, as specified by comma-separated values passed to the id parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> LookupAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/lookup", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns fully-hydrated tweet objects for up to 100 tweets per request, as specified by comma-separated values passed to the id parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> LookupAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/lookup", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns fully-hydrated tweet objects for up to 100 tweets per request, as specified by comma-separated values passed to the id parameter.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> LookupAsync(IEnumerable<long> id, bool? trim_user = null, bool? include_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/lookup", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns fully-hydrated tweet objects for up to 100 tweets per request, as specified by comma-separated values passed to the id parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public DictionaryResponse<string, Status> LookupMap(params Expression<Func<string, object>>[] parameters)
        {
            return this.LookupMapImpl(InternalUtils.ExpressionsToDictionary(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns fully-hydrated tweet objects for up to 100 tweets per request, as specified by comma-separated values passed to the id parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public DictionaryResponse<string, Status> LookupMap(IDictionary<string, object> parameters)
        {
            return this.LookupMapImpl(parameters, "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns fully-hydrated tweet objects for up to 100 tweets per request, as specified by comma-separated values passed to the id parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public DictionaryResponse<string, Status> LookupMap(object parameters)
        {
            return this.LookupMapImpl(InternalUtils.ResolveObject(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns fully-hydrated tweet objects for up to 100 tweets per request, as specified by comma-separated values passed to the id parameter.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The statuses.</returns>
        public DictionaryResponse<string, Status> LookupMap(IEnumerable<long> id, bool? trim_user = null, bool? include_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.LookupMapImpl(parameters, "1.1", null);
        }
        #endif

        /// <summary>
        /// <para>Returns fully-hydrated tweet objects for up to 100 tweets per request, as specified by comma-separated values passed to the id parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public Task<DictionaryResponse<string, Status>> LookupMapAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.LookupMapAsyncImpl(InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, "1.1", null);
        }

        /// <summary>
        /// <para>Returns fully-hydrated tweet objects for up to 100 tweets per request, as specified by comma-separated values passed to the id parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<DictionaryResponse<string, Status>> LookupMapAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.LookupMapAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Returns fully-hydrated tweet objects for up to 100 tweets per request, as specified by comma-separated values passed to the id parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<DictionaryResponse<string, Status>> LookupMapAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.LookupMapAsyncImpl(InternalUtils.ResolveObject(parameters), cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Returns fully-hydrated tweet objects for up to 100 tweets per request, as specified by comma-separated values passed to the id parameter.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<DictionaryResponse<string, Status>> LookupMapAsync(IEnumerable<long> id, bool? trim_user = null, bool? include_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.LookupMapAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        #if !NETSTANDARD1_3
        private DictionaryResponse<string, Status> LookupMapImpl(IEnumerable<KeyValuePair<string, object>> parameters, string urlPrefix, string urlSuffix)
        {
            if(parameters == null) throw new ArgumentNullException("parameters");
            return this.Tokens.AccessApiDictionaryImpl<string, Status>(MethodType.Post, "statuses/lookup",
                parameters.Concat(new[] { new KeyValuePair<string, object>("map", "true") }), "id", urlPrefix, urlSuffix);
        }
        #endif
        private Task<DictionaryResponse<string, Status>> LookupMapAsyncImpl(IEnumerable<KeyValuePair<string, object>> parameters, CancellationToken cancellationToken, string urlPrefix, string urlSuffix)
        {
            if(parameters == null) throw new ArgumentNullException("parameters");
            return this.Tokens.AccessApiDictionaryAsyncImpl<string, Status>(MethodType.Post, "statuses/lookup",
                parameters.Concat(new[] { new KeyValuePair<string, object>("map", "true") }), cancellationToken, "id", urlPrefix, urlSuffix);
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of up to 100 user IDs belonging to users who have retweeted the tweet specified by the id parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> RetweetersIds(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "statuses/retweeters/ids", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of up to 100 user IDs belonging to users who have retweeted the tweet specified by the id parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> RetweetersIds(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "statuses/retweeters/ids", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of up to 100 user IDs belonging to users who have retweeted the tweet specified by the id parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> RetweetersIds(object parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "statuses/retweeters/ids", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of up to 100 user IDs belonging to users who have retweeted the tweet specified by the id parameter.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateRetweetersIds(EnumerateMode mode, long id, long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(cursor != null) parameters.Add("cursor", cursor);
            return Cursored.Enumerate<long>(this.Tokens, "statuses/retweeters/ids", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of up to 100 user IDs belonging to users who have retweeted the tweet specified by the id parameter.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> RetweetersIds(long id, long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "statuses/retweeters/ids", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of up to 100 user IDs belonging to users who have retweeted the tweet specified by the id parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateRetweetersIds(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored.Enumerate<long>(this.Tokens, "statuses/retweeters/ids", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of up to 100 user IDs belonging to users who have retweeted the tweet specified by the id parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateRetweetersIds(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored.Enumerate<long>(this.Tokens, "statuses/retweeters/ids", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of up to 100 user IDs belonging to users who have retweeted the tweet specified by the id parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateRetweetersIds(EnumerateMode mode, object parameters)
        {
            return Cursored.Enumerate<long>(this.Tokens, "statuses/retweeters/ids", mode, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns a collection of up to 100 user IDs belonging to users who have retweeted the tweet specified by the id parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> RetweetersIdsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "statuses/retweeters/ids", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of up to 100 user IDs belonging to users who have retweeted the tweet specified by the id parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> RetweetersIdsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "statuses/retweeters/ids", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of up to 100 user IDs belonging to users who have retweeted the tweet specified by the id parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> RetweetersIdsAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "statuses/retweeters/ids", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of up to 100 user IDs belonging to users who have retweeted the tweet specified by the id parameter.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> RetweetersIdsAsync(long id, long? cursor = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "statuses/retweeters/ids", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Updates the authenticating user’s current status, also known as Tweeting.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> status (required)</para>
        /// <para>- <c>long</c> in_reply_to_status_id (optional)</para>
        /// <para>- <c>bool</c> possibly_sensitive (optional)</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> place_id (optional)</para>
        /// <para>- <c>bool</c> display_coordinates (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> media_ids (optional)</para>
        /// <para>- <c>string</c> attachment_url (optional)</para>
        /// <para>- <c>bool</c> auto_populate_reply_metadata (optional)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> exclude_reply_user_ids (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// <para>- <c>bool</c> enable_dm_commands (optional)</para>
        /// <para>- <c>bool</c> fail_dm_commands (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The updated status.</returns>
        public StatusResponse Update(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<StatusResponse>(MethodType.Post, "statuses/update", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Updates the authenticating user’s current status, also known as Tweeting.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> status (required)</para>
        /// <para>- <c>long</c> in_reply_to_status_id (optional)</para>
        /// <para>- <c>bool</c> possibly_sensitive (optional)</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> place_id (optional)</para>
        /// <para>- <c>bool</c> display_coordinates (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> media_ids (optional)</para>
        /// <para>- <c>string</c> attachment_url (optional)</para>
        /// <para>- <c>bool</c> auto_populate_reply_metadata (optional)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> exclude_reply_user_ids (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// <para>- <c>bool</c> enable_dm_commands (optional)</para>
        /// <para>- <c>bool</c> fail_dm_commands (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The updated status.</returns>
        public StatusResponse Update(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<StatusResponse>(MethodType.Post, "statuses/update", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Updates the authenticating user’s current status, also known as Tweeting.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> status (required)</para>
        /// <para>- <c>long</c> in_reply_to_status_id (optional)</para>
        /// <para>- <c>bool</c> possibly_sensitive (optional)</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> place_id (optional)</para>
        /// <para>- <c>bool</c> display_coordinates (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> media_ids (optional)</para>
        /// <para>- <c>string</c> attachment_url (optional)</para>
        /// <para>- <c>bool</c> auto_populate_reply_metadata (optional)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> exclude_reply_user_ids (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// <para>- <c>bool</c> enable_dm_commands (optional)</para>
        /// <para>- <c>bool</c> fail_dm_commands (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The updated status.</returns>
        public StatusResponse Update(object parameters)
        {
            return this.Tokens.AccessApi<StatusResponse>(MethodType.Post, "statuses/update", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Updates the authenticating user’s current status, also known as Tweeting.</para>
        /// </summary>
        /// <param name="status">required.</param>
        /// <param name="in_reply_to_status_id">optional.</param>
        /// <param name="possibly_sensitive">optional.</param>
        /// <param name="lat">optional.</param>
        /// <param name="long">optional.</param>
        /// <param name="place_id">optional.</param>
        /// <param name="display_coordinates">optional.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="media_ids">optional.</param>
        /// <param name="attachment_url">optional.</param>
        /// <param name="auto_populate_reply_metadata">optional.</param>
        /// <param name="exclude_reply_user_ids">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="enable_dm_commands">optional.</param>
        /// <param name="fail_dm_commands">optional.</param>
        /// <returns>The updated status.</returns>
        public StatusResponse Update(string status, long? in_reply_to_status_id = null, bool? possibly_sensitive = null, double? lat = null, double? @long = null, string place_id = null, bool? display_coordinates = null, bool? trim_user = null, IEnumerable<long> media_ids = null, string attachment_url = null, bool? auto_populate_reply_metadata = null, IEnumerable<long> exclude_reply_user_ids = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, bool? enable_dm_commands = null, bool? fail_dm_commands = null)
        {
            var parameters = new Dictionary<string, object>();
            if(status == null) throw new ArgumentNullException("status");
            parameters.Add("status", status);
            if(in_reply_to_status_id != null) parameters.Add("in_reply_to_status_id", in_reply_to_status_id);
            if(possibly_sensitive != null) parameters.Add("possibly_sensitive", possibly_sensitive);
            if(lat != null) parameters.Add("lat", lat);
            if(@long != null) parameters.Add("long", @long);
            if(place_id != null) parameters.Add("place_id", place_id);
            if(display_coordinates != null) parameters.Add("display_coordinates", display_coordinates);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(media_ids != null) parameters.Add("media_ids", media_ids);
            if(attachment_url != null) parameters.Add("attachment_url", attachment_url);
            if(auto_populate_reply_metadata != null) parameters.Add("auto_populate_reply_metadata", auto_populate_reply_metadata);
            if(exclude_reply_user_ids != null) parameters.Add("exclude_reply_user_ids", exclude_reply_user_ids);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            if(enable_dm_commands != null) parameters.Add("enable_dm_commands", enable_dm_commands);
            if(fail_dm_commands != null) parameters.Add("fail_dm_commands", fail_dm_commands);
            return this.Tokens.AccessApi<StatusResponse>(MethodType.Post, "statuses/update", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Updates the authenticating user’s current status, also known as Tweeting.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> status (required)</para>
        /// <para>- <c>long</c> in_reply_to_status_id (optional)</para>
        /// <para>- <c>bool</c> possibly_sensitive (optional)</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> place_id (optional)</para>
        /// <para>- <c>bool</c> display_coordinates (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> media_ids (optional)</para>
        /// <para>- <c>string</c> attachment_url (optional)</para>
        /// <para>- <c>bool</c> auto_populate_reply_metadata (optional)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> exclude_reply_user_ids (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// <para>- <c>bool</c> enable_dm_commands (optional)</para>
        /// <para>- <c>bool</c> fail_dm_commands (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The updated status.</returns>
        public Task<StatusResponse> UpdateAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<StatusResponse>(MethodType.Post, "statuses/update", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Updates the authenticating user’s current status, also known as Tweeting.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> status (required)</para>
        /// <para>- <c>long</c> in_reply_to_status_id (optional)</para>
        /// <para>- <c>bool</c> possibly_sensitive (optional)</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> place_id (optional)</para>
        /// <para>- <c>bool</c> display_coordinates (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> media_ids (optional)</para>
        /// <para>- <c>string</c> attachment_url (optional)</para>
        /// <para>- <c>bool</c> auto_populate_reply_metadata (optional)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> exclude_reply_user_ids (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// <para>- <c>bool</c> enable_dm_commands (optional)</para>
        /// <para>- <c>bool</c> fail_dm_commands (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The updated status.</returns>
        public Task<StatusResponse> UpdateAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<StatusResponse>(MethodType.Post, "statuses/update", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Updates the authenticating user’s current status, also known as Tweeting.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> status (required)</para>
        /// <para>- <c>long</c> in_reply_to_status_id (optional)</para>
        /// <para>- <c>bool</c> possibly_sensitive (optional)</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> place_id (optional)</para>
        /// <para>- <c>bool</c> display_coordinates (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> media_ids (optional)</para>
        /// <para>- <c>string</c> attachment_url (optional)</para>
        /// <para>- <c>bool</c> auto_populate_reply_metadata (optional)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> exclude_reply_user_ids (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// <para>- <c>bool</c> enable_dm_commands (optional)</para>
        /// <para>- <c>bool</c> fail_dm_commands (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The updated status.</returns>
        public Task<StatusResponse> UpdateAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<StatusResponse>(MethodType.Post, "statuses/update", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Updates the authenticating user’s current status, also known as Tweeting.</para>
        /// </summary>
        /// <param name="status">required.</param>
        /// <param name="in_reply_to_status_id">optional.</param>
        /// <param name="possibly_sensitive">optional.</param>
        /// <param name="lat">optional.</param>
        /// <param name="long">optional.</param>
        /// <param name="place_id">optional.</param>
        /// <param name="display_coordinates">optional.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="media_ids">optional.</param>
        /// <param name="attachment_url">optional.</param>
        /// <param name="auto_populate_reply_metadata">optional.</param>
        /// <param name="exclude_reply_user_ids">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="enable_dm_commands">optional.</param>
        /// <param name="fail_dm_commands">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The updated status.</returns>
        public Task<StatusResponse> UpdateAsync(string status, long? in_reply_to_status_id = null, bool? possibly_sensitive = null, double? lat = null, double? @long = null, string place_id = null, bool? display_coordinates = null, bool? trim_user = null, IEnumerable<long> media_ids = null, string attachment_url = null, bool? auto_populate_reply_metadata = null, IEnumerable<long> exclude_reply_user_ids = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, bool? enable_dm_commands = null, bool? fail_dm_commands = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(status == null) throw new ArgumentNullException("status");
            parameters.Add("status", status);
            if(in_reply_to_status_id != null) parameters.Add("in_reply_to_status_id", in_reply_to_status_id);
            if(possibly_sensitive != null) parameters.Add("possibly_sensitive", possibly_sensitive);
            if(lat != null) parameters.Add("lat", lat);
            if(@long != null) parameters.Add("long", @long);
            if(place_id != null) parameters.Add("place_id", place_id);
            if(display_coordinates != null) parameters.Add("display_coordinates", display_coordinates);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(media_ids != null) parameters.Add("media_ids", media_ids);
            if(attachment_url != null) parameters.Add("attachment_url", attachment_url);
            if(auto_populate_reply_metadata != null) parameters.Add("auto_populate_reply_metadata", auto_populate_reply_metadata);
            if(exclude_reply_user_ids != null) parameters.Add("exclude_reply_user_ids", exclude_reply_user_ids);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            if(enable_dm_commands != null) parameters.Add("enable_dm_commands", enable_dm_commands);
            if(fail_dm_commands != null) parameters.Add("fail_dm_commands", fail_dm_commands);
            return this.Tokens.AccessApiAsync<StatusResponse>(MethodType.Post, "statuses/update", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Updates the authenticating user’s current status and attaches media for upload.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> status (required)</para>
        /// <para>- <c>Stream</c> media (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> media (any one is required)</para>
        /// <para>- <c>FileInfo</c> media (any one is required)</para>
        /// <para>- <c>bool</c> possibly_sensitive (optional)</para>
        /// <para>- <c>long</c> in_reply_to_status_id (optional)</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> place_id (optional)</para>
        /// <para>- <c>bool</c> display_coordinates (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The updated status.</returns>
        [Obsolete("Use Media.Upload and Statuses.Update.")]
        public StatusResponse UpdateWithMedia(params Expression<Func<string, object>>[] parameters)
        {
            return this.UpdateWithMediaImpl(InternalUtils.ExpressionsToDictionary(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Updates the authenticating user’s current status and attaches media for upload.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> status (required)</para>
        /// <para>- <c>Stream</c> media (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> media (any one is required)</para>
        /// <para>- <c>FileInfo</c> media (any one is required)</para>
        /// <para>- <c>bool</c> possibly_sensitive (optional)</para>
        /// <para>- <c>long</c> in_reply_to_status_id (optional)</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> place_id (optional)</para>
        /// <para>- <c>bool</c> display_coordinates (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The updated status.</returns>
        [Obsolete("Use Media.Upload and Statuses.Update.")]
        public StatusResponse UpdateWithMedia(IDictionary<string, object> parameters)
        {
            return this.UpdateWithMediaImpl(parameters, "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Updates the authenticating user’s current status and attaches media for upload.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> status (required)</para>
        /// <para>- <c>Stream</c> media (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> media (any one is required)</para>
        /// <para>- <c>FileInfo</c> media (any one is required)</para>
        /// <para>- <c>bool</c> possibly_sensitive (optional)</para>
        /// <para>- <c>long</c> in_reply_to_status_id (optional)</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> place_id (optional)</para>
        /// <para>- <c>bool</c> display_coordinates (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The updated status.</returns>
        [Obsolete("Use Media.Upload and Statuses.Update.")]
        public StatusResponse UpdateWithMedia(object parameters)
        {
            return this.UpdateWithMediaImpl(InternalUtils.ResolveObject(parameters), "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Updates the authenticating user’s current status and attaches media for upload.</para>
        /// </summary>
        /// <param name="status">required.</param>
        /// <param name="media">any one is required.</param>
        /// <param name="possibly_sensitive">optional.</param>
        /// <param name="in_reply_to_status_id">optional.</param>
        /// <param name="lat">optional.</param>
        /// <param name="long">optional.</param>
        /// <param name="place_id">optional.</param>
        /// <param name="display_coordinates">optional.</param>
        /// <returns>The updated status.</returns>
        [Obsolete("Use Media.Upload and Statuses.Update.")]
        public StatusResponse UpdateWithMedia(string status, Stream media, bool? possibly_sensitive = null, long? in_reply_to_status_id = null, double? lat = null, double? @long = null, string place_id = null, bool? display_coordinates = null)
        {
            var parameters = new Dictionary<string, object>();
            if(status == null) throw new ArgumentNullException("status");
            parameters.Add("status", status);
            if(media == null) throw new ArgumentNullException("media");
            parameters.Add("media", media);
            if(possibly_sensitive != null) parameters.Add("possibly_sensitive", possibly_sensitive);
            if(in_reply_to_status_id != null) parameters.Add("in_reply_to_status_id", in_reply_to_status_id);
            if(lat != null) parameters.Add("lat", lat);
            if(@long != null) parameters.Add("long", @long);
            if(place_id != null) parameters.Add("place_id", place_id);
            if(display_coordinates != null) parameters.Add("display_coordinates", display_coordinates);
            return this.UpdateWithMediaImpl(parameters, "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Updates the authenticating user’s current status and attaches media for upload.</para>
        /// </summary>
        /// <param name="status">required.</param>
        /// <param name="media">any one is required.</param>
        /// <param name="possibly_sensitive">optional.</param>
        /// <param name="in_reply_to_status_id">optional.</param>
        /// <param name="lat">optional.</param>
        /// <param name="long">optional.</param>
        /// <param name="place_id">optional.</param>
        /// <param name="display_coordinates">optional.</param>
        /// <returns>The updated status.</returns>
        [Obsolete("Use Media.Upload and Statuses.Update.")]
        public StatusResponse UpdateWithMedia(string status, IEnumerable<byte> media, bool? possibly_sensitive = null, long? in_reply_to_status_id = null, double? lat = null, double? @long = null, string place_id = null, bool? display_coordinates = null)
        {
            var parameters = new Dictionary<string, object>();
            if(status == null) throw new ArgumentNullException("status");
            parameters.Add("status", status);
            if(media == null) throw new ArgumentNullException("media");
            parameters.Add("media", media);
            if(possibly_sensitive != null) parameters.Add("possibly_sensitive", possibly_sensitive);
            if(in_reply_to_status_id != null) parameters.Add("in_reply_to_status_id", in_reply_to_status_id);
            if(lat != null) parameters.Add("lat", lat);
            if(@long != null) parameters.Add("long", @long);
            if(place_id != null) parameters.Add("place_id", place_id);
            if(display_coordinates != null) parameters.Add("display_coordinates", display_coordinates);
            return this.UpdateWithMediaImpl(parameters, "1.1", null);
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Updates the authenticating user’s current status and attaches media for upload.</para>
        /// </summary>
        /// <param name="status">required.</param>
        /// <param name="media">any one is required.</param>
        /// <param name="possibly_sensitive">optional.</param>
        /// <param name="in_reply_to_status_id">optional.</param>
        /// <param name="lat">optional.</param>
        /// <param name="long">optional.</param>
        /// <param name="place_id">optional.</param>
        /// <param name="display_coordinates">optional.</param>
        /// <returns>The updated status.</returns>
        [Obsolete("Use Media.Upload and Statuses.Update.")]
        public StatusResponse UpdateWithMedia(string status, FileInfo media, bool? possibly_sensitive = null, long? in_reply_to_status_id = null, double? lat = null, double? @long = null, string place_id = null, bool? display_coordinates = null)
        {
            var parameters = new Dictionary<string, object>();
            if(status == null) throw new ArgumentNullException("status");
            parameters.Add("status", status);
            if(media == null) throw new ArgumentNullException("media");
            parameters.Add("media", media);
            if(possibly_sensitive != null) parameters.Add("possibly_sensitive", possibly_sensitive);
            if(in_reply_to_status_id != null) parameters.Add("in_reply_to_status_id", in_reply_to_status_id);
            if(lat != null) parameters.Add("lat", lat);
            if(@long != null) parameters.Add("long", @long);
            if(place_id != null) parameters.Add("place_id", place_id);
            if(display_coordinates != null) parameters.Add("display_coordinates", display_coordinates);
            return this.UpdateWithMediaImpl(parameters, "1.1", null);
        }
        #endif

        /// <summary>
        /// <para>Updates the authenticating user’s current status and attaches media for upload.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> status (required)</para>
        /// <para>- <c>Stream</c> media (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> media (any one is required)</para>
        /// <para>- <c>FileInfo</c> media (any one is required)</para>
        /// <para>- <c>bool</c> possibly_sensitive (optional)</para>
        /// <para>- <c>long</c> in_reply_to_status_id (optional)</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> place_id (optional)</para>
        /// <para>- <c>bool</c> display_coordinates (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The updated status.</returns>
        [Obsolete("Use Media.Upload and Statuses.Update.")]
        public Task<StatusResponse> UpdateWithMediaAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.UpdateWithMediaAsyncImpl(InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, "1.1", null);
        }

        /// <summary>
        /// <para>Updates the authenticating user’s current status and attaches media for upload.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> status (required)</para>
        /// <para>- <c>Stream</c> media (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> media (any one is required)</para>
        /// <para>- <c>FileInfo</c> media (any one is required)</para>
        /// <para>- <c>bool</c> possibly_sensitive (optional)</para>
        /// <para>- <c>long</c> in_reply_to_status_id (optional)</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> place_id (optional)</para>
        /// <para>- <c>bool</c> display_coordinates (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The updated status.</returns>
        [Obsolete("Use Media.Upload and Statuses.Update.")]
        public Task<StatusResponse> UpdateWithMediaAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.UpdateWithMediaAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Updates the authenticating user’s current status and attaches media for upload.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> status (required)</para>
        /// <para>- <c>Stream</c> media (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> media (any one is required)</para>
        /// <para>- <c>FileInfo</c> media (any one is required)</para>
        /// <para>- <c>bool</c> possibly_sensitive (optional)</para>
        /// <para>- <c>long</c> in_reply_to_status_id (optional)</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> place_id (optional)</para>
        /// <para>- <c>bool</c> display_coordinates (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The updated status.</returns>
        [Obsolete("Use Media.Upload and Statuses.Update.")]
        public Task<StatusResponse> UpdateWithMediaAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.UpdateWithMediaAsyncImpl(InternalUtils.ResolveObject(parameters), cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Updates the authenticating user’s current status and attaches media for upload.</para>
        /// </summary>
        /// <param name="status">required.</param>
        /// <param name="media">any one is required.</param>
        /// <param name="possibly_sensitive">optional.</param>
        /// <param name="in_reply_to_status_id">optional.</param>
        /// <param name="lat">optional.</param>
        /// <param name="long">optional.</param>
        /// <param name="place_id">optional.</param>
        /// <param name="display_coordinates">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The updated status.</returns>
        [Obsolete("Use Media.Upload and Statuses.Update.")]
        public Task<StatusResponse> UpdateWithMediaAsync(string status, Stream media, bool? possibly_sensitive = null, long? in_reply_to_status_id = null, double? lat = null, double? @long = null, string place_id = null, bool? display_coordinates = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(status == null) throw new ArgumentNullException("status");
            parameters.Add("status", status);
            if(media == null) throw new ArgumentNullException("media");
            parameters.Add("media", media);
            if(possibly_sensitive != null) parameters.Add("possibly_sensitive", possibly_sensitive);
            if(in_reply_to_status_id != null) parameters.Add("in_reply_to_status_id", in_reply_to_status_id);
            if(lat != null) parameters.Add("lat", lat);
            if(@long != null) parameters.Add("long", @long);
            if(place_id != null) parameters.Add("place_id", place_id);
            if(display_coordinates != null) parameters.Add("display_coordinates", display_coordinates);
            return this.UpdateWithMediaAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Updates the authenticating user’s current status and attaches media for upload.</para>
        /// </summary>
        /// <param name="status">required.</param>
        /// <param name="media">any one is required.</param>
        /// <param name="possibly_sensitive">optional.</param>
        /// <param name="in_reply_to_status_id">optional.</param>
        /// <param name="lat">optional.</param>
        /// <param name="long">optional.</param>
        /// <param name="place_id">optional.</param>
        /// <param name="display_coordinates">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The updated status.</returns>
        [Obsolete("Use Media.Upload and Statuses.Update.")]
        public Task<StatusResponse> UpdateWithMediaAsync(string status, IEnumerable<byte> media, bool? possibly_sensitive = null, long? in_reply_to_status_id = null, double? lat = null, double? @long = null, string place_id = null, bool? display_coordinates = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(status == null) throw new ArgumentNullException("status");
            parameters.Add("status", status);
            if(media == null) throw new ArgumentNullException("media");
            parameters.Add("media", media);
            if(possibly_sensitive != null) parameters.Add("possibly_sensitive", possibly_sensitive);
            if(in_reply_to_status_id != null) parameters.Add("in_reply_to_status_id", in_reply_to_status_id);
            if(lat != null) parameters.Add("lat", lat);
            if(@long != null) parameters.Add("long", @long);
            if(place_id != null) parameters.Add("place_id", place_id);
            if(display_coordinates != null) parameters.Add("display_coordinates", display_coordinates);
            return this.UpdateWithMediaAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        /// <summary>
        /// <para>Updates the authenticating user’s current status and attaches media for upload.</para>
        /// </summary>
        /// <param name="status">required.</param>
        /// <param name="media">any one is required.</param>
        /// <param name="possibly_sensitive">optional.</param>
        /// <param name="in_reply_to_status_id">optional.</param>
        /// <param name="lat">optional.</param>
        /// <param name="long">optional.</param>
        /// <param name="place_id">optional.</param>
        /// <param name="display_coordinates">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The updated status.</returns>
        [Obsolete("Use Media.Upload and Statuses.Update.")]
        public Task<StatusResponse> UpdateWithMediaAsync(string status, FileInfo media, bool? possibly_sensitive = null, long? in_reply_to_status_id = null, double? lat = null, double? @long = null, string place_id = null, bool? display_coordinates = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(status == null) throw new ArgumentNullException("status");
            parameters.Add("status", status);
            if(media == null) throw new ArgumentNullException("media");
            parameters.Add("media", media);
            if(possibly_sensitive != null) parameters.Add("possibly_sensitive", possibly_sensitive);
            if(in_reply_to_status_id != null) parameters.Add("in_reply_to_status_id", in_reply_to_status_id);
            if(lat != null) parameters.Add("lat", lat);
            if(@long != null) parameters.Add("long", @long);
            if(place_id != null) parameters.Add("place_id", place_id);
            if(display_coordinates != null) parameters.Add("display_coordinates", display_coordinates);
            return this.UpdateWithMediaAsyncImpl(parameters, cancellationToken, "1.1", null);
        }

        #if !NETSTANDARD1_3
        private StatusResponse UpdateWithMediaImpl(IEnumerable<KeyValuePair<string, object>> parameters, string urlPrefix, string urlSuffix)
        {
            if(parameters == null) throw new ArgumentNullException("parameters");
            var list = parameters.ToList();
            list.Where(kvp => kvp.Key == "media").ToArray().ForEach(kvp =>
            {
                list.Remove(kvp);
                list.Add(new KeyValuePair<string, object>("media[]", kvp.Value));
            });
            return this.Tokens.AccessApiImpl<StatusResponse>(MethodType.Post, "statuses/update_with_media", list, "", urlPrefix, urlSuffix);
        }
        #endif
        private Task<StatusResponse> UpdateWithMediaAsyncImpl(IEnumerable<KeyValuePair<string, object>> parameters, CancellationToken cancellationToken, string urlPrefix, string urlSuffix)
        {
            if(parameters == null) throw new ArgumentNullException("parameters");
            var list = parameters.ToList();
            list.Where(kvp => kvp.Key == "media").ToArray().ForEach(kvp =>
            {
                list.Remove(kvp);
                list.Add(new KeyValuePair<string, object>("media[]", kvp.Value));
            });
            return this.Tokens.AccessApiAsyncImpl<StatusResponse>(MethodType.Post, "statuses/update_with_media", list, cancellationToken, "", urlPrefix, urlSuffix);
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Destroys the status specified by the required ID parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The destroyed status.</returns>
        public StatusResponse Destroy(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApi<StatusResponse>(MethodType.Post, "statuses/destroy/{id}", new [] { "id" }, InternalUtils.ExpressionsToDictionary(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Destroys the status specified by the required ID parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The destroyed status.</returns>
        public StatusResponse Destroy(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessParameterReservedApi<StatusResponse>(MethodType.Post, "statuses/destroy/{id}", new [] { "id" }, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Destroys the status specified by the required ID parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The destroyed status.</returns>
        public StatusResponse Destroy(object parameters)
        {
            return this.Tokens.AccessParameterReservedApi<StatusResponse>(MethodType.Post, "statuses/destroy/{id}", new [] { "id" }, InternalUtils.ResolveObject(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Destroys the status specified by the required ID parameter.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The destroyed status.</returns>
        public StatusResponse Destroy(long id, bool? trim_user = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessParameterReservedApi<StatusResponse>(MethodType.Post, "statuses/destroy/{id}", new [] { "id" }, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Destroys the status specified by the required ID parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The destroyed status.</returns>
        public Task<StatusResponse> DestroyAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiAsync<StatusResponse>(MethodType.Post, "statuses/destroy/{id}", new [] { "id" }, InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Destroys the status specified by the required ID parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The destroyed status.</returns>
        public Task<StatusResponse> DestroyAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<StatusResponse>(MethodType.Post, "statuses/destroy/{id}", new [] { "id" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Destroys the status specified by the required ID parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The destroyed status.</returns>
        public Task<StatusResponse> DestroyAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<StatusResponse>(MethodType.Post, "statuses/destroy/{id}", new [] { "id" }, InternalUtils.ResolveObject(parameters), cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Destroys the status specified by the required ID parameter.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The destroyed status.</returns>
        public Task<StatusResponse> DestroyAsync(long id, bool? trim_user = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessParameterReservedApiAsync<StatusResponse>(MethodType.Post, "statuses/destroy/{id}", new [] { "id" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Retweets a tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The retweeted status.</returns>
        public StatusResponse Retweet(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApi<StatusResponse>(MethodType.Post, "statuses/retweet/{id}", new [] { "id" }, InternalUtils.ExpressionsToDictionary(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Retweets a tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The retweeted status.</returns>
        public StatusResponse Retweet(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessParameterReservedApi<StatusResponse>(MethodType.Post, "statuses/retweet/{id}", new [] { "id" }, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Retweets a tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The retweeted status.</returns>
        public StatusResponse Retweet(object parameters)
        {
            return this.Tokens.AccessParameterReservedApi<StatusResponse>(MethodType.Post, "statuses/retweet/{id}", new [] { "id" }, InternalUtils.ResolveObject(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Retweets a tweet.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The retweeted status.</returns>
        public StatusResponse Retweet(long id, bool? trim_user = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessParameterReservedApi<StatusResponse>(MethodType.Post, "statuses/retweet/{id}", new [] { "id" }, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Retweets a tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The retweeted status.</returns>
        public Task<StatusResponse> RetweetAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiAsync<StatusResponse>(MethodType.Post, "statuses/retweet/{id}", new [] { "id" }, InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Retweets a tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The retweeted status.</returns>
        public Task<StatusResponse> RetweetAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<StatusResponse>(MethodType.Post, "statuses/retweet/{id}", new [] { "id" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Retweets a tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The retweeted status.</returns>
        public Task<StatusResponse> RetweetAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<StatusResponse>(MethodType.Post, "statuses/retweet/{id}", new [] { "id" }, InternalUtils.ResolveObject(parameters), cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Retweets a tweet.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The retweeted status.</returns>
        public Task<StatusResponse> RetweetAsync(long id, bool? trim_user = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessParameterReservedApiAsync<StatusResponse>(MethodType.Post, "statuses/retweet/{id}", new [] { "id" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Untweets a retweeted status.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The original Tweet with retweet details embedded.</returns>
        public StatusResponse Unretweet(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApi<StatusResponse>(MethodType.Post, "statuses/unretweet/{id}", new [] { "id" }, InternalUtils.ExpressionsToDictionary(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Untweets a retweeted status.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The original Tweet with retweet details embedded.</returns>
        public StatusResponse Unretweet(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessParameterReservedApi<StatusResponse>(MethodType.Post, "statuses/unretweet/{id}", new [] { "id" }, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Untweets a retweeted status.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The original Tweet with retweet details embedded.</returns>
        public StatusResponse Unretweet(object parameters)
        {
            return this.Tokens.AccessParameterReservedApi<StatusResponse>(MethodType.Post, "statuses/unretweet/{id}", new [] { "id" }, InternalUtils.ResolveObject(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Untweets a retweeted status.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The original Tweet with retweet details embedded.</returns>
        public StatusResponse Unretweet(long id, bool? trim_user = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessParameterReservedApi<StatusResponse>(MethodType.Post, "statuses/unretweet/{id}", new [] { "id" }, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Untweets a retweeted status.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The original Tweet with retweet details embedded.</returns>
        public Task<StatusResponse> UnretweetAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiAsync<StatusResponse>(MethodType.Post, "statuses/unretweet/{id}", new [] { "id" }, InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Untweets a retweeted status.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The original Tweet with retweet details embedded.</returns>
        public Task<StatusResponse> UnretweetAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<StatusResponse>(MethodType.Post, "statuses/unretweet/{id}", new [] { "id" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Untweets a retweeted status.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The original Tweet with retweet details embedded.</returns>
        public Task<StatusResponse> UnretweetAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<StatusResponse>(MethodType.Post, "statuses/unretweet/{id}", new [] { "id" }, InternalUtils.ResolveObject(parameters), cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Untweets a retweeted status.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The original Tweet with retweet details embedded.</returns>
        public Task<StatusResponse> UnretweetAsync(long id, bool? trim_user = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessParameterReservedApiAsync<StatusResponse>(MethodType.Post, "statuses/unretweet/{id}", new [] { "id" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET trends.
    /// </summary>
    public partial class Trends : ApiProviderBase
    {
        internal Trends(TokensBase e) : base(e) { }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the locations that Twitter has trending topic information for.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The locations.</returns>
        public ListedResponse<TrendLocation> Available(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<TrendLocation>(MethodType.Get, "trends/available", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the locations that Twitter has trending topic information for.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The locations.</returns>
        public ListedResponse<TrendLocation> Available(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<TrendLocation>(MethodType.Get, "trends/available", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the locations that Twitter has trending topic information for.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The locations.</returns>
        public ListedResponse<TrendLocation> Available(object parameters)
        {
            return this.Tokens.AccessApiArray<TrendLocation>(MethodType.Get, "trends/available", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the locations that Twitter has trending topic information for.</para>
        /// </summary>
        /// <returns>The locations.</returns>
        public ListedResponse<TrendLocation> Available()
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiArray<TrendLocation>(MethodType.Get, "trends/available", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns the locations that Twitter has trending topic information for.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The locations.</returns>
        public Task<ListedResponse<TrendLocation>> AvailableAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<TrendLocation>(MethodType.Get, "trends/available", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the locations that Twitter has trending topic information for.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The locations.</returns>
        public Task<ListedResponse<TrendLocation>> AvailableAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<TrendLocation>(MethodType.Get, "trends/available", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the locations that Twitter has trending topic information for.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The locations.</returns>
        public Task<ListedResponse<TrendLocation>> AvailableAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<TrendLocation>(MethodType.Get, "trends/available", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the locations that Twitter has trending topic information for.</para>
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The locations.</returns>
        public Task<ListedResponse<TrendLocation>> AvailableAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiArrayAsync<TrendLocation>(MethodType.Get, "trends/available", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the locations that Twitter has trending topic information for, closest to a specified location.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The locations.</returns>
        public ListedResponse<TrendLocation> Closest(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<TrendLocation>(MethodType.Get, "trends/closest", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the locations that Twitter has trending topic information for, closest to a specified location.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The locations.</returns>
        public ListedResponse<TrendLocation> Closest(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<TrendLocation>(MethodType.Get, "trends/closest", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the locations that Twitter has trending topic information for, closest to a specified location.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The locations.</returns>
        public ListedResponse<TrendLocation> Closest(object parameters)
        {
            return this.Tokens.AccessApiArray<TrendLocation>(MethodType.Get, "trends/closest", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the locations that Twitter has trending topic information for, closest to a specified location.</para>
        /// </summary>
        /// <param name="lat">required.</param>
        /// <param name="long">required.</param>
        /// <returns>The locations.</returns>
        public ListedResponse<TrendLocation> Closest(double lat, double @long)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("lat", lat);
            parameters.Add("long", @long);
            return this.Tokens.AccessApiArray<TrendLocation>(MethodType.Get, "trends/closest", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns the locations that Twitter has trending topic information for, closest to a specified location.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The locations.</returns>
        public Task<ListedResponse<TrendLocation>> ClosestAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<TrendLocation>(MethodType.Get, "trends/closest", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the locations that Twitter has trending topic information for, closest to a specified location.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The locations.</returns>
        public Task<ListedResponse<TrendLocation>> ClosestAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<TrendLocation>(MethodType.Get, "trends/closest", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the locations that Twitter has trending topic information for, closest to a specified location.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The locations.</returns>
        public Task<ListedResponse<TrendLocation>> ClosestAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<TrendLocation>(MethodType.Get, "trends/closest", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the locations that Twitter has trending topic information for, closest to a specified location.</para>
        /// </summary>
        /// <param name="lat">required.</param>
        /// <param name="long">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The locations.</returns>
        public Task<ListedResponse<TrendLocation>> ClosestAsync(double lat, double @long, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("lat", lat);
            parameters.Add("long", @long);
            return this.Tokens.AccessApiArrayAsync<TrendLocation>(MethodType.Get, "trends/closest", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the top 10 trending topics for a specific id, if trending information is available for it.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>string</c> exclude (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The queries.</returns>
        public ListedResponse<TrendsResult> Place(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<TrendsResult>(MethodType.Get, "trends/place", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the top 10 trending topics for a specific id, if trending information is available for it.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>string</c> exclude (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The queries.</returns>
        public ListedResponse<TrendsResult> Place(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<TrendsResult>(MethodType.Get, "trends/place", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the top 10 trending topics for a specific id, if trending information is available for it.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>string</c> exclude (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The queries.</returns>
        public ListedResponse<TrendsResult> Place(object parameters)
        {
            return this.Tokens.AccessApiArray<TrendsResult>(MethodType.Get, "trends/place", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the top 10 trending topics for a specific id, if trending information is available for it.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="exclude">optional.</param>
        /// <returns>The queries.</returns>
        public ListedResponse<TrendsResult> Place(long id, string exclude = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(exclude != null) parameters.Add("exclude", exclude);
            return this.Tokens.AccessApiArray<TrendsResult>(MethodType.Get, "trends/place", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns the top 10 trending topics for a specific id, if trending information is available for it.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>string</c> exclude (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The queries.</returns>
        public Task<ListedResponse<TrendsResult>> PlaceAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<TrendsResult>(MethodType.Get, "trends/place", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the top 10 trending topics for a specific id, if trending information is available for it.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>string</c> exclude (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The queries.</returns>
        public Task<ListedResponse<TrendsResult>> PlaceAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<TrendsResult>(MethodType.Get, "trends/place", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the top 10 trending topics for a specific id, if trending information is available for it.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>string</c> exclude (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The queries.</returns>
        public Task<ListedResponse<TrendsResult>> PlaceAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<TrendsResult>(MethodType.Get, "trends/place", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the top 10 trending topics for a specific id, if trending information is available for it.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="exclude">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The queries.</returns>
        public Task<ListedResponse<TrendsResult>> PlaceAsync(long id, string exclude = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(exclude != null) parameters.Add("exclude", exclude);
            return this.Tokens.AccessApiArrayAsync<TrendsResult>(MethodType.Get, "trends/place", parameters, cancellationToken, urlPrefix: "1.1");
        }

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of Premium search API.
    /// </summary>
    public partial class Tweets : ApiProviderBase
    {
        internal Tweets(TokensBase e) : base(e) { }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of relevant Tweets matching a specified query.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> product (required)</para>
        /// <para>- <c>string</c> label (required)</para>
        /// <para>- <c>string</c> query (required)</para>
        /// <para>- <c>string</c> tag (optional)</para>
        /// <para>- <c>string</c> fromDate (optional)</para>
        /// <para>- <c>string</c> toDate (optional)</para>
        /// <para>- <c>long</c> maxResults (optional)</para>
        /// <para>- <c>string</c> next (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public PremiumSearchResult Search(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApi<PremiumSearchResult>(MethodType.Get, "tweets/search/{product}/{label}", new [] { "product", "label" }, InternalUtils.ExpressionsToDictionary(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of relevant Tweets matching a specified query.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> product (required)</para>
        /// <para>- <c>string</c> label (required)</para>
        /// <para>- <c>string</c> query (required)</para>
        /// <para>- <c>string</c> tag (optional)</para>
        /// <para>- <c>string</c> fromDate (optional)</para>
        /// <para>- <c>string</c> toDate (optional)</para>
        /// <para>- <c>long</c> maxResults (optional)</para>
        /// <para>- <c>string</c> next (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public PremiumSearchResult Search(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessParameterReservedApi<PremiumSearchResult>(MethodType.Get, "tweets/search/{product}/{label}", new [] { "product", "label" }, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of relevant Tweets matching a specified query.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> product (required)</para>
        /// <para>- <c>string</c> label (required)</para>
        /// <para>- <c>string</c> query (required)</para>
        /// <para>- <c>string</c> tag (optional)</para>
        /// <para>- <c>string</c> fromDate (optional)</para>
        /// <para>- <c>string</c> toDate (optional)</para>
        /// <para>- <c>long</c> maxResults (optional)</para>
        /// <para>- <c>string</c> next (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public PremiumSearchResult Search(object parameters)
        {
            return this.Tokens.AccessParameterReservedApi<PremiumSearchResult>(MethodType.Get, "tweets/search/{product}/{label}", new [] { "product", "label" }, InternalUtils.ResolveObject(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of relevant Tweets matching a specified query.</para>
        /// </summary>
        /// <param name="product">required.</param>
        /// <param name="label">required.</param>
        /// <param name="query">required.</param>
        /// <param name="tag">optional.</param>
        /// <param name="fromDate">optional.</param>
        /// <param name="toDate">optional.</param>
        /// <param name="maxResults">optional.</param>
        /// <param name="next">optional.</param>
        /// <returns>The statuses.</returns>
        public PremiumSearchResult Search(string product, string label, string query, string tag = null, string fromDate = null, string toDate = null, long? maxResults = null, string next = null)
        {
            var parameters = new Dictionary<string, object>();
            if(product == null) throw new ArgumentNullException("product");
            parameters.Add("product", product);
            if(label == null) throw new ArgumentNullException("label");
            parameters.Add("label", label);
            if(query == null) throw new ArgumentNullException("query");
            parameters.Add("query", query);
            if(tag != null) parameters.Add("tag", tag);
            if(fromDate != null) parameters.Add("fromDate", fromDate);
            if(toDate != null) parameters.Add("toDate", toDate);
            if(maxResults != null) parameters.Add("maxResults", maxResults);
            if(next != null) parameters.Add("next", next);
            return this.Tokens.AccessParameterReservedApi<PremiumSearchResult>(MethodType.Get, "tweets/search/{product}/{label}", new [] { "product", "label" }, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns a collection of relevant Tweets matching a specified query.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> product (required)</para>
        /// <para>- <c>string</c> label (required)</para>
        /// <para>- <c>string</c> query (required)</para>
        /// <para>- <c>string</c> tag (optional)</para>
        /// <para>- <c>string</c> fromDate (optional)</para>
        /// <para>- <c>string</c> toDate (optional)</para>
        /// <para>- <c>long</c> maxResults (optional)</para>
        /// <para>- <c>string</c> next (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public Task<PremiumSearchResult> SearchAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiAsync<PremiumSearchResult>(MethodType.Get, "tweets/search/{product}/{label}", new [] { "product", "label" }, InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of relevant Tweets matching a specified query.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> product (required)</para>
        /// <para>- <c>string</c> label (required)</para>
        /// <para>- <c>string</c> query (required)</para>
        /// <para>- <c>string</c> tag (optional)</para>
        /// <para>- <c>string</c> fromDate (optional)</para>
        /// <para>- <c>string</c> toDate (optional)</para>
        /// <para>- <c>long</c> maxResults (optional)</para>
        /// <para>- <c>string</c> next (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<PremiumSearchResult> SearchAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<PremiumSearchResult>(MethodType.Get, "tweets/search/{product}/{label}", new [] { "product", "label" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of relevant Tweets matching a specified query.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> product (required)</para>
        /// <para>- <c>string</c> label (required)</para>
        /// <para>- <c>string</c> query (required)</para>
        /// <para>- <c>string</c> tag (optional)</para>
        /// <para>- <c>string</c> fromDate (optional)</para>
        /// <para>- <c>string</c> toDate (optional)</para>
        /// <para>- <c>long</c> maxResults (optional)</para>
        /// <para>- <c>string</c> next (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<PremiumSearchResult> SearchAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<PremiumSearchResult>(MethodType.Get, "tweets/search/{product}/{label}", new [] { "product", "label" }, InternalUtils.ResolveObject(parameters), cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of relevant Tweets matching a specified query.</para>
        /// </summary>
        /// <param name="product">required.</param>
        /// <param name="label">required.</param>
        /// <param name="query">required.</param>
        /// <param name="tag">optional.</param>
        /// <param name="fromDate">optional.</param>
        /// <param name="toDate">optional.</param>
        /// <param name="maxResults">optional.</param>
        /// <param name="next">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<PremiumSearchResult> SearchAsync(string product, string label, string query, string tag = null, string fromDate = null, string toDate = null, long? maxResults = null, string next = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(product == null) throw new ArgumentNullException("product");
            parameters.Add("product", product);
            if(label == null) throw new ArgumentNullException("label");
            parameters.Add("label", label);
            if(query == null) throw new ArgumentNullException("query");
            parameters.Add("query", query);
            if(tag != null) parameters.Add("tag", tag);
            if(fromDate != null) parameters.Add("fromDate", fromDate);
            if(toDate != null) parameters.Add("toDate", toDate);
            if(maxResults != null) parameters.Add("maxResults", maxResults);
            if(next != null) parameters.Add("next", next);
            return this.Tokens.AccessParameterReservedApiAsync<PremiumSearchResult>(MethodType.Get, "tweets/search/{product}/{label}", new [] { "product", "label" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns counts (data volumes) data for the specified query.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> product (required)</para>
        /// <para>- <c>string</c> label (required)</para>
        /// <para>- <c>string</c> query (required)</para>
        /// <para>- <c>string</c> fromDate (optional)</para>
        /// <para>- <c>string</c> toDate (optional)</para>
        /// <para>- <c>Bucket</c> bucket (optional)</para>
        /// <para>- <c>string</c> next (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses counts.</returns>
        public PremiumSearchCountResult Counts(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApi<PremiumSearchCountResult>(MethodType.Get, "tweets/search/{product}/{label}/counts", new [] { "product", "label" }, InternalUtils.ExpressionsToDictionary(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns counts (data volumes) data for the specified query.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> product (required)</para>
        /// <para>- <c>string</c> label (required)</para>
        /// <para>- <c>string</c> query (required)</para>
        /// <para>- <c>string</c> fromDate (optional)</para>
        /// <para>- <c>string</c> toDate (optional)</para>
        /// <para>- <c>Bucket</c> bucket (optional)</para>
        /// <para>- <c>string</c> next (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses counts.</returns>
        public PremiumSearchCountResult Counts(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessParameterReservedApi<PremiumSearchCountResult>(MethodType.Get, "tweets/search/{product}/{label}/counts", new [] { "product", "label" }, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns counts (data volumes) data for the specified query.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> product (required)</para>
        /// <para>- <c>string</c> label (required)</para>
        /// <para>- <c>string</c> query (required)</para>
        /// <para>- <c>string</c> fromDate (optional)</para>
        /// <para>- <c>string</c> toDate (optional)</para>
        /// <para>- <c>Bucket</c> bucket (optional)</para>
        /// <para>- <c>string</c> next (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses counts.</returns>
        public PremiumSearchCountResult Counts(object parameters)
        {
            return this.Tokens.AccessParameterReservedApi<PremiumSearchCountResult>(MethodType.Get, "tweets/search/{product}/{label}/counts", new [] { "product", "label" }, InternalUtils.ResolveObject(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns counts (data volumes) data for the specified query.</para>
        /// </summary>
        /// <param name="product">required.</param>
        /// <param name="label">required.</param>
        /// <param name="query">required.</param>
        /// <param name="fromDate">optional.</param>
        /// <param name="toDate">optional.</param>
        /// <param name="bucket">optional.</param>
        /// <param name="next">optional.</param>
        /// <returns>The statuses counts.</returns>
        public PremiumSearchCountResult Counts(string product, string label, string query, string fromDate = null, string toDate = null, Bucket? bucket = null, string next = null)
        {
            var parameters = new Dictionary<string, object>();
            if(product == null) throw new ArgumentNullException("product");
            parameters.Add("product", product);
            if(label == null) throw new ArgumentNullException("label");
            parameters.Add("label", label);
            if(query == null) throw new ArgumentNullException("query");
            parameters.Add("query", query);
            if(fromDate != null) parameters.Add("fromDate", fromDate);
            if(toDate != null) parameters.Add("toDate", toDate);
            if(bucket != null) parameters.Add("bucket", bucket);
            if(next != null) parameters.Add("next", next);
            return this.Tokens.AccessParameterReservedApi<PremiumSearchCountResult>(MethodType.Get, "tweets/search/{product}/{label}/counts", new [] { "product", "label" }, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns counts (data volumes) data for the specified query.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> product (required)</para>
        /// <para>- <c>string</c> label (required)</para>
        /// <para>- <c>string</c> query (required)</para>
        /// <para>- <c>string</c> fromDate (optional)</para>
        /// <para>- <c>string</c> toDate (optional)</para>
        /// <para>- <c>Bucket</c> bucket (optional)</para>
        /// <para>- <c>string</c> next (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses counts.</returns>
        public Task<PremiumSearchCountResult> CountsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiAsync<PremiumSearchCountResult>(MethodType.Get, "tweets/search/{product}/{label}/counts", new [] { "product", "label" }, InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns counts (data volumes) data for the specified query.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> product (required)</para>
        /// <para>- <c>string</c> label (required)</para>
        /// <para>- <c>string</c> query (required)</para>
        /// <para>- <c>string</c> fromDate (optional)</para>
        /// <para>- <c>string</c> toDate (optional)</para>
        /// <para>- <c>Bucket</c> bucket (optional)</para>
        /// <para>- <c>string</c> next (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses counts.</returns>
        public Task<PremiumSearchCountResult> CountsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<PremiumSearchCountResult>(MethodType.Get, "tweets/search/{product}/{label}/counts", new [] { "product", "label" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns counts (data volumes) data for the specified query.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> product (required)</para>
        /// <para>- <c>string</c> label (required)</para>
        /// <para>- <c>string</c> query (required)</para>
        /// <para>- <c>string</c> fromDate (optional)</para>
        /// <para>- <c>string</c> toDate (optional)</para>
        /// <para>- <c>Bucket</c> bucket (optional)</para>
        /// <para>- <c>string</c> next (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses counts.</returns>
        public Task<PremiumSearchCountResult> CountsAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<PremiumSearchCountResult>(MethodType.Get, "tweets/search/{product}/{label}/counts", new [] { "product", "label" }, InternalUtils.ResolveObject(parameters), cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns counts (data volumes) data for the specified query.</para>
        /// </summary>
        /// <param name="product">required.</param>
        /// <param name="label">required.</param>
        /// <param name="query">required.</param>
        /// <param name="fromDate">optional.</param>
        /// <param name="toDate">optional.</param>
        /// <param name="bucket">optional.</param>
        /// <param name="next">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses counts.</returns>
        public Task<PremiumSearchCountResult> CountsAsync(string product, string label, string query, string fromDate = null, string toDate = null, Bucket? bucket = null, string next = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(product == null) throw new ArgumentNullException("product");
            parameters.Add("product", product);
            if(label == null) throw new ArgumentNullException("label");
            parameters.Add("label", label);
            if(query == null) throw new ArgumentNullException("query");
            parameters.Add("query", query);
            if(fromDate != null) parameters.Add("fromDate", fromDate);
            if(toDate != null) parameters.Add("toDate", toDate);
            if(bucket != null) parameters.Add("bucket", bucket);
            if(next != null) parameters.Add("next", next);
            return this.Tokens.AccessParameterReservedApiAsync<PremiumSearchCountResult>(MethodType.Get, "tweets/search/{product}/{label}/counts", new [] { "product", "label" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET/POST users.
    /// </summary>
    public partial class Users : ApiProviderBase
    {
        internal Users(TokensBase e) : base(e) { }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of users that the specified user can "contribute" to.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Contributees(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/contributees", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of users that the specified user can "contribute" to.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Contributees(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/contributees", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of users that the specified user can "contribute" to.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Contributees(object parameters)
        {
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/contributees", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of users that the specified user can "contribute" to.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Contributees(long user_id, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/contributees", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of users that the specified user can "contribute" to.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Contributees(string screen_name, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/contributees", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns a collection of users that the specified user can "contribute" to.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> ContributeesAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/contributees", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of users that the specified user can "contribute" to.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> ContributeesAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/contributees", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of users that the specified user can "contribute" to.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> ContributeesAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/contributees", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of users that the specified user can "contribute" to.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> ContributeesAsync(long user_id, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/contributees", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of users that the specified user can "contribute" to.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> ContributeesAsync(string screen_name, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/contributees", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of users who can contribute to the specified account.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Contributors(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/contributors", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of users who can contribute to the specified account.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Contributors(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/contributors", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of users who can contribute to the specified account.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Contributors(object parameters)
        {
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/contributors", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of users who can contribute to the specified account.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Contributors(long user_id, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/contributors", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a collection of users who can contribute to the specified account.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Contributors(string screen_name, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/contributors", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns a collection of users who can contribute to the specified account.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> ContributorsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/contributors", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of users who can contribute to the specified account.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> ContributorsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/contributors", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of users who can contribute to the specified account.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> ContributorsAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/contributors", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of users who can contribute to the specified account.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> ContributorsAsync(long user_id, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/contributors", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a collection of users who can contribute to the specified account.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> ContributorsAsync(string screen_name, bool? include_entities = null, bool? skip_status = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/contributors", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns fully-hydrated user objects for up to 100 users per request, as specified by comma-separated values passed to the user_id and/or screen_name parameters.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Lookup(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/lookup", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns fully-hydrated user objects for up to 100 users per request, as specified by comma-separated values passed to the user_id and/or screen_name parameters.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Lookup(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/lookup", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns fully-hydrated user objects for up to 100 users per request, as specified by comma-separated values passed to the user_id and/or screen_name parameters.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Lookup(object parameters)
        {
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/lookup", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns fully-hydrated user objects for up to 100 users per request, as specified by comma-separated values passed to the user_id and/or screen_name parameters.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Lookup(IEnumerable<long> user_id, bool? include_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(user_id == null) throw new ArgumentNullException("user_id");
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/lookup", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns fully-hydrated user objects for up to 100 users per request, as specified by comma-separated values passed to the user_id and/or screen_name parameters.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Lookup(IEnumerable<string> screen_name, bool? include_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/lookup", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns fully-hydrated user objects for up to 100 users per request, as specified by comma-separated values passed to the user_id and/or screen_name parameters.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> LookupAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/lookup", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns fully-hydrated user objects for up to 100 users per request, as specified by comma-separated values passed to the user_id and/or screen_name parameters.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> LookupAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/lookup", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns fully-hydrated user objects for up to 100 users per request, as specified by comma-separated values passed to the user_id and/or screen_name parameters.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> LookupAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/lookup", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns fully-hydrated user objects for up to 100 users per request, as specified by comma-separated values passed to the user_id and/or screen_name parameters.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> LookupAsync(IEnumerable<long> user_id, bool? include_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(user_id == null) throw new ArgumentNullException("user_id");
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/lookup", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns fully-hydrated user objects for up to 100 users per request, as specified by comma-separated values passed to the user_id and/or screen_name parameters.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> LookupAsync(IEnumerable<string> screen_name, bool? include_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/lookup", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the size of the specified user's profile banner.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The sizes.</returns>
        public ProfileBannerSizes ProfileBanner(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<ProfileBannerSizes>(MethodType.Get, "users/profile_banner", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the size of the specified user's profile banner.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The sizes.</returns>
        public ProfileBannerSizes ProfileBanner(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<ProfileBannerSizes>(MethodType.Get, "users/profile_banner", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the size of the specified user's profile banner.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The sizes.</returns>
        public ProfileBannerSizes ProfileBanner(object parameters)
        {
            return this.Tokens.AccessApi<ProfileBannerSizes>(MethodType.Get, "users/profile_banner", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the size of the specified user's profile banner.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The sizes.</returns>
        public ProfileBannerSizes ProfileBanner(long user_id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApi<ProfileBannerSizes>(MethodType.Get, "users/profile_banner", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the size of the specified user's profile banner.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The sizes.</returns>
        public ProfileBannerSizes ProfileBanner(string screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApi<ProfileBannerSizes>(MethodType.Get, "users/profile_banner", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns the size of the specified user's profile banner.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The sizes.</returns>
        public Task<ProfileBannerSizes> ProfileBannerAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<ProfileBannerSizes>(MethodType.Get, "users/profile_banner", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the size of the specified user's profile banner.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The sizes.</returns>
        public Task<ProfileBannerSizes> ProfileBannerAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ProfileBannerSizes>(MethodType.Get, "users/profile_banner", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the size of the specified user's profile banner.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The sizes.</returns>
        public Task<ProfileBannerSizes> ProfileBannerAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ProfileBannerSizes>(MethodType.Get, "users/profile_banner", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the size of the specified user's profile banner.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The sizes.</returns>
        public Task<ProfileBannerSizes> ProfileBannerAsync(long user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiAsync<ProfileBannerSizes>(MethodType.Get, "users/profile_banner", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the size of the specified user's profile banner.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The sizes.</returns>
        public Task<ProfileBannerSizes> ProfileBannerAsync(string screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiAsync<ProfileBannerSizes>(MethodType.Get, "users/profile_banner", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Provides a simple, relevance-based search interface to public user accounts on Twitter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> q (required)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Search(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/search", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Provides a simple, relevance-based search interface to public user accounts on Twitter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> q (required)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Search(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/search", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Provides a simple, relevance-based search interface to public user accounts on Twitter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> q (required)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Search(object parameters)
        {
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/search", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Provides a simple, relevance-based search interface to public user accounts on Twitter.</para>
        /// </summary>
        /// <param name="q">required.</param>
        /// <param name="page">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Search(string q, int? page = null, int? count = null, bool? include_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(q == null) throw new ArgumentNullException("q");
            parameters.Add("q", q);
            if(page != null) parameters.Add("page", page);
            if(count != null) parameters.Add("count", count);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/search", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Provides a simple, relevance-based search interface to public user accounts on Twitter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> q (required)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> SearchAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/search", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Provides a simple, relevance-based search interface to public user accounts on Twitter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> q (required)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> SearchAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/search", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Provides a simple, relevance-based search interface to public user accounts on Twitter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> q (required)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> SearchAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/search", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Provides a simple, relevance-based search interface to public user accounts on Twitter.</para>
        /// </summary>
        /// <param name="q">required.</param>
        /// <param name="page">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> SearchAsync(string q, int? page = null, int? count = null, bool? include_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(q == null) throw new ArgumentNullException("q");
            parameters.Add("q", q);
            if(page != null) parameters.Add("page", page);
            if(count != null) parameters.Add("count", count);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/search", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a variety of information about the user specified by the required user_id or screen_name parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "users/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a variety of information about the user specified by the required user_id or screen_name parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "users/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a variety of information about the user specified by the required user_id or screen_name parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(object parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "users/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a variety of information about the user specified by the required user_id or screen_name parameter.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(long user_id, bool? include_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "users/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a variety of information about the user specified by the required user_id or screen_name parameter.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(string screen_name, bool? include_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "users/show", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns a variety of information about the user specified by the required user_id or screen_name parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "users/show", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a variety of information about the user specified by the required user_id or screen_name parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "users/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a variety of information about the user specified by the required user_id or screen_name parameter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "users/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a variety of information about the user specified by the required user_id or screen_name parameter.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(long user_id, bool? include_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "users/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a variety of information about the user specified by the required user_id or screen_name parameter.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(string screen_name, bool? include_entities = null, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "users/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the list of suggested user categories.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The categories.</returns>
        public ListedResponse<Category> Suggestions(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<Category>(MethodType.Get, "users/suggestions", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the list of suggested user categories.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The categories.</returns>
        public ListedResponse<Category> Suggestions(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<Category>(MethodType.Get, "users/suggestions", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the list of suggested user categories.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The categories.</returns>
        public ListedResponse<Category> Suggestions(object parameters)
        {
            return this.Tokens.AccessApiArray<Category>(MethodType.Get, "users/suggestions", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns the list of suggested user categories.</para>
        /// </summary>
        /// <param name="lang">optional.</param>
        /// <returns>The categories.</returns>
        public ListedResponse<Category> Suggestions(string lang = null)
        {
            var parameters = new Dictionary<string, object>();
            if(lang != null) parameters.Add("lang", lang);
            return this.Tokens.AccessApiArray<Category>(MethodType.Get, "users/suggestions", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns the list of suggested user categories.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The categories.</returns>
        public Task<ListedResponse<Category>> SuggestionsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<Category>(MethodType.Get, "users/suggestions", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the list of suggested user categories.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The categories.</returns>
        public Task<ListedResponse<Category>> SuggestionsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Category>(MethodType.Get, "users/suggestions", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the list of suggested user categories.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The categories.</returns>
        public Task<ListedResponse<Category>> SuggestionsAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Category>(MethodType.Get, "users/suggestions", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns the list of suggested user categories.</para>
        /// </summary>
        /// <param name="lang">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The categories.</returns>
        public Task<ListedResponse<Category>> SuggestionsAsync(string lang = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(lang != null) parameters.Add("lang", lang);
            return this.Tokens.AccessApiArrayAsync<Category>(MethodType.Get, "users/suggestions", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The category.</returns>
        public CategoryResponse Suggestion(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApi<CategoryResponse>(MethodType.Get, "users/suggestions/{slug}", new [] { "slug" }, InternalUtils.ExpressionsToDictionary(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The category.</returns>
        public CategoryResponse Suggestion(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessParameterReservedApi<CategoryResponse>(MethodType.Get, "users/suggestions/{slug}", new [] { "slug" }, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The category.</returns>
        public CategoryResponse Suggestion(object parameters)
        {
            return this.Tokens.AccessParameterReservedApi<CategoryResponse>(MethodType.Get, "users/suggestions/{slug}", new [] { "slug" }, InternalUtils.ResolveObject(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list.</para>
        /// </summary>
        /// <param name="slug">required.</param>
        /// <param name="lang">optional.</param>
        /// <returns>The category.</returns>
        public CategoryResponse Suggestion(string slug, string lang = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(lang != null) parameters.Add("lang", lang);
            return this.Tokens.AccessParameterReservedApi<CategoryResponse>(MethodType.Get, "users/suggestions/{slug}", new [] { "slug" }, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The category.</returns>
        public Task<CategoryResponse> SuggestionAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiAsync<CategoryResponse>(MethodType.Get, "users/suggestions/{slug}", new [] { "slug" }, InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The category.</returns>
        public Task<CategoryResponse> SuggestionAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<CategoryResponse>(MethodType.Get, "users/suggestions/{slug}", new [] { "slug" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The category.</returns>
        public Task<CategoryResponse> SuggestionAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<CategoryResponse>(MethodType.Get, "users/suggestions/{slug}", new [] { "slug" }, InternalUtils.ResolveObject(parameters), cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list.</para>
        /// </summary>
        /// <param name="slug">required.</param>
        /// <param name="lang">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The category.</returns>
        public Task<CategoryResponse> SuggestionAsync(string slug, string lang = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            if(lang != null) parameters.Add("lang", lang);
            return this.Tokens.AccessParameterReservedApiAsync<CategoryResponse>(MethodType.Get, "users/suggestions/{slug}", new [] { "slug" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> SuggestedMembers(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiArray<User>(MethodType.Get, "users/suggestions/{slug}/members", new [] { "slug" }, InternalUtils.ExpressionsToDictionary(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> SuggestedMembers(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessParameterReservedApiArray<User>(MethodType.Get, "users/suggestions/{slug}/members", new [] { "slug" }, parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> SuggestedMembers(object parameters)
        {
            return this.Tokens.AccessParameterReservedApiArray<User>(MethodType.Get, "users/suggestions/{slug}/members", new [] { "slug" }, InternalUtils.ResolveObject(parameters), urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list.</para>
        /// </summary>
        /// <param name="slug">required.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> SuggestedMembers(string slug)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            return this.Tokens.AccessParameterReservedApiArray<User>(MethodType.Get, "users/suggestions/{slug}/members", new [] { "slug" }, parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> SuggestedMembersAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiArrayAsync<User>(MethodType.Get, "users/suggestions/{slug}/members", new [] { "slug" }, InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> SuggestedMembersAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiArrayAsync<User>(MethodType.Get, "users/suggestions/{slug}/members", new [] { "slug" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> SuggestedMembersAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiArrayAsync<User>(MethodType.Get, "users/suggestions/{slug}/members", new [] { "slug" }, InternalUtils.ResolveObject(parameters), cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list.</para>
        /// </summary>
        /// <param name="slug">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> SuggestedMembersAsync(string slug, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            parameters.Add("slug", slug);
            return this.Tokens.AccessParameterReservedApiArrayAsync<User>(MethodType.Get, "users/suggestions/{slug}/members", new [] { "slug" }, parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Report the specified user as a spam account to Twitter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse ReportSpam(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "users/report_spam", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Report the specified user as a spam account to Twitter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse ReportSpam(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "users/report_spam", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Report the specified user as a spam account to Twitter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse ReportSpam(object parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "users/report_spam", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Report the specified user as a spam account to Twitter.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse ReportSpam(string screen_name, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "users/report_spam", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Report the specified user as a spam account to Twitter.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse ReportSpam(long user_id, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "users/report_spam", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Report the specified user as a spam account to Twitter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ReportSpamAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "users/report_spam", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Report the specified user as a spam account to Twitter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ReportSpamAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "users/report_spam", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Report the specified user as a spam account to Twitter.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_ext_alt_text (optional)</para>
        /// <para>- <c>TweetMode</c> tweet_mode (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ReportSpamAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "users/report_spam", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Report the specified user as a spam account to Twitter.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ReportSpamAsync(string screen_name, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            parameters.Add("screen_name", screen_name);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "users/report_spam", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Report the specified user as a spam account to Twitter.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_ext_alt_text">optional.</param>
        /// <param name="tweet_mode">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ReportSpamAsync(long user_id, bool? include_ext_alt_text = null, TweetMode? tweet_mode = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_ext_alt_text != null) parameters.Add("include_ext_alt_text", include_ext_alt_text);
            if(tweet_mode != null) parameters.Add("tweet_mode", tweet_mode);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "users/report_spam", parameters, cancellationToken, urlPrefix: "1.1");
        }

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET/POST direct_messages/welcome_messages.
    /// </summary>
    public partial class WelcomeMessages : ApiProviderBase
    {
        internal WelcomeMessages(TokensBase e) : base(e) { }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Creates a new Welcome Message that will be stored and sent in the future from the authenticating user in defined circumstances.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> text (required)</para>
        /// <para>- <c>QuickReply</c> quick_reply (optional)</para>
        /// <para>- <c>string</c> attachment_type (optional)</para>
        /// <para>- <c>long</c> attachment_media_id (optional)</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The message template.</returns>
        public WelcomeMessageResponse New(params Expression<Func<string, object>>[] parameters)
        {
            var jm = new string[10];
            jm[0] = "{\"welcome_message\" : {";
            jm[1] = "\"name\": $name,";
            jm[2] = "\"message_data\": {";
            jm[3] = "\"text\": $text,";
            jm[4] = "\"quick_reply\": $quick_reply,";
            jm[5] = "\"attachment\": {";
            jm[6] = "\"type\": $attachment_type,";
            jm[7] = "\"media\": {";
            jm[8] = "\"id\": $attachment_media_id";
            jm[9] = "}}}}}";
            return this.Tokens.AccessJsonParameteredApi<WelcomeMessageResponse>("direct_messages/welcome_messages/new", parameters, jm, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Creates a new Welcome Message that will be stored and sent in the future from the authenticating user in defined circumstances.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> text (required)</para>
        /// <para>- <c>QuickReply</c> quick_reply (optional)</para>
        /// <para>- <c>string</c> attachment_type (optional)</para>
        /// <para>- <c>long</c> attachment_media_id (optional)</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The message template.</returns>
        public WelcomeMessageResponse New(IDictionary<string, object> parameters)
        {
            var jm = new string[10];
            jm[0] = "{\"welcome_message\" : {";
            jm[1] = "\"name\": $name,";
            jm[2] = "\"message_data\": {";
            jm[3] = "\"text\": $text,";
            jm[4] = "\"quick_reply\": $quick_reply,";
            jm[5] = "\"attachment\": {";
            jm[6] = "\"type\": $attachment_type,";
            jm[7] = "\"media\": {";
            jm[8] = "\"id\": $attachment_media_id";
            jm[9] = "}}}}}";
            return this.Tokens.AccessJsonParameteredApi<WelcomeMessageResponse>("direct_messages/welcome_messages/new", parameters, jm, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Creates a new Welcome Message that will be stored and sent in the future from the authenticating user in defined circumstances.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> text (required)</para>
        /// <para>- <c>QuickReply</c> quick_reply (optional)</para>
        /// <para>- <c>string</c> attachment_type (optional)</para>
        /// <para>- <c>long</c> attachment_media_id (optional)</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The message template.</returns>
        public WelcomeMessageResponse New(object parameters)
        {
            var jm = new string[10];
            jm[0] = "{\"welcome_message\" : {";
            jm[1] = "\"name\": $name,";
            jm[2] = "\"message_data\": {";
            jm[3] = "\"text\": $text,";
            jm[4] = "\"quick_reply\": $quick_reply,";
            jm[5] = "\"attachment\": {";
            jm[6] = "\"type\": $attachment_type,";
            jm[7] = "\"media\": {";
            jm[8] = "\"id\": $attachment_media_id";
            jm[9] = "}}}}}";
            return this.Tokens.AccessJsonParameteredApi<WelcomeMessageResponse>("direct_messages/welcome_messages/new", parameters, jm, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Creates a new Welcome Message that will be stored and sent in the future from the authenticating user in defined circumstances.</para>
        /// </summary>
        /// <param name="text">required.</param>
        /// <param name="quick_reply">optional.</param>
        /// <param name="attachment_type">optional.</param>
        /// <param name="attachment_media_id">optional.</param>
        /// <param name="name">optional.</param>
        /// <returns>The message template.</returns>
        public WelcomeMessageResponse New(string text, QuickReply quick_reply = null, string attachment_type = null, long? attachment_media_id = null, string name = null)
        {
            var jm = new string[10];
            jm[0] = "{\"welcome_message\" : {";
            jm[1] = "\"name\": $name,";
            jm[2] = "\"message_data\": {";
            jm[3] = "\"text\": $text,";
            jm[4] = "\"quick_reply\": $quick_reply,";
            jm[5] = "\"attachment\": {";
            jm[6] = "\"type\": $attachment_type,";
            jm[7] = "\"media\": {";
            jm[8] = "\"id\": $attachment_media_id";
            jm[9] = "}}}}}";
            var parameters = new Dictionary<string, object>();
            if(text == null) throw new ArgumentNullException("text");
            parameters.Add("text", text);
            if(quick_reply != null) parameters.Add("quick_reply", quick_reply);
            if(attachment_type != null) parameters.Add("attachment_type", attachment_type);
            if(attachment_media_id != null) parameters.Add("attachment_media_id", attachment_media_id);
            if(name != null) parameters.Add("name", name);
            return this.Tokens.AccessJsonParameteredApi<WelcomeMessageResponse>("direct_messages/welcome_messages/new", parameters, jm, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Creates a new Welcome Message that will be stored and sent in the future from the authenticating user in defined circumstances.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> text (required)</para>
        /// <para>- <c>QuickReply</c> quick_reply (optional)</para>
        /// <para>- <c>string</c> attachment_type (optional)</para>
        /// <para>- <c>long</c> attachment_media_id (optional)</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The message template.</returns>
        public Task<WelcomeMessageResponse> NewAsync(params Expression<Func<string, object>>[] parameters)
        {
            var jm = new string[10];
            jm[0] = "{\"welcome_message\" : {";
            jm[1] = "\"name\": $name,";
            jm[2] = "\"message_data\": {";
            jm[3] = "\"text\": $text,";
            jm[4] = "\"quick_reply\": $quick_reply,";
            jm[5] = "\"attachment\": {";
            jm[6] = "\"type\": $attachment_type,";
            jm[7] = "\"media\": {";
            jm[8] = "\"id\": $attachment_media_id";
            jm[9] = "}}}}}";
            return this.Tokens.AccessJsonParameteredApiAsync<WelcomeMessageResponse>("direct_messages/welcome_messages/new", parameters, jm, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Creates a new Welcome Message that will be stored and sent in the future from the authenticating user in defined circumstances.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> text (required)</para>
        /// <para>- <c>QuickReply</c> quick_reply (optional)</para>
        /// <para>- <c>string</c> attachment_type (optional)</para>
        /// <para>- <c>long</c> attachment_media_id (optional)</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The message template.</returns>
        public Task<WelcomeMessageResponse> NewAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            var jm = new string[10];
            jm[0] = "{\"welcome_message\" : {";
            jm[1] = "\"name\": $name,";
            jm[2] = "\"message_data\": {";
            jm[3] = "\"text\": $text,";
            jm[4] = "\"quick_reply\": $quick_reply,";
            jm[5] = "\"attachment\": {";
            jm[6] = "\"type\": $attachment_type,";
            jm[7] = "\"media\": {";
            jm[8] = "\"id\": $attachment_media_id";
            jm[9] = "}}}}}";
            return this.Tokens.AccessJsonParameteredApiAsync<WelcomeMessageResponse>("direct_messages/welcome_messages/new", parameters, jm, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Creates a new Welcome Message that will be stored and sent in the future from the authenticating user in defined circumstances.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> text (required)</para>
        /// <para>- <c>QuickReply</c> quick_reply (optional)</para>
        /// <para>- <c>string</c> attachment_type (optional)</para>
        /// <para>- <c>long</c> attachment_media_id (optional)</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The message template.</returns>
        public Task<WelcomeMessageResponse> NewAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            var jm = new string[10];
            jm[0] = "{\"welcome_message\" : {";
            jm[1] = "\"name\": $name,";
            jm[2] = "\"message_data\": {";
            jm[3] = "\"text\": $text,";
            jm[4] = "\"quick_reply\": $quick_reply,";
            jm[5] = "\"attachment\": {";
            jm[6] = "\"type\": $attachment_type,";
            jm[7] = "\"media\": {";
            jm[8] = "\"id\": $attachment_media_id";
            jm[9] = "}}}}}";
            return this.Tokens.AccessJsonParameteredApiAsync<WelcomeMessageResponse>("direct_messages/welcome_messages/new", parameters, jm, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Creates a new Welcome Message that will be stored and sent in the future from the authenticating user in defined circumstances.</para>
        /// </summary>
        /// <param name="text">required.</param>
        /// <param name="quick_reply">optional.</param>
        /// <param name="attachment_type">optional.</param>
        /// <param name="attachment_media_id">optional.</param>
        /// <param name="name">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The message template.</returns>
        public Task<WelcomeMessageResponse> NewAsync(string text, QuickReply quick_reply = null, string attachment_type = null, long? attachment_media_id = null, string name = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var jm = new string[10];
            jm[0] = "{\"welcome_message\" : {";
            jm[1] = "\"name\": $name,";
            jm[2] = "\"message_data\": {";
            jm[3] = "\"text\": $text,";
            jm[4] = "\"quick_reply\": $quick_reply,";
            jm[5] = "\"attachment\": {";
            jm[6] = "\"type\": $attachment_type,";
            jm[7] = "\"media\": {";
            jm[8] = "\"id\": $attachment_media_id";
            jm[9] = "}}}}}";
            var parameters = new Dictionary<string, object>();
            if(text == null) throw new ArgumentNullException("text");
            parameters.Add("text", text);
            if(quick_reply != null) parameters.Add("quick_reply", quick_reply);
            if(attachment_type != null) parameters.Add("attachment_type", attachment_type);
            if(attachment_media_id != null) parameters.Add("attachment_media_id", attachment_media_id);
            if(name != null) parameters.Add("name", name);
            return this.Tokens.AccessJsonParameteredApiAsync<WelcomeMessageResponse>("direct_messages/welcome_messages/new", parameters, jm, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a list of Welcome Messages.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Welcome Messages.</returns>
        public CursoredWelcomeMessages List(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<CursoredWelcomeMessages>(MethodType.Get, "direct_messages/welcome_messages/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a list of Welcome Messages.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Welcome Messages.</returns>
        public CursoredWelcomeMessages List(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<CursoredWelcomeMessages>(MethodType.Get, "direct_messages/welcome_messages/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a list of Welcome Messages.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Welcome Messages.</returns>
        public CursoredWelcomeMessages List(object parameters)
        {
            return this.Tokens.AccessApi<CursoredWelcomeMessages>(MethodType.Get, "direct_messages/welcome_messages/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a list of Welcome Messages.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <returns>The Welcome Messages.</returns>
        public CursoredWelcomeMessages List(int? count = null, string cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApi<CursoredWelcomeMessages>(MethodType.Get, "direct_messages/welcome_messages/list", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns a list of Welcome Messages.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Welcome Messages.</returns>
        public Task<CursoredWelcomeMessages> ListAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<CursoredWelcomeMessages>(MethodType.Get, "direct_messages/welcome_messages/list", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a list of Welcome Messages.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The Welcome Messages.</returns>
        public Task<CursoredWelcomeMessages> ListAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<CursoredWelcomeMessages>(MethodType.Get, "direct_messages/welcome_messages/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a list of Welcome Messages.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The Welcome Messages.</returns>
        public Task<CursoredWelcomeMessages> ListAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<CursoredWelcomeMessages>(MethodType.Get, "direct_messages/welcome_messages/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a list of Welcome Messages.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The Welcome Messages.</returns>
        public Task<CursoredWelcomeMessages> ListAsync(int? count = null, string cursor = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApiAsync<CursoredWelcomeMessages>(MethodType.Get, "direct_messages/welcome_messages/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a Welcome Message by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Welcome Message.</returns>
        public WelcomeMessageResponse Show(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<WelcomeMessageResponse>(MethodType.Get, "direct_messages/welcome_messages/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a Welcome Message by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Welcome Message.</returns>
        public WelcomeMessageResponse Show(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<WelcomeMessageResponse>(MethodType.Get, "direct_messages/welcome_messages/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a Welcome Message by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Welcome Message.</returns>
        public WelcomeMessageResponse Show(object parameters)
        {
            return this.Tokens.AccessApi<WelcomeMessageResponse>(MethodType.Get, "direct_messages/welcome_messages/show", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a Welcome Message by the given id.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <returns>The Welcome Message.</returns>
        public WelcomeMessageResponse Show(string id)
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            return this.Tokens.AccessApi<WelcomeMessageResponse>(MethodType.Get, "direct_messages/welcome_messages/show", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns a Welcome Message by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Welcome Message.</returns>
        public Task<WelcomeMessageResponse> ShowAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<WelcomeMessageResponse>(MethodType.Get, "direct_messages/welcome_messages/show", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a Welcome Message by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The Welcome Message.</returns>
        public Task<WelcomeMessageResponse> ShowAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<WelcomeMessageResponse>(MethodType.Get, "direct_messages/welcome_messages/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a Welcome Message by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The Welcome Message.</returns>
        public Task<WelcomeMessageResponse> ShowAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<WelcomeMessageResponse>(MethodType.Get, "direct_messages/welcome_messages/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a Welcome Message by the given id.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The Welcome Message.</returns>
        public Task<WelcomeMessageResponse> ShowAsync(string id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            return this.Tokens.AccessApiAsync<WelcomeMessageResponse>(MethodType.Get, "direct_messages/welcome_messages/show", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Deletes a Welcome Message by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void Destroy(params Expression<Func<string, object>>[] parameters)
        {
            this.Tokens.AccessApiNoResponse(MethodType.Delete, "direct_messages/welcome_messages/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Deletes a Welcome Message by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void Destroy(IDictionary<string, object> parameters)
        {
            this.Tokens.AccessApiNoResponse(MethodType.Delete, "direct_messages/welcome_messages/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Deletes a Welcome Message by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void Destroy(object parameters)
        {
            this.Tokens.AccessApiNoResponse(MethodType.Delete, "direct_messages/welcome_messages/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Deletes a Welcome Message by the given id.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <returns></returns>
        public void Destroy(string id)
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            this.Tokens.AccessApiNoResponse(MethodType.Delete, "direct_messages/welcome_messages/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Deletes a Welcome Message by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public Task DestroyAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiNoResponseAsync(MethodType.Delete, "direct_messages/welcome_messages/destroy", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Deletes a Welcome Message by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task DestroyAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiNoResponseAsync(MethodType.Delete, "direct_messages/welcome_messages/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Deletes a Welcome Message by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task DestroyAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiNoResponseAsync(MethodType.Delete, "direct_messages/welcome_messages/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Deletes a Welcome Message by the given id.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task DestroyAsync(string id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            return this.Tokens.AccessApiNoResponseAsync(MethodType.Delete, "direct_messages/welcome_messages/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET/POST direct_messages/welcome_messages/Rules.
    /// </summary>
    public partial class WelcomeMessagesRules : ApiProviderBase
    {
        internal WelcomeMessagesRules(TokensBase e) : base(e) { }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Creates a new Welcome Message Rule that determines which Welcome Message will be shown in a given conversation.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> welcome_message_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The created Welcome Message Rule.</returns>
        public WelcomeMessageRuleResponse New(params Expression<Func<string, object>>[] parameters)
        {
            var jm = new string[3];
            jm[0] = "{\"welcome_message_rule\": {";
            jm[1] = "\"welcome_message_id\": $welcome_message_id";
            jm[2] = "}}";
            return this.Tokens.AccessJsonParameteredApi<WelcomeMessageRuleResponse>("direct_messages/welcome_messages/rules/new", parameters, jm, jsonPath: "welcome_message_rule", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Creates a new Welcome Message Rule that determines which Welcome Message will be shown in a given conversation.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> welcome_message_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The created Welcome Message Rule.</returns>
        public WelcomeMessageRuleResponse New(IDictionary<string, object> parameters)
        {
            var jm = new string[3];
            jm[0] = "{\"welcome_message_rule\": {";
            jm[1] = "\"welcome_message_id\": $welcome_message_id";
            jm[2] = "}}";
            return this.Tokens.AccessJsonParameteredApi<WelcomeMessageRuleResponse>("direct_messages/welcome_messages/rules/new", parameters, jm, jsonPath: "welcome_message_rule", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Creates a new Welcome Message Rule that determines which Welcome Message will be shown in a given conversation.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> welcome_message_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The created Welcome Message Rule.</returns>
        public WelcomeMessageRuleResponse New(object parameters)
        {
            var jm = new string[3];
            jm[0] = "{\"welcome_message_rule\": {";
            jm[1] = "\"welcome_message_id\": $welcome_message_id";
            jm[2] = "}}";
            return this.Tokens.AccessJsonParameteredApi<WelcomeMessageRuleResponse>("direct_messages/welcome_messages/rules/new", parameters, jm, jsonPath: "welcome_message_rule", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Creates a new Welcome Message Rule that determines which Welcome Message will be shown in a given conversation.</para>
        /// </summary>
        /// <param name="welcome_message_id">required.</param>
        /// <returns>The created Welcome Message Rule.</returns>
        public WelcomeMessageRuleResponse New(string welcome_message_id)
        {
            var jm = new string[3];
            jm[0] = "{\"welcome_message_rule\": {";
            jm[1] = "\"welcome_message_id\": $welcome_message_id";
            jm[2] = "}}";
            var parameters = new Dictionary<string, object>();
            if(welcome_message_id == null) throw new ArgumentNullException("welcome_message_id");
            parameters.Add("welcome_message_id", welcome_message_id);
            return this.Tokens.AccessJsonParameteredApi<WelcomeMessageRuleResponse>("direct_messages/welcome_messages/rules/new", parameters, jm, jsonPath: "welcome_message_rule", urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Creates a new Welcome Message Rule that determines which Welcome Message will be shown in a given conversation.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> welcome_message_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The created Welcome Message Rule.</returns>
        public Task<WelcomeMessageRuleResponse> NewAsync(params Expression<Func<string, object>>[] parameters)
        {
            var jm = new string[3];
            jm[0] = "{\"welcome_message_rule\": {";
            jm[1] = "\"welcome_message_id\": $welcome_message_id";
            jm[2] = "}}";
            return this.Tokens.AccessJsonParameteredApiAsync<WelcomeMessageRuleResponse>("direct_messages/welcome_messages/rules/new", parameters, jm, jsonPath: "welcome_message_rule", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Creates a new Welcome Message Rule that determines which Welcome Message will be shown in a given conversation.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> welcome_message_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The created Welcome Message Rule.</returns>
        public Task<WelcomeMessageRuleResponse> NewAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            var jm = new string[3];
            jm[0] = "{\"welcome_message_rule\": {";
            jm[1] = "\"welcome_message_id\": $welcome_message_id";
            jm[2] = "}}";
            return this.Tokens.AccessJsonParameteredApiAsync<WelcomeMessageRuleResponse>("direct_messages/welcome_messages/rules/new", parameters, jm, cancellationToken, jsonPath: "welcome_message_rule", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Creates a new Welcome Message Rule that determines which Welcome Message will be shown in a given conversation.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> welcome_message_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The created Welcome Message Rule.</returns>
        public Task<WelcomeMessageRuleResponse> NewAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            var jm = new string[3];
            jm[0] = "{\"welcome_message_rule\": {";
            jm[1] = "\"welcome_message_id\": $welcome_message_id";
            jm[2] = "}}";
            return this.Tokens.AccessJsonParameteredApiAsync<WelcomeMessageRuleResponse>("direct_messages/welcome_messages/rules/new", parameters, jm, cancellationToken, jsonPath: "welcome_message_rule", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Creates a new Welcome Message Rule that determines which Welcome Message will be shown in a given conversation.</para>
        /// </summary>
        /// <param name="welcome_message_id">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The created Welcome Message Rule.</returns>
        public Task<WelcomeMessageRuleResponse> NewAsync(string welcome_message_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var jm = new string[3];
            jm[0] = "{\"welcome_message_rule\": {";
            jm[1] = "\"welcome_message_id\": $welcome_message_id";
            jm[2] = "}}";
            var parameters = new Dictionary<string, object>();
            if(welcome_message_id == null) throw new ArgumentNullException("welcome_message_id");
            parameters.Add("welcome_message_id", welcome_message_id);
            return this.Tokens.AccessJsonParameteredApiAsync<WelcomeMessageRuleResponse>("direct_messages/welcome_messages/rules/new", parameters, jm, cancellationToken, jsonPath: "welcome_message_rule", urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a list of Welcome Message Rules.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Welcome Message Rules.</returns>
        public CursoredWelcomeMessageRules List(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<CursoredWelcomeMessageRules>(MethodType.Get, "direct_messages/welcome_messages/rules/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a list of Welcome Message Rules.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Welcome Message Rules.</returns>
        public CursoredWelcomeMessageRules List(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<CursoredWelcomeMessageRules>(MethodType.Get, "direct_messages/welcome_messages/rules/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a list of Welcome Message Rules.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Welcome Message Rules.</returns>
        public CursoredWelcomeMessageRules List(object parameters)
        {
            return this.Tokens.AccessApi<CursoredWelcomeMessageRules>(MethodType.Get, "direct_messages/welcome_messages/rules/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a list of Welcome Message Rules.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <returns>The Welcome Message Rules.</returns>
        public IEnumerable<WelcomeMessageRule> EnumerateList(int? count = null, string cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return Cursored.EnumerateForward<CursoredWelcomeMessageRules, WelcomeMessageRule>(this.Tokens, "direct_messages/welcome_messages/rules/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a list of Welcome Message Rules.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <returns>The Welcome Message Rules.</returns>
        public CursoredWelcomeMessageRules List(int? count = null, string cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApi<CursoredWelcomeMessageRules>(MethodType.Get, "direct_messages/welcome_messages/rules/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a list of Welcome Message Rules.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Welcome Message Rules.</returns>
        public IEnumerable<WelcomeMessageRule> EnumerateList(params Expression<Func<string, object>>[] parameters)
        {
            return Cursored.EnumerateForward<CursoredWelcomeMessageRules, WelcomeMessageRule>(this.Tokens, "direct_messages/welcome_messages/rules/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a list of Welcome Message Rules.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Welcome Message Rules.</returns>
        public IEnumerable<WelcomeMessageRule> EnumerateList(IDictionary<string, object> parameters)
        {
            return Cursored.EnumerateForward<CursoredWelcomeMessageRules, WelcomeMessageRule>(this.Tokens, "direct_messages/welcome_messages/rules/list", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a list of Welcome Message Rules.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Welcome Message Rules.</returns>
        public IEnumerable<WelcomeMessageRule> EnumerateList(object parameters)
        {
            return Cursored.EnumerateForward<CursoredWelcomeMessageRules, WelcomeMessageRule>(this.Tokens, "direct_messages/welcome_messages/rules/list", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns a list of Welcome Message Rules.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Welcome Message Rules.</returns>
        public Task<CursoredWelcomeMessageRules> ListAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<CursoredWelcomeMessageRules>(MethodType.Get, "direct_messages/welcome_messages/rules/list", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a list of Welcome Message Rules.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The Welcome Message Rules.</returns>
        public Task<CursoredWelcomeMessageRules> ListAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<CursoredWelcomeMessageRules>(MethodType.Get, "direct_messages/welcome_messages/rules/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a list of Welcome Message Rules.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The Welcome Message Rules.</returns>
        public Task<CursoredWelcomeMessageRules> ListAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<CursoredWelcomeMessageRules>(MethodType.Get, "direct_messages/welcome_messages/rules/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a list of Welcome Message Rules.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The Welcome Message Rules.</returns>
        public Task<CursoredWelcomeMessageRules> ListAsync(int? count = null, string cursor = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApiAsync<CursoredWelcomeMessageRules>(MethodType.Get, "direct_messages/welcome_messages/rules/list", parameters, cancellationToken, urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a Welcome Message Rule by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Welcome Message Rule.</returns>
        public WelcomeMessageRuleResponse Show(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<WelcomeMessageRuleResponse>(MethodType.Get, "direct_messages/welcome_messages/rules/show", parameters, jsonPath: "welcome_message_rule", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a Welcome Message Rule by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Welcome Message Rule.</returns>
        public WelcomeMessageRuleResponse Show(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<WelcomeMessageRuleResponse>(MethodType.Get, "direct_messages/welcome_messages/rules/show", parameters, jsonPath: "welcome_message_rule", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a Welcome Message Rule by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Welcome Message Rule.</returns>
        public WelcomeMessageRuleResponse Show(object parameters)
        {
            return this.Tokens.AccessApi<WelcomeMessageRuleResponse>(MethodType.Get, "direct_messages/welcome_messages/rules/show", parameters, jsonPath: "welcome_message_rule", urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a Welcome Message Rule by the given id.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <returns>The Welcome Message Rule.</returns>
        public WelcomeMessageRuleResponse Show(string id)
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            return this.Tokens.AccessApi<WelcomeMessageRuleResponse>(MethodType.Get, "direct_messages/welcome_messages/rules/show", parameters, jsonPath: "welcome_message_rule", urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Returns a Welcome Message Rule by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Welcome Message Rule.</returns>
        public Task<WelcomeMessageRuleResponse> ShowAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<WelcomeMessageRuleResponse>(MethodType.Get, "direct_messages/welcome_messages/rules/show", parameters, jsonPath: "welcome_message_rule", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a Welcome Message Rule by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The Welcome Message Rule.</returns>
        public Task<WelcomeMessageRuleResponse> ShowAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<WelcomeMessageRuleResponse>(MethodType.Get, "direct_messages/welcome_messages/rules/show", parameters, cancellationToken, jsonPath: "welcome_message_rule", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a Welcome Message Rule by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The Welcome Message Rule.</returns>
        public Task<WelcomeMessageRuleResponse> ShowAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<WelcomeMessageRuleResponse>(MethodType.Get, "direct_messages/welcome_messages/rules/show", parameters, cancellationToken, jsonPath: "welcome_message_rule", urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Returns a Welcome Message Rule by the given id.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The Welcome Message Rule.</returns>
        public Task<WelcomeMessageRuleResponse> ShowAsync(string id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            return this.Tokens.AccessApiAsync<WelcomeMessageRuleResponse>(MethodType.Get, "direct_messages/welcome_messages/rules/show", parameters, cancellationToken, jsonPath: "welcome_message_rule", urlPrefix: "1.1");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Deletes a Welcome Message Rule by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void Destroy(params Expression<Func<string, object>>[] parameters)
        {
            this.Tokens.AccessApiNoResponse(MethodType.Delete, "direct_messages/welcome_messages/rules/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Deletes a Welcome Message Rule by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void Destroy(IDictionary<string, object> parameters)
        {
            this.Tokens.AccessApiNoResponse(MethodType.Delete, "direct_messages/welcome_messages/rules/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Deletes a Welcome Message Rule by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void Destroy(object parameters)
        {
            this.Tokens.AccessApiNoResponse(MethodType.Delete, "direct_messages/welcome_messages/rules/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Deletes a Welcome Message Rule by the given id.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <returns></returns>
        public void Destroy(string id)
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            this.Tokens.AccessApiNoResponse(MethodType.Delete, "direct_messages/welcome_messages/rules/destroy", parameters, urlPrefix: "1.1");
        }
        #endif

        /// <summary>
        /// <para>Deletes a Welcome Message Rule by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public Task DestroyAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiNoResponseAsync(MethodType.Delete, "direct_messages/welcome_messages/rules/destroy", parameters, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Deletes a Welcome Message Rule by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task DestroyAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiNoResponseAsync(MethodType.Delete, "direct_messages/welcome_messages/rules/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Deletes a Welcome Message Rule by the given id.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task DestroyAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiNoResponseAsync(MethodType.Delete, "direct_messages/welcome_messages/rules/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

        /// <summary>
        /// <para>Deletes a Welcome Message Rule by the given id.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task DestroyAsync(string id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            return this.Tokens.AccessApiNoResponseAsync(MethodType.Delete, "direct_messages/welcome_messages/rules/destroy", parameters, cancellationToken, urlPrefix: "1.1");
        }

    }

}
namespace CoreTweet.V2
{
    /// <summary>
    /// Provides a set of methods for the wrapper of Filtered stream v1 API on Twitter API v2.
    /// </summary>
    public partial class FilteredStreamApi : ApiProviderBase
    {
        internal FilteredStreamApi(TokensBase e) : base(e) { }

        #if true
        /// <summary>
        /// <para>Streams Tweets in real-time based on a specific set of filter rules.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>TweetExpansions</c> expansions (optional)</para>
        /// <para>- <c>MediaFields</c> media_fields (optional, query string: <c>"media.fields"</c>)</para>
        /// <para>- <c>PlaceFields</c> place_fields (optional, query string: <c>"place.fields"</c>)</para>
        /// <para>- <c>PollFields</c> poll_fields (optional, query string: <c>"poll.fields"</c>)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public LineDelimitedJsonStreamResponseStreamer<FilterStreamResponse> Filter(params Expression<Func<string, object>>[] parameters)
        {
            return this.FilterImpl(InternalUtils.ExpressionsToDictionary(parameters).Select(x => new KeyValuePair<string, object>(x.Key == "media_fields" ? "media.fields" : x.Key == "place_fields" ? "place.fields" : x.Key == "poll_fields" ? "poll.fields" : x.Key == "tweet_fields" ? "tweet.fields" : x.Key == "user_fields" ? "user.fields" : x.Key, x.Value)), "2", "");
        }
        #endif

        #if true
        /// <summary>
        /// <para>Streams Tweets in real-time based on a specific set of filter rules.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>TweetExpansions</c> expansions (optional)</para>
        /// <para>- <c>MediaFields</c> media_fields (optional, query string: <c>"media.fields"</c>)</para>
        /// <para>- <c>PlaceFields</c> place_fields (optional, query string: <c>"place.fields"</c>)</para>
        /// <para>- <c>PollFields</c> poll_fields (optional, query string: <c>"poll.fields"</c>)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public LineDelimitedJsonStreamResponseStreamer<FilterStreamResponse> Filter(IDictionary<string, object> parameters)
        {
            return this.FilterImpl(parameters, "2", "");
        }
        #endif

        #if true
        /// <summary>
        /// <para>Streams Tweets in real-time based on a specific set of filter rules.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>TweetExpansions</c> expansions (optional)</para>
        /// <para>- <c>MediaFields</c> media_fields (optional, query string: <c>"media.fields"</c>)</para>
        /// <para>- <c>PlaceFields</c> place_fields (optional, query string: <c>"place.fields"</c>)</para>
        /// <para>- <c>PollFields</c> poll_fields (optional, query string: <c>"poll.fields"</c>)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public LineDelimitedJsonStreamResponseStreamer<FilterStreamResponse> Filter(object parameters)
        {
            return this.FilterImpl(InternalUtils.ResolveObject(parameters), "2", "");
        }
        #endif

        #if true
        /// <summary>
        /// <para>Streams Tweets in real-time based on a specific set of filter rules.</para>
        /// </summary>
        /// <param name="expansions">optional.</param>
        /// <param name="media_fields">optional.</param>
        /// <param name="place_fields">optional.</param>
        /// <param name="poll_fields">optional.</param>
        /// <param name="tweet_fields">optional.</param>
        /// <param name="user_fields">optional.</param>
        /// <returns></returns>
        public LineDelimitedJsonStreamResponseStreamer<FilterStreamResponse> Filter(TweetExpansions? expansions = null, MediaFields? media_fields = null, PlaceFields? place_fields = null, PollFields? poll_fields = null, TweetFields? tweet_fields = null, UserFields? user_fields = null)
        {
            var parameters = new Dictionary<string, object>();
            if(expansions != null) parameters.Add("expansions", expansions);
            if(media_fields != null) parameters.Add("media.fields", media_fields);
            if(place_fields != null) parameters.Add("place.fields", place_fields);
            if(poll_fields != null) parameters.Add("poll.fields", poll_fields);
            if(tweet_fields != null) parameters.Add("tweet.fields", tweet_fields);
            if(user_fields != null) parameters.Add("user.fields", user_fields);
            return this.FilterImpl(parameters, "2", "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Return a list of filter rules currently active on the streaming endpoint, either as a list or individually.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> ids (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The rules.</returns>
        public FilterRulesGetResponse GetRules(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<FilterRulesGetResponse>(MethodType.Get, "tweets/search/stream/rules", parameters, urlPrefix: "2", urlSuffix: "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Return a list of filter rules currently active on the streaming endpoint, either as a list or individually.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> ids (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The rules.</returns>
        public FilterRulesGetResponse GetRules(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<FilterRulesGetResponse>(MethodType.Get, "tweets/search/stream/rules", parameters, urlPrefix: "2", urlSuffix: "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Return a list of filter rules currently active on the streaming endpoint, either as a list or individually.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> ids (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The rules.</returns>
        public FilterRulesGetResponse GetRules(object parameters)
        {
            return this.Tokens.AccessApi<FilterRulesGetResponse>(MethodType.Get, "tweets/search/stream/rules", parameters, urlPrefix: "2", urlSuffix: "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Return a list of filter rules currently active on the streaming endpoint, either as a list or individually.</para>
        /// </summary>
        /// <param name="ids">optional.</param>
        /// <returns>The rules.</returns>
        public FilterRulesGetResponse GetRules(IEnumerable<long> ids = null)
        {
            var parameters = new Dictionary<string, object>();
            if(ids != null) parameters.Add("ids", ids);
            return this.Tokens.AccessApi<FilterRulesGetResponse>(MethodType.Get, "tweets/search/stream/rules", parameters, urlPrefix: "2", urlSuffix: "");
        }
        #endif

        /// <summary>
        /// <para>Return a list of filter rules currently active on the streaming endpoint, either as a list or individually.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> ids (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The rules.</returns>
        public Task<FilterRulesGetResponse> GetRulesAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<FilterRulesGetResponse>(MethodType.Get, "tweets/search/stream/rules", parameters, urlPrefix: "2", urlSuffix: "");
        }

        /// <summary>
        /// <para>Return a list of filter rules currently active on the streaming endpoint, either as a list or individually.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> ids (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The rules.</returns>
        public Task<FilterRulesGetResponse> GetRulesAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<FilterRulesGetResponse>(MethodType.Get, "tweets/search/stream/rules", parameters, cancellationToken, urlPrefix: "2", urlSuffix: "");
        }

        /// <summary>
        /// <para>Return a list of filter rules currently active on the streaming endpoint, either as a list or individually.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> ids (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The rules.</returns>
        public Task<FilterRulesGetResponse> GetRulesAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<FilterRulesGetResponse>(MethodType.Get, "tweets/search/stream/rules", parameters, cancellationToken, urlPrefix: "2", urlSuffix: "");
        }

        /// <summary>
        /// <para>Return a list of filter rules currently active on the streaming endpoint, either as a list or individually.</para>
        /// </summary>
        /// <param name="ids">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The rules.</returns>
        public Task<FilterRulesGetResponse> GetRulesAsync(IEnumerable<long> ids = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(ids != null) parameters.Add("ids", ids);
            return this.Tokens.AccessApiAsync<FilterRulesGetResponse>(MethodType.Get, "tweets/search/stream/rules", parameters, cancellationToken, urlPrefix: "2", urlSuffix: "");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Creates filter rules. To create one or more rules, submit an add payload as an array of rules and operators.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;FilterRule&gt;</c> add (required)</para>
        /// <para>- <c>bool</c> dry_run (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The result of the request.</returns>
        public FilterRulesPostCreateResponse CreateRules(params Expression<Func<string, object>>[] parameters)
        {
            var jm = new string[3];
            jm[0] = "{";
            jm[1] = "\"add\": $add";
            jm[2] = "}";
            return this.Tokens.AccessJsonParameteredApi<FilterRulesPostCreateResponse>("tweets/search/stream/rules", parameters, jm, urlPrefix: "2", urlSuffix: "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Creates filter rules. To create one or more rules, submit an add payload as an array of rules and operators.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;FilterRule&gt;</c> add (required)</para>
        /// <para>- <c>bool</c> dry_run (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The result of the request.</returns>
        public FilterRulesPostCreateResponse CreateRules(IDictionary<string, object> parameters)
        {
            var jm = new string[3];
            jm[0] = "{";
            jm[1] = "\"add\": $add";
            jm[2] = "}";
            return this.Tokens.AccessJsonParameteredApi<FilterRulesPostCreateResponse>("tweets/search/stream/rules", parameters, jm, urlPrefix: "2", urlSuffix: "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Creates filter rules. To create one or more rules, submit an add payload as an array of rules and operators.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;FilterRule&gt;</c> add (required)</para>
        /// <para>- <c>bool</c> dry_run (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The result of the request.</returns>
        public FilterRulesPostCreateResponse CreateRules(object parameters)
        {
            var jm = new string[3];
            jm[0] = "{";
            jm[1] = "\"add\": $add";
            jm[2] = "}";
            return this.Tokens.AccessJsonParameteredApi<FilterRulesPostCreateResponse>("tweets/search/stream/rules", parameters, jm, urlPrefix: "2", urlSuffix: "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Creates filter rules. To create one or more rules, submit an add payload as an array of rules and operators.</para>
        /// </summary>
        /// <param name="add">required.</param>
        /// <param name="dry_run">optional.</param>
        /// <returns>The result of the request.</returns>
        public FilterRulesPostCreateResponse CreateRules(IEnumerable<FilterRule> add, bool? dry_run = null)
        {
            var jm = new string[3];
            jm[0] = "{";
            jm[1] = "\"add\": $add";
            jm[2] = "}";
            var parameters = new Dictionary<string, object>();
            if(add == null) throw new ArgumentNullException("add");
            parameters.Add("add", add);
            if(dry_run != null) parameters.Add("dry_run", dry_run);
            return this.Tokens.AccessJsonParameteredApi<FilterRulesPostCreateResponse>("tweets/search/stream/rules", parameters, jm, urlPrefix: "2", urlSuffix: "");
        }
        #endif

        /// <summary>
        /// <para>Creates filter rules. To create one or more rules, submit an add payload as an array of rules and operators.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;FilterRule&gt;</c> add (required)</para>
        /// <para>- <c>bool</c> dry_run (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The result of the request.</returns>
        public Task<FilterRulesPostCreateResponse> CreateRulesAsync(params Expression<Func<string, object>>[] parameters)
        {
            var jm = new string[3];
            jm[0] = "{";
            jm[1] = "\"add\": $add";
            jm[2] = "}";
            return this.Tokens.AccessJsonParameteredApiAsync<FilterRulesPostCreateResponse>("tweets/search/stream/rules", parameters, jm, urlPrefix: "2", urlSuffix: "");
        }

        /// <summary>
        /// <para>Creates filter rules. To create one or more rules, submit an add payload as an array of rules and operators.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;FilterRule&gt;</c> add (required)</para>
        /// <para>- <c>bool</c> dry_run (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The result of the request.</returns>
        public Task<FilterRulesPostCreateResponse> CreateRulesAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            var jm = new string[3];
            jm[0] = "{";
            jm[1] = "\"add\": $add";
            jm[2] = "}";
            return this.Tokens.AccessJsonParameteredApiAsync<FilterRulesPostCreateResponse>("tweets/search/stream/rules", parameters, jm, cancellationToken, urlPrefix: "2", urlSuffix: "");
        }

        /// <summary>
        /// <para>Creates filter rules. To create one or more rules, submit an add payload as an array of rules and operators.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;FilterRule&gt;</c> add (required)</para>
        /// <para>- <c>bool</c> dry_run (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The result of the request.</returns>
        public Task<FilterRulesPostCreateResponse> CreateRulesAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            var jm = new string[3];
            jm[0] = "{";
            jm[1] = "\"add\": $add";
            jm[2] = "}";
            return this.Tokens.AccessJsonParameteredApiAsync<FilterRulesPostCreateResponse>("tweets/search/stream/rules", parameters, jm, cancellationToken, urlPrefix: "2", urlSuffix: "");
        }

        /// <summary>
        /// <para>Creates filter rules. To create one or more rules, submit an add payload as an array of rules and operators.</para>
        /// </summary>
        /// <param name="add">required.</param>
        /// <param name="dry_run">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The result of the request.</returns>
        public Task<FilterRulesPostCreateResponse> CreateRulesAsync(IEnumerable<FilterRule> add, bool? dry_run = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var jm = new string[3];
            jm[0] = "{";
            jm[1] = "\"add\": $add";
            jm[2] = "}";
            var parameters = new Dictionary<string, object>();
            if(add == null) throw new ArgumentNullException("add");
            parameters.Add("add", add);
            if(dry_run != null) parameters.Add("dry_run", dry_run);
            return this.Tokens.AccessJsonParameteredApiAsync<FilterRulesPostCreateResponse>("tweets/search/stream/rules", parameters, jm, cancellationToken, urlPrefix: "2", urlSuffix: "");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Deletes filter rules. This endpoint can delete multiple rules at a time by specifying an array of IDs. If one or more rules cannot be deleted (for example, because it does not exist), the operation will not fail. In other words, only existing rules will be deleted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> ids (optional)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> values (optional)</para>
        /// <para>- <c>bool</c> dry_run (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The result of the request.</returns>
        public FilterRulesPostDeleteResponse DeleteRules(params Expression<Func<string, object>>[] parameters)
        {
            var jm = new string[4];
            jm[0] = "{\"delete\": {";
            jm[1] = "\"ids\": $ids,";
            jm[2] = "\"values\": $values";
            jm[3] = "}}";
            return this.DeleteRulesImpl(InternalUtils.ExpressionsToDictionary(parameters), jm, "2", "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Deletes filter rules. This endpoint can delete multiple rules at a time by specifying an array of IDs. If one or more rules cannot be deleted (for example, because it does not exist), the operation will not fail. In other words, only existing rules will be deleted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> ids (optional)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> values (optional)</para>
        /// <para>- <c>bool</c> dry_run (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The result of the request.</returns>
        public FilterRulesPostDeleteResponse DeleteRules(IDictionary<string, object> parameters)
        {
            var jm = new string[4];
            jm[0] = "{\"delete\": {";
            jm[1] = "\"ids\": $ids,";
            jm[2] = "\"values\": $values";
            jm[3] = "}}";
            return this.DeleteRulesImpl(parameters, jm, "2", "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Deletes filter rules. This endpoint can delete multiple rules at a time by specifying an array of IDs. If one or more rules cannot be deleted (for example, because it does not exist), the operation will not fail. In other words, only existing rules will be deleted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> ids (optional)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> values (optional)</para>
        /// <para>- <c>bool</c> dry_run (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The result of the request.</returns>
        public FilterRulesPostDeleteResponse DeleteRules(object parameters)
        {
            var jm = new string[4];
            jm[0] = "{\"delete\": {";
            jm[1] = "\"ids\": $ids,";
            jm[2] = "\"values\": $values";
            jm[3] = "}}";
            return this.DeleteRulesImpl(InternalUtils.ResolveObject(parameters), jm, "2", "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Deletes filter rules. This endpoint can delete multiple rules at a time by specifying an array of IDs. If one or more rules cannot be deleted (for example, because it does not exist), the operation will not fail. In other words, only existing rules will be deleted.</para>
        /// </summary>
        /// <param name="ids">optional.</param>
        /// <param name="values">optional.</param>
        /// <param name="dry_run">optional.</param>
        /// <returns>The result of the request.</returns>
        public FilterRulesPostDeleteResponse DeleteRules(IEnumerable<long> ids = null, IEnumerable<string> values = null, bool? dry_run = null)
        {
            var jm = new string[4];
            jm[0] = "{\"delete\": {";
            jm[1] = "\"ids\": $ids,";
            jm[2] = "\"values\": $values";
            jm[3] = "}}";
            var parameters = new Dictionary<string, object>();
            if(ids != null) parameters.Add("ids", ids);
            if(values != null) parameters.Add("values", values);
            if(dry_run != null) parameters.Add("dry_run", dry_run);
            return this.DeleteRulesImpl(parameters, jm, "2", "");
        }
        #endif

        /// <summary>
        /// <para>Deletes filter rules. This endpoint can delete multiple rules at a time by specifying an array of IDs. If one or more rules cannot be deleted (for example, because it does not exist), the operation will not fail. In other words, only existing rules will be deleted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> ids (optional)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> values (optional)</para>
        /// <para>- <c>bool</c> dry_run (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The result of the request.</returns>
        public Task<FilterRulesPostDeleteResponse> DeleteRulesAsync(params Expression<Func<string, object>>[] parameters)
        {
            var jm = new string[4];
            jm[0] = "{\"delete\": {";
            jm[1] = "\"ids\": $ids,";
            jm[2] = "\"values\": $values";
            jm[3] = "}}";
            return this.DeleteRulesAsyncImpl(InternalUtils.ExpressionsToDictionary(parameters), jm, CancellationToken.None, "2", "");
        }

        /// <summary>
        /// <para>Deletes filter rules. This endpoint can delete multiple rules at a time by specifying an array of IDs. If one or more rules cannot be deleted (for example, because it does not exist), the operation will not fail. In other words, only existing rules will be deleted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> ids (optional)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> values (optional)</para>
        /// <para>- <c>bool</c> dry_run (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The result of the request.</returns>
        public Task<FilterRulesPostDeleteResponse> DeleteRulesAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            var jm = new string[4];
            jm[0] = "{\"delete\": {";
            jm[1] = "\"ids\": $ids,";
            jm[2] = "\"values\": $values";
            jm[3] = "}}";
            return this.DeleteRulesAsyncImpl(parameters, jm, cancellationToken, "2", "");
        }

        /// <summary>
        /// <para>Deletes filter rules. This endpoint can delete multiple rules at a time by specifying an array of IDs. If one or more rules cannot be deleted (for example, because it does not exist), the operation will not fail. In other words, only existing rules will be deleted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> ids (optional)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> values (optional)</para>
        /// <para>- <c>bool</c> dry_run (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The result of the request.</returns>
        public Task<FilterRulesPostDeleteResponse> DeleteRulesAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            var jm = new string[4];
            jm[0] = "{\"delete\": {";
            jm[1] = "\"ids\": $ids,";
            jm[2] = "\"values\": $values";
            jm[3] = "}}";
            return this.DeleteRulesAsyncImpl(InternalUtils.ResolveObject(parameters), jm, cancellationToken, "2", "");
        }

        /// <summary>
        /// <para>Deletes filter rules. This endpoint can delete multiple rules at a time by specifying an array of IDs. If one or more rules cannot be deleted (for example, because it does not exist), the operation will not fail. In other words, only existing rules will be deleted.</para>
        /// </summary>
        /// <param name="ids">optional.</param>
        /// <param name="values">optional.</param>
        /// <param name="dry_run">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The result of the request.</returns>
        public Task<FilterRulesPostDeleteResponse> DeleteRulesAsync(IEnumerable<long> ids = null, IEnumerable<string> values = null, bool? dry_run = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var jm = new string[4];
            jm[0] = "{\"delete\": {";
            jm[1] = "\"ids\": $ids,";
            jm[2] = "\"values\": $values";
            jm[3] = "}}";
            var parameters = new Dictionary<string, object>();
            if(ids != null) parameters.Add("ids", ids);
            if(values != null) parameters.Add("values", values);
            if(dry_run != null) parameters.Add("dry_run", dry_run);
            return this.DeleteRulesAsyncImpl(parameters, jm, cancellationToken, "2", "");
        }

    }

}
namespace CoreTweet.Rest
{
}
namespace CoreTweet.V2
{
    /// <summary>
    /// Provides a set of methods for the wrapper of Hide replies v2 API on Twitter API v2.
    /// </summary>
    public partial class HideRepliesApi : ApiProviderBase
    {
        internal HideRepliesApi(TokensBase e) : base(e) { }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Hides a Tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> hidden (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The data that indicates if the Tweet was successfully hidden.</returns>
        public HideRepliesResponse Hidden(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApi<HideRepliesResponse>(MethodType.Put, "tweets/{id}/hidden", new [] { "id" }, InternalUtils.ExpressionsToDictionary(parameters), urlPrefix: "2", urlSuffix: "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Hides a Tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> hidden (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The data that indicates if the Tweet was successfully hidden.</returns>
        public HideRepliesResponse Hidden(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessParameterReservedApi<HideRepliesResponse>(MethodType.Put, "tweets/{id}/hidden", new [] { "id" }, parameters, urlPrefix: "2", urlSuffix: "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Hides a Tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> hidden (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The data that indicates if the Tweet was successfully hidden.</returns>
        public HideRepliesResponse Hidden(object parameters)
        {
            return this.Tokens.AccessParameterReservedApi<HideRepliesResponse>(MethodType.Put, "tweets/{id}/hidden", new [] { "id" }, InternalUtils.ResolveObject(parameters), urlPrefix: "2", urlSuffix: "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Hides a Tweet.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="hidden">required.</param>
        /// <returns>The data that indicates if the Tweet was successfully hidden.</returns>
        public HideRepliesResponse Hidden(long id, bool hidden)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            parameters.Add("hidden", hidden);
            return this.Tokens.AccessParameterReservedApi<HideRepliesResponse>(MethodType.Put, "tweets/{id}/hidden", new [] { "id" }, parameters, urlPrefix: "2", urlSuffix: "");
        }
        #endif

        /// <summary>
        /// <para>Hides a Tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> hidden (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The data that indicates if the Tweet was successfully hidden.</returns>
        public Task<HideRepliesResponse> HiddenAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiAsync<HideRepliesResponse>(MethodType.Put, "tweets/{id}/hidden", new [] { "id" }, InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None, urlPrefix: "2", urlSuffix: "");
        }

        /// <summary>
        /// <para>Hides a Tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> hidden (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The data that indicates if the Tweet was successfully hidden.</returns>
        public Task<HideRepliesResponse> HiddenAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<HideRepliesResponse>(MethodType.Put, "tweets/{id}/hidden", new [] { "id" }, parameters, cancellationToken, urlPrefix: "2", urlSuffix: "");
        }

        /// <summary>
        /// <para>Hides a Tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> hidden (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The data that indicates if the Tweet was successfully hidden.</returns>
        public Task<HideRepliesResponse> HiddenAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<HideRepliesResponse>(MethodType.Put, "tweets/{id}/hidden", new [] { "id" }, InternalUtils.ResolveObject(parameters), cancellationToken, urlPrefix: "2", urlSuffix: "");
        }

        /// <summary>
        /// <para>Hides a Tweet.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="hidden">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The data that indicates if the Tweet was successfully hidden.</returns>
        public Task<HideRepliesResponse> HiddenAsync(long id, bool hidden, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            parameters.Add("hidden", hidden);
            return this.Tokens.AccessParameterReservedApiAsync<HideRepliesResponse>(MethodType.Put, "tweets/{id}/hidden", new [] { "id" }, parameters, cancellationToken, urlPrefix: "2", urlSuffix: "");
        }

    }

}
namespace CoreTweet.Rest
{
}
namespace CoreTweet.V2
{
    /// <summary>
    /// Provides a set of methods for the wrapper of Recent search v2 API on Twitter API v2.
    /// </summary>
    public partial class RecentSearchApi : ApiProviderBase
    {
        internal RecentSearchApi(TokensBase e) : base(e) { }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns Tweets from the last 7 days that match a search query.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> query (required)</para>
        /// <para>- <c>DateTimeOffset</c> end_time (optional)</para>
        /// <para>- <c>TweetExpansions</c> expansions (optional)</para>
        /// <para>- <c>int</c> max_results (optional)</para>
        /// <para>- <c>MediaFields</c> media_fields (optional, query string: <c>"media.fields"</c>)</para>
        /// <para>- <c>string</c> next_token (optional)</para>
        /// <para>- <c>PlaceFields</c> place_fields (optional, query string: <c>"place.fields"</c>)</para>
        /// <para>- <c>PollFields</c> poll_fields (optional, query string: <c>"poll.fields"</c>)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>DateTimeOffset</c> start_time (optional)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>long</c> until_id (optional)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Tweets.</returns>
        public RecentSearchResponse GetTweets(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<RecentSearchResponse>(MethodType.Get, "tweets/search", parameters, urlPrefix: "2", urlSuffix: "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns Tweets from the last 7 days that match a search query.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> query (required)</para>
        /// <para>- <c>DateTimeOffset</c> end_time (optional)</para>
        /// <para>- <c>TweetExpansions</c> expansions (optional)</para>
        /// <para>- <c>int</c> max_results (optional)</para>
        /// <para>- <c>MediaFields</c> media_fields (optional, query string: <c>"media.fields"</c>)</para>
        /// <para>- <c>string</c> next_token (optional)</para>
        /// <para>- <c>PlaceFields</c> place_fields (optional, query string: <c>"place.fields"</c>)</para>
        /// <para>- <c>PollFields</c> poll_fields (optional, query string: <c>"poll.fields"</c>)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>DateTimeOffset</c> start_time (optional)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>long</c> until_id (optional)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Tweets.</returns>
        public RecentSearchResponse GetTweets(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<RecentSearchResponse>(MethodType.Get, "tweets/search", parameters, urlPrefix: "2", urlSuffix: "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns Tweets from the last 7 days that match a search query.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> query (required)</para>
        /// <para>- <c>DateTimeOffset</c> end_time (optional)</para>
        /// <para>- <c>TweetExpansions</c> expansions (optional)</para>
        /// <para>- <c>int</c> max_results (optional)</para>
        /// <para>- <c>MediaFields</c> media_fields (optional, query string: <c>"media.fields"</c>)</para>
        /// <para>- <c>string</c> next_token (optional)</para>
        /// <para>- <c>PlaceFields</c> place_fields (optional, query string: <c>"place.fields"</c>)</para>
        /// <para>- <c>PollFields</c> poll_fields (optional, query string: <c>"poll.fields"</c>)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>DateTimeOffset</c> start_time (optional)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>long</c> until_id (optional)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Tweets.</returns>
        public RecentSearchResponse GetTweets(object parameters)
        {
            return this.Tokens.AccessApi<RecentSearchResponse>(MethodType.Get, "tweets/search", parameters, urlPrefix: "2", urlSuffix: "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns Tweets from the last 7 days that match a search query.</para>
        /// </summary>
        /// <param name="query">required.</param>
        /// <param name="end_time">optional.</param>
        /// <param name="expansions">optional.</param>
        /// <param name="max_results">optional.</param>
        /// <param name="media_fields">optional.</param>
        /// <param name="next_token">optional.</param>
        /// <param name="place_fields">optional.</param>
        /// <param name="poll_fields">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="start_time">optional.</param>
        /// <param name="tweet_fields">optional.</param>
        /// <param name="until_id">optional.</param>
        /// <param name="user_fields">optional.</param>
        /// <returns>The Tweets.</returns>
        public RecentSearchResponse GetTweets(string query, DateTimeOffset? end_time = null, TweetExpansions? expansions = null, int? max_results = null, MediaFields? media_fields = null, string next_token = null, PlaceFields? place_fields = null, PollFields? poll_fields = null, long? since_id = null, DateTimeOffset? start_time = null, TweetFields? tweet_fields = null, long? until_id = null, UserFields? user_fields = null)
        {
            var parameters = new Dictionary<string, object>();
            if(query == null) throw new ArgumentNullException("query");
            parameters.Add("query", query);
            if(end_time != null) parameters.Add("end_time", end_time);
            if(expansions != null) parameters.Add("expansions", expansions);
            if(max_results != null) parameters.Add("max_results", max_results);
            if(media_fields != null) parameters.Add("media.fields", media_fields);
            if(next_token != null) parameters.Add("next_token", next_token);
            if(place_fields != null) parameters.Add("place.fields", place_fields);
            if(poll_fields != null) parameters.Add("poll.fields", poll_fields);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(start_time != null) parameters.Add("start_time", start_time);
            if(tweet_fields != null) parameters.Add("tweet.fields", tweet_fields);
            if(until_id != null) parameters.Add("until_id", until_id);
            if(user_fields != null) parameters.Add("user.fields", user_fields);
            return this.Tokens.AccessApi<RecentSearchResponse>(MethodType.Get, "tweets/search", parameters, urlPrefix: "2", urlSuffix: "");
        }
        #endif

        /// <summary>
        /// <para>Returns Tweets from the last 7 days that match a search query.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> query (required)</para>
        /// <para>- <c>DateTimeOffset</c> end_time (optional)</para>
        /// <para>- <c>TweetExpansions</c> expansions (optional)</para>
        /// <para>- <c>int</c> max_results (optional)</para>
        /// <para>- <c>MediaFields</c> media_fields (optional, query string: <c>"media.fields"</c>)</para>
        /// <para>- <c>string</c> next_token (optional)</para>
        /// <para>- <c>PlaceFields</c> place_fields (optional, query string: <c>"place.fields"</c>)</para>
        /// <para>- <c>PollFields</c> poll_fields (optional, query string: <c>"poll.fields"</c>)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>DateTimeOffset</c> start_time (optional)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>long</c> until_id (optional)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Tweets.</returns>
        public Task<RecentSearchResponse> GetTweetsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<RecentSearchResponse>(MethodType.Get, "tweets/search", parameters, urlPrefix: "2", urlSuffix: "");
        }

        /// <summary>
        /// <para>Returns Tweets from the last 7 days that match a search query.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> query (required)</para>
        /// <para>- <c>DateTimeOffset</c> end_time (optional)</para>
        /// <para>- <c>TweetExpansions</c> expansions (optional)</para>
        /// <para>- <c>int</c> max_results (optional)</para>
        /// <para>- <c>MediaFields</c> media_fields (optional, query string: <c>"media.fields"</c>)</para>
        /// <para>- <c>string</c> next_token (optional)</para>
        /// <para>- <c>PlaceFields</c> place_fields (optional, query string: <c>"place.fields"</c>)</para>
        /// <para>- <c>PollFields</c> poll_fields (optional, query string: <c>"poll.fields"</c>)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>DateTimeOffset</c> start_time (optional)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>long</c> until_id (optional)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The Tweets.</returns>
        public Task<RecentSearchResponse> GetTweetsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<RecentSearchResponse>(MethodType.Get, "tweets/search", parameters, cancellationToken, urlPrefix: "2", urlSuffix: "");
        }

        /// <summary>
        /// <para>Returns Tweets from the last 7 days that match a search query.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> query (required)</para>
        /// <para>- <c>DateTimeOffset</c> end_time (optional)</para>
        /// <para>- <c>TweetExpansions</c> expansions (optional)</para>
        /// <para>- <c>int</c> max_results (optional)</para>
        /// <para>- <c>MediaFields</c> media_fields (optional, query string: <c>"media.fields"</c>)</para>
        /// <para>- <c>string</c> next_token (optional)</para>
        /// <para>- <c>PlaceFields</c> place_fields (optional, query string: <c>"place.fields"</c>)</para>
        /// <para>- <c>PollFields</c> poll_fields (optional, query string: <c>"poll.fields"</c>)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>DateTimeOffset</c> start_time (optional)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>long</c> until_id (optional)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The Tweets.</returns>
        public Task<RecentSearchResponse> GetTweetsAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<RecentSearchResponse>(MethodType.Get, "tweets/search", parameters, cancellationToken, urlPrefix: "2", urlSuffix: "");
        }

        /// <summary>
        /// <para>Returns Tweets from the last 7 days that match a search query.</para>
        /// </summary>
        /// <param name="query">required.</param>
        /// <param name="end_time">optional.</param>
        /// <param name="expansions">optional.</param>
        /// <param name="max_results">optional.</param>
        /// <param name="media_fields">optional.</param>
        /// <param name="next_token">optional.</param>
        /// <param name="place_fields">optional.</param>
        /// <param name="poll_fields">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="start_time">optional.</param>
        /// <param name="tweet_fields">optional.</param>
        /// <param name="until_id">optional.</param>
        /// <param name="user_fields">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The Tweets.</returns>
        public Task<RecentSearchResponse> GetTweetsAsync(string query, DateTimeOffset? end_time = null, TweetExpansions? expansions = null, int? max_results = null, MediaFields? media_fields = null, string next_token = null, PlaceFields? place_fields = null, PollFields? poll_fields = null, long? since_id = null, DateTimeOffset? start_time = null, TweetFields? tweet_fields = null, long? until_id = null, UserFields? user_fields = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(query == null) throw new ArgumentNullException("query");
            parameters.Add("query", query);
            if(end_time != null) parameters.Add("end_time", end_time);
            if(expansions != null) parameters.Add("expansions", expansions);
            if(max_results != null) parameters.Add("max_results", max_results);
            if(media_fields != null) parameters.Add("media.fields", media_fields);
            if(next_token != null) parameters.Add("next_token", next_token);
            if(place_fields != null) parameters.Add("place.fields", place_fields);
            if(poll_fields != null) parameters.Add("poll.fields", poll_fields);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(start_time != null) parameters.Add("start_time", start_time);
            if(tweet_fields != null) parameters.Add("tweet.fields", tweet_fields);
            if(until_id != null) parameters.Add("until_id", until_id);
            if(user_fields != null) parameters.Add("user.fields", user_fields);
            return this.Tokens.AccessApiAsync<RecentSearchResponse>(MethodType.Get, "tweets/search", parameters, cancellationToken, urlPrefix: "2", urlSuffix: "");
        }

    }

}
namespace CoreTweet.Rest
{
}
namespace CoreTweet.V2
{
    /// <summary>
    /// Provides a set of methods for the wrapper of Sampled stream v1 API on Twitter API v2.
    /// </summary>
    public partial class SampledStreamApi : ApiProviderBase
    {
        internal SampledStreamApi(TokensBase e) : base(e) { }

        #if true
        /// <summary>
        /// <para>Streams about 1% of all Tweets in real-time.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>TweetExpansions</c> expansions (optional)</para>
        /// <para>- <c>MediaFields</c> media_fields (optional, query string: <c>"media.fields"</c>)</para>
        /// <para>- <c>PlaceFields</c> place_fields (optional, query string: <c>"place.fields"</c>)</para>
        /// <para>- <c>PollFields</c> poll_fields (optional, query string: <c>"poll.fields"</c>)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public LineDelimitedJsonStreamResponseStreamer<SampleStreamResponse> Sample(params Expression<Func<string, object>>[] parameters)
        {
            return this.SampleImpl(InternalUtils.ExpressionsToDictionary(parameters).Select(x => new KeyValuePair<string, object>(x.Key == "media_fields" ? "media.fields" : x.Key == "place_fields" ? "place.fields" : x.Key == "poll_fields" ? "poll.fields" : x.Key == "tweet_fields" ? "tweet.fields" : x.Key == "user_fields" ? "user.fields" : x.Key, x.Value)), "2", "");
        }
        #endif

        #if true
        /// <summary>
        /// <para>Streams about 1% of all Tweets in real-time.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>TweetExpansions</c> expansions (optional)</para>
        /// <para>- <c>MediaFields</c> media_fields (optional, query string: <c>"media.fields"</c>)</para>
        /// <para>- <c>PlaceFields</c> place_fields (optional, query string: <c>"place.fields"</c>)</para>
        /// <para>- <c>PollFields</c> poll_fields (optional, query string: <c>"poll.fields"</c>)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public LineDelimitedJsonStreamResponseStreamer<SampleStreamResponse> Sample(IDictionary<string, object> parameters)
        {
            return this.SampleImpl(parameters, "2", "");
        }
        #endif

        #if true
        /// <summary>
        /// <para>Streams about 1% of all Tweets in real-time.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>TweetExpansions</c> expansions (optional)</para>
        /// <para>- <c>MediaFields</c> media_fields (optional, query string: <c>"media.fields"</c>)</para>
        /// <para>- <c>PlaceFields</c> place_fields (optional, query string: <c>"place.fields"</c>)</para>
        /// <para>- <c>PollFields</c> poll_fields (optional, query string: <c>"poll.fields"</c>)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public LineDelimitedJsonStreamResponseStreamer<SampleStreamResponse> Sample(object parameters)
        {
            return this.SampleImpl(InternalUtils.ResolveObject(parameters), "2", "");
        }
        #endif

        #if true
        /// <summary>
        /// <para>Streams about 1% of all Tweets in real-time.</para>
        /// </summary>
        /// <param name="expansions">optional.</param>
        /// <param name="media_fields">optional.</param>
        /// <param name="place_fields">optional.</param>
        /// <param name="poll_fields">optional.</param>
        /// <param name="tweet_fields">optional.</param>
        /// <param name="user_fields">optional.</param>
        /// <returns></returns>
        public LineDelimitedJsonStreamResponseStreamer<SampleStreamResponse> Sample(TweetExpansions? expansions = null, MediaFields? media_fields = null, PlaceFields? place_fields = null, PollFields? poll_fields = null, TweetFields? tweet_fields = null, UserFields? user_fields = null)
        {
            var parameters = new Dictionary<string, object>();
            if(expansions != null) parameters.Add("expansions", expansions);
            if(media_fields != null) parameters.Add("media.fields", media_fields);
            if(place_fields != null) parameters.Add("place.fields", place_fields);
            if(poll_fields != null) parameters.Add("poll.fields", poll_fields);
            if(tweet_fields != null) parameters.Add("tweet.fields", tweet_fields);
            if(user_fields != null) parameters.Add("user.fields", user_fields);
            return this.SampleImpl(parameters, "2", "");
        }
        #endif

    }

}
namespace CoreTweet.Rest
{
}
namespace CoreTweet.V2
{
    /// <summary>
    /// Provides a set of methods for the wrapper of Tweet Lookup API on Twitter API v2.
    /// </summary>
    public partial class TweetLookupApi : ApiProviderBase
    {
        internal TweetLookupApi(TokensBase e) : base(e) { }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a variety of information about a single Tweet specified by the requested ID.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>TweetExpansions</c> expansions (optional)</para>
        /// <para>- <c>MediaFields</c> media_fields (optional, query string: <c>"media.fields"</c>)</para>
        /// <para>- <c>PlaceFields</c> place_fields (optional, query string: <c>"place.fields"</c>)</para>
        /// <para>- <c>PollFields</c> poll_fields (optional, query string: <c>"poll.fields"</c>)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Tweet.</returns>
        public TweetResponse GetTweet(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApi<TweetResponse>(MethodType.Get, "tweets/{id}", new [] { "id" }, InternalUtils.ExpressionsToDictionary(parameters).Select(x => new KeyValuePair<string, object>(x.Key == "media_fields" ? "media.fields" : x.Key == "place_fields" ? "place.fields" : x.Key == "poll_fields" ? "poll.fields" : x.Key == "tweet_fields" ? "tweet.fields" : x.Key == "user_fields" ? "user.fields" : x.Key, x.Value)), urlPrefix: "2", urlSuffix: "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a variety of information about a single Tweet specified by the requested ID.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>TweetExpansions</c> expansions (optional)</para>
        /// <para>- <c>MediaFields</c> media_fields (optional, query string: <c>"media.fields"</c>)</para>
        /// <para>- <c>PlaceFields</c> place_fields (optional, query string: <c>"place.fields"</c>)</para>
        /// <para>- <c>PollFields</c> poll_fields (optional, query string: <c>"poll.fields"</c>)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Tweet.</returns>
        public TweetResponse GetTweet(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessParameterReservedApi<TweetResponse>(MethodType.Get, "tweets/{id}", new [] { "id" }, parameters, urlPrefix: "2", urlSuffix: "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a variety of information about a single Tweet specified by the requested ID.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>TweetExpansions</c> expansions (optional)</para>
        /// <para>- <c>MediaFields</c> media_fields (optional, query string: <c>"media.fields"</c>)</para>
        /// <para>- <c>PlaceFields</c> place_fields (optional, query string: <c>"place.fields"</c>)</para>
        /// <para>- <c>PollFields</c> poll_fields (optional, query string: <c>"poll.fields"</c>)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Tweet.</returns>
        public TweetResponse GetTweet(object parameters)
        {
            return this.Tokens.AccessParameterReservedApi<TweetResponse>(MethodType.Get, "tweets/{id}", new [] { "id" }, InternalUtils.ResolveObject(parameters), urlPrefix: "2", urlSuffix: "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a variety of information about a single Tweet specified by the requested ID.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="expansions">optional.</param>
        /// <param name="media_fields">optional.</param>
        /// <param name="place_fields">optional.</param>
        /// <param name="poll_fields">optional.</param>
        /// <param name="tweet_fields">optional.</param>
        /// <param name="user_fields">optional.</param>
        /// <returns>The Tweet.</returns>
        public TweetResponse GetTweet(long id, TweetExpansions? expansions = null, MediaFields? media_fields = null, PlaceFields? place_fields = null, PollFields? poll_fields = null, TweetFields? tweet_fields = null, UserFields? user_fields = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(expansions != null) parameters.Add("expansions", expansions);
            if(media_fields != null) parameters.Add("media.fields", media_fields);
            if(place_fields != null) parameters.Add("place.fields", place_fields);
            if(poll_fields != null) parameters.Add("poll.fields", poll_fields);
            if(tweet_fields != null) parameters.Add("tweet.fields", tweet_fields);
            if(user_fields != null) parameters.Add("user.fields", user_fields);
            return this.Tokens.AccessParameterReservedApi<TweetResponse>(MethodType.Get, "tweets/{id}", new [] { "id" }, parameters, urlPrefix: "2", urlSuffix: "");
        }
        #endif

        /// <summary>
        /// <para>Returns a variety of information about a single Tweet specified by the requested ID.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>TweetExpansions</c> expansions (optional)</para>
        /// <para>- <c>MediaFields</c> media_fields (optional, query string: <c>"media.fields"</c>)</para>
        /// <para>- <c>PlaceFields</c> place_fields (optional, query string: <c>"place.fields"</c>)</para>
        /// <para>- <c>PollFields</c> poll_fields (optional, query string: <c>"poll.fields"</c>)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Tweet.</returns>
        public Task<TweetResponse> GetTweetAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiAsync<TweetResponse>(MethodType.Get, "tweets/{id}", new [] { "id" }, InternalUtils.ExpressionsToDictionary(parameters).Select(x => new KeyValuePair<string, object>(x.Key == "media_fields" ? "media.fields" : x.Key == "place_fields" ? "place.fields" : x.Key == "poll_fields" ? "poll.fields" : x.Key == "tweet_fields" ? "tweet.fields" : x.Key == "user_fields" ? "user.fields" : x.Key, x.Value)), CancellationToken.None, urlPrefix: "2", urlSuffix: "");
        }

        /// <summary>
        /// <para>Returns a variety of information about a single Tweet specified by the requested ID.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>TweetExpansions</c> expansions (optional)</para>
        /// <para>- <c>MediaFields</c> media_fields (optional, query string: <c>"media.fields"</c>)</para>
        /// <para>- <c>PlaceFields</c> place_fields (optional, query string: <c>"place.fields"</c>)</para>
        /// <para>- <c>PollFields</c> poll_fields (optional, query string: <c>"poll.fields"</c>)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The Tweet.</returns>
        public Task<TweetResponse> GetTweetAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<TweetResponse>(MethodType.Get, "tweets/{id}", new [] { "id" }, parameters, cancellationToken, urlPrefix: "2", urlSuffix: "");
        }

        /// <summary>
        /// <para>Returns a variety of information about a single Tweet specified by the requested ID.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>TweetExpansions</c> expansions (optional)</para>
        /// <para>- <c>MediaFields</c> media_fields (optional, query string: <c>"media.fields"</c>)</para>
        /// <para>- <c>PlaceFields</c> place_fields (optional, query string: <c>"place.fields"</c>)</para>
        /// <para>- <c>PollFields</c> poll_fields (optional, query string: <c>"poll.fields"</c>)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The Tweet.</returns>
        public Task<TweetResponse> GetTweetAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<TweetResponse>(MethodType.Get, "tweets/{id}", new [] { "id" }, InternalUtils.ResolveObject(parameters), cancellationToken, urlPrefix: "2", urlSuffix: "");
        }

        /// <summary>
        /// <para>Returns a variety of information about a single Tweet specified by the requested ID.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="expansions">optional.</param>
        /// <param name="media_fields">optional.</param>
        /// <param name="place_fields">optional.</param>
        /// <param name="poll_fields">optional.</param>
        /// <param name="tweet_fields">optional.</param>
        /// <param name="user_fields">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The Tweet.</returns>
        public Task<TweetResponse> GetTweetAsync(long id, TweetExpansions? expansions = null, MediaFields? media_fields = null, PlaceFields? place_fields = null, PollFields? poll_fields = null, TweetFields? tweet_fields = null, UserFields? user_fields = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(expansions != null) parameters.Add("expansions", expansions);
            if(media_fields != null) parameters.Add("media.fields", media_fields);
            if(place_fields != null) parameters.Add("place.fields", place_fields);
            if(poll_fields != null) parameters.Add("poll.fields", poll_fields);
            if(tweet_fields != null) parameters.Add("tweet.fields", tweet_fields);
            if(user_fields != null) parameters.Add("user.fields", user_fields);
            return this.Tokens.AccessParameterReservedApiAsync<TweetResponse>(MethodType.Get, "tweets/{id}", new [] { "id" }, parameters, cancellationToken, urlPrefix: "2", urlSuffix: "");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a variety of information about the Tweet specified by the requested ID or list of IDs.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> ids (required)</para>
        /// <para>- <c>TweetExpansions</c> expansions (optional)</para>
        /// <para>- <c>MediaFields</c> media_fields (optional, query string: <c>"media.fields"</c>)</para>
        /// <para>- <c>PlaceFields</c> place_fields (optional, query string: <c>"place.fields"</c>)</para>
        /// <para>- <c>PollFields</c> poll_fields (optional, query string: <c>"poll.fields"</c>)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Tweets.</returns>
        public TweetsResponse GetTweets(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<TweetsResponse>(MethodType.Get, "tweets", parameters, urlPrefix: "2", urlSuffix: "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a variety of information about the Tweet specified by the requested ID or list of IDs.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> ids (required)</para>
        /// <para>- <c>TweetExpansions</c> expansions (optional)</para>
        /// <para>- <c>MediaFields</c> media_fields (optional, query string: <c>"media.fields"</c>)</para>
        /// <para>- <c>PlaceFields</c> place_fields (optional, query string: <c>"place.fields"</c>)</para>
        /// <para>- <c>PollFields</c> poll_fields (optional, query string: <c>"poll.fields"</c>)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Tweets.</returns>
        public TweetsResponse GetTweets(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<TweetsResponse>(MethodType.Get, "tweets", parameters, urlPrefix: "2", urlSuffix: "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a variety of information about the Tweet specified by the requested ID or list of IDs.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> ids (required)</para>
        /// <para>- <c>TweetExpansions</c> expansions (optional)</para>
        /// <para>- <c>MediaFields</c> media_fields (optional, query string: <c>"media.fields"</c>)</para>
        /// <para>- <c>PlaceFields</c> place_fields (optional, query string: <c>"place.fields"</c>)</para>
        /// <para>- <c>PollFields</c> poll_fields (optional, query string: <c>"poll.fields"</c>)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Tweets.</returns>
        public TweetsResponse GetTweets(object parameters)
        {
            return this.Tokens.AccessApi<TweetsResponse>(MethodType.Get, "tweets", parameters, urlPrefix: "2", urlSuffix: "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a variety of information about the Tweet specified by the requested ID or list of IDs.</para>
        /// </summary>
        /// <param name="ids">required.</param>
        /// <param name="expansions">optional.</param>
        /// <param name="media_fields">optional.</param>
        /// <param name="place_fields">optional.</param>
        /// <param name="poll_fields">optional.</param>
        /// <param name="tweet_fields">optional.</param>
        /// <param name="user_fields">optional.</param>
        /// <returns>The Tweets.</returns>
        public TweetsResponse GetTweets(IEnumerable<long> ids, TweetExpansions? expansions = null, MediaFields? media_fields = null, PlaceFields? place_fields = null, PollFields? poll_fields = null, TweetFields? tweet_fields = null, UserFields? user_fields = null)
        {
            var parameters = new Dictionary<string, object>();
            if(ids == null) throw new ArgumentNullException("ids");
            parameters.Add("ids", ids);
            if(expansions != null) parameters.Add("expansions", expansions);
            if(media_fields != null) parameters.Add("media.fields", media_fields);
            if(place_fields != null) parameters.Add("place.fields", place_fields);
            if(poll_fields != null) parameters.Add("poll.fields", poll_fields);
            if(tweet_fields != null) parameters.Add("tweet.fields", tweet_fields);
            if(user_fields != null) parameters.Add("user.fields", user_fields);
            return this.Tokens.AccessApi<TweetsResponse>(MethodType.Get, "tweets", parameters, urlPrefix: "2", urlSuffix: "");
        }
        #endif

        /// <summary>
        /// <para>Returns a variety of information about the Tweet specified by the requested ID or list of IDs.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> ids (required)</para>
        /// <para>- <c>TweetExpansions</c> expansions (optional)</para>
        /// <para>- <c>MediaFields</c> media_fields (optional, query string: <c>"media.fields"</c>)</para>
        /// <para>- <c>PlaceFields</c> place_fields (optional, query string: <c>"place.fields"</c>)</para>
        /// <para>- <c>PollFields</c> poll_fields (optional, query string: <c>"poll.fields"</c>)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Tweets.</returns>
        public Task<TweetsResponse> GetTweetsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<TweetsResponse>(MethodType.Get, "tweets", parameters, urlPrefix: "2", urlSuffix: "");
        }

        /// <summary>
        /// <para>Returns a variety of information about the Tweet specified by the requested ID or list of IDs.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> ids (required)</para>
        /// <para>- <c>TweetExpansions</c> expansions (optional)</para>
        /// <para>- <c>MediaFields</c> media_fields (optional, query string: <c>"media.fields"</c>)</para>
        /// <para>- <c>PlaceFields</c> place_fields (optional, query string: <c>"place.fields"</c>)</para>
        /// <para>- <c>PollFields</c> poll_fields (optional, query string: <c>"poll.fields"</c>)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The Tweets.</returns>
        public Task<TweetsResponse> GetTweetsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<TweetsResponse>(MethodType.Get, "tweets", parameters, cancellationToken, urlPrefix: "2", urlSuffix: "");
        }

        /// <summary>
        /// <para>Returns a variety of information about the Tweet specified by the requested ID or list of IDs.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> ids (required)</para>
        /// <para>- <c>TweetExpansions</c> expansions (optional)</para>
        /// <para>- <c>MediaFields</c> media_fields (optional, query string: <c>"media.fields"</c>)</para>
        /// <para>- <c>PlaceFields</c> place_fields (optional, query string: <c>"place.fields"</c>)</para>
        /// <para>- <c>PollFields</c> poll_fields (optional, query string: <c>"poll.fields"</c>)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The Tweets.</returns>
        public Task<TweetsResponse> GetTweetsAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<TweetsResponse>(MethodType.Get, "tweets", parameters, cancellationToken, urlPrefix: "2", urlSuffix: "");
        }

        /// <summary>
        /// <para>Returns a variety of information about the Tweet specified by the requested ID or list of IDs.</para>
        /// </summary>
        /// <param name="ids">required.</param>
        /// <param name="expansions">optional.</param>
        /// <param name="media_fields">optional.</param>
        /// <param name="place_fields">optional.</param>
        /// <param name="poll_fields">optional.</param>
        /// <param name="tweet_fields">optional.</param>
        /// <param name="user_fields">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The Tweets.</returns>
        public Task<TweetsResponse> GetTweetsAsync(IEnumerable<long> ids, TweetExpansions? expansions = null, MediaFields? media_fields = null, PlaceFields? place_fields = null, PollFields? poll_fields = null, TweetFields? tweet_fields = null, UserFields? user_fields = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(ids == null) throw new ArgumentNullException("ids");
            parameters.Add("ids", ids);
            if(expansions != null) parameters.Add("expansions", expansions);
            if(media_fields != null) parameters.Add("media.fields", media_fields);
            if(place_fields != null) parameters.Add("place.fields", place_fields);
            if(poll_fields != null) parameters.Add("poll.fields", poll_fields);
            if(tweet_fields != null) parameters.Add("tweet.fields", tweet_fields);
            if(user_fields != null) parameters.Add("user.fields", user_fields);
            return this.Tokens.AccessApiAsync<TweetsResponse>(MethodType.Get, "tweets", parameters, cancellationToken, urlPrefix: "2", urlSuffix: "");
        }

    }

}
namespace CoreTweet.Rest
{
}
namespace CoreTweet.V2
{
    /// <summary>
    /// Provides a set of methods for the wrapper of User Lookup API on Twitter API v2.
    /// </summary>
    public partial class UserLookupApi : ApiProviderBase
    {
        internal UserLookupApi(TokensBase e) : base(e) { }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a variety of information about a single more user specified by the requested ID. By default, only the ID, the username and the user's profile name are returned.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>UserExpansions</c> expansions (optional)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The User.</returns>
        public UserResponse GetUser(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApi<UserResponse>(MethodType.Get, "users/{id}", new [] { "id" }, InternalUtils.ExpressionsToDictionary(parameters).Select(x => new KeyValuePair<string, object>(x.Key == "tweet_fields" ? "tweet.fields" : x.Key == "user_fields" ? "user.fields" : x.Key, x.Value)), urlPrefix: "2", urlSuffix: "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a variety of information about a single more user specified by the requested ID. By default, only the ID, the username and the user's profile name are returned.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>UserExpansions</c> expansions (optional)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The User.</returns>
        public UserResponse GetUser(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessParameterReservedApi<UserResponse>(MethodType.Get, "users/{id}", new [] { "id" }, parameters, urlPrefix: "2", urlSuffix: "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a variety of information about a single more user specified by the requested ID. By default, only the ID, the username and the user's profile name are returned.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>UserExpansions</c> expansions (optional)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The User.</returns>
        public UserResponse GetUser(object parameters)
        {
            return this.Tokens.AccessParameterReservedApi<UserResponse>(MethodType.Get, "users/{id}", new [] { "id" }, InternalUtils.ResolveObject(parameters), urlPrefix: "2", urlSuffix: "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a variety of information about a single more user specified by the requested ID. By default, only the ID, the username and the user's profile name are returned.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="expansions">optional.</param>
        /// <param name="tweet_fields">optional.</param>
        /// <param name="user_fields">optional.</param>
        /// <returns>The User.</returns>
        public UserResponse GetUser(long id, UserExpansions? expansions = null, TweetFields? tweet_fields = null, UserFields? user_fields = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(expansions != null) parameters.Add("expansions", expansions);
            if(tweet_fields != null) parameters.Add("tweet.fields", tweet_fields);
            if(user_fields != null) parameters.Add("user.fields", user_fields);
            return this.Tokens.AccessParameterReservedApi<UserResponse>(MethodType.Get, "users/{id}", new [] { "id" }, parameters, urlPrefix: "2", urlSuffix: "");
        }
        #endif

        /// <summary>
        /// <para>Returns a variety of information about a single more user specified by the requested ID. By default, only the ID, the username and the user's profile name are returned.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>UserExpansions</c> expansions (optional)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The User.</returns>
        public Task<UserResponse> GetUserAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiAsync<UserResponse>(MethodType.Get, "users/{id}", new [] { "id" }, InternalUtils.ExpressionsToDictionary(parameters).Select(x => new KeyValuePair<string, object>(x.Key == "tweet_fields" ? "tweet.fields" : x.Key == "user_fields" ? "user.fields" : x.Key, x.Value)), CancellationToken.None, urlPrefix: "2", urlSuffix: "");
        }

        /// <summary>
        /// <para>Returns a variety of information about a single more user specified by the requested ID. By default, only the ID, the username and the user's profile name are returned.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>UserExpansions</c> expansions (optional)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The User.</returns>
        public Task<UserResponse> GetUserAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<UserResponse>(MethodType.Get, "users/{id}", new [] { "id" }, parameters, cancellationToken, urlPrefix: "2", urlSuffix: "");
        }

        /// <summary>
        /// <para>Returns a variety of information about a single more user specified by the requested ID. By default, only the ID, the username and the user's profile name are returned.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>UserExpansions</c> expansions (optional)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The User.</returns>
        public Task<UserResponse> GetUserAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<UserResponse>(MethodType.Get, "users/{id}", new [] { "id" }, InternalUtils.ResolveObject(parameters), cancellationToken, urlPrefix: "2", urlSuffix: "");
        }

        /// <summary>
        /// <para>Returns a variety of information about a single more user specified by the requested ID. By default, only the ID, the username and the user's profile name are returned.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="expansions">optional.</param>
        /// <param name="tweet_fields">optional.</param>
        /// <param name="user_fields">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The User.</returns>
        public Task<UserResponse> GetUserAsync(long id, UserExpansions? expansions = null, TweetFields? tweet_fields = null, UserFields? user_fields = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(expansions != null) parameters.Add("expansions", expansions);
            if(tweet_fields != null) parameters.Add("tweet.fields", tweet_fields);
            if(user_fields != null) parameters.Add("user.fields", user_fields);
            return this.Tokens.AccessParameterReservedApiAsync<UserResponse>(MethodType.Get, "users/{id}", new [] { "id" }, parameters, cancellationToken, urlPrefix: "2", urlSuffix: "");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a variety of information about one User specified by the requested username.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> username (required)</para>
        /// <para>- <c>UserExpansions</c> expansions (optional)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The User.</returns>
        public UserResponse GetUserByUsername(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApi<UserResponse>(MethodType.Get, "users/by/username/{username}", new [] { "username" }, InternalUtils.ExpressionsToDictionary(parameters).Select(x => new KeyValuePair<string, object>(x.Key == "tweet_fields" ? "tweet.fields" : x.Key == "user_fields" ? "user.fields" : x.Key, x.Value)), urlPrefix: "2", urlSuffix: "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a variety of information about one User specified by the requested username.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> username (required)</para>
        /// <para>- <c>UserExpansions</c> expansions (optional)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The User.</returns>
        public UserResponse GetUserByUsername(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessParameterReservedApi<UserResponse>(MethodType.Get, "users/by/username/{username}", new [] { "username" }, parameters, urlPrefix: "2", urlSuffix: "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a variety of information about one User specified by the requested username.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> username (required)</para>
        /// <para>- <c>UserExpansions</c> expansions (optional)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The User.</returns>
        public UserResponse GetUserByUsername(object parameters)
        {
            return this.Tokens.AccessParameterReservedApi<UserResponse>(MethodType.Get, "users/by/username/{username}", new [] { "username" }, InternalUtils.ResolveObject(parameters), urlPrefix: "2", urlSuffix: "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a variety of information about one User specified by the requested username.</para>
        /// </summary>
        /// <param name="username">required.</param>
        /// <param name="expansions">optional.</param>
        /// <param name="tweet_fields">optional.</param>
        /// <param name="user_fields">optional.</param>
        /// <returns>The User.</returns>
        public UserResponse GetUserByUsername(string username, UserExpansions? expansions = null, TweetFields? tweet_fields = null, UserFields? user_fields = null)
        {
            var parameters = new Dictionary<string, object>();
            if(username == null) throw new ArgumentNullException("username");
            parameters.Add("username", username);
            if(expansions != null) parameters.Add("expansions", expansions);
            if(tweet_fields != null) parameters.Add("tweet.fields", tweet_fields);
            if(user_fields != null) parameters.Add("user.fields", user_fields);
            return this.Tokens.AccessParameterReservedApi<UserResponse>(MethodType.Get, "users/by/username/{username}", new [] { "username" }, parameters, urlPrefix: "2", urlSuffix: "");
        }
        #endif

        /// <summary>
        /// <para>Returns a variety of information about one User specified by the requested username.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> username (required)</para>
        /// <para>- <c>UserExpansions</c> expansions (optional)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The User.</returns>
        public Task<UserResponse> GetUserByUsernameAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiAsync<UserResponse>(MethodType.Get, "users/by/username/{username}", new [] { "username" }, InternalUtils.ExpressionsToDictionary(parameters).Select(x => new KeyValuePair<string, object>(x.Key == "tweet_fields" ? "tweet.fields" : x.Key == "user_fields" ? "user.fields" : x.Key, x.Value)), CancellationToken.None, urlPrefix: "2", urlSuffix: "");
        }

        /// <summary>
        /// <para>Returns a variety of information about one User specified by the requested username.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> username (required)</para>
        /// <para>- <c>UserExpansions</c> expansions (optional)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The User.</returns>
        public Task<UserResponse> GetUserByUsernameAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<UserResponse>(MethodType.Get, "users/by/username/{username}", new [] { "username" }, parameters, cancellationToken, urlPrefix: "2", urlSuffix: "");
        }

        /// <summary>
        /// <para>Returns a variety of information about one User specified by the requested username.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> username (required)</para>
        /// <para>- <c>UserExpansions</c> expansions (optional)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The User.</returns>
        public Task<UserResponse> GetUserByUsernameAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<UserResponse>(MethodType.Get, "users/by/username/{username}", new [] { "username" }, InternalUtils.ResolveObject(parameters), cancellationToken, urlPrefix: "2", urlSuffix: "");
        }

        /// <summary>
        /// <para>Returns a variety of information about one User specified by the requested username.</para>
        /// </summary>
        /// <param name="username">required.</param>
        /// <param name="expansions">optional.</param>
        /// <param name="tweet_fields">optional.</param>
        /// <param name="user_fields">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The User.</returns>
        public Task<UserResponse> GetUserByUsernameAsync(string username, UserExpansions? expansions = null, TweetFields? tweet_fields = null, UserFields? user_fields = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(username == null) throw new ArgumentNullException("username");
            parameters.Add("username", username);
            if(expansions != null) parameters.Add("expansions", expansions);
            if(tweet_fields != null) parameters.Add("tweet.fields", tweet_fields);
            if(user_fields != null) parameters.Add("user.fields", user_fields);
            return this.Tokens.AccessParameterReservedApiAsync<UserResponse>(MethodType.Get, "users/by/username/{username}", new [] { "username" }, parameters, cancellationToken, urlPrefix: "2", urlSuffix: "");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a variety of information about one or more Users specified by the requested IDs.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> id (required)</para>
        /// <para>- <c>UserExpansions</c> expansions (optional)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Users.</returns>
        public UsersResponse GetUsers(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UsersResponse>(MethodType.Get, "users", parameters, urlPrefix: "2", urlSuffix: "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a variety of information about one or more Users specified by the requested IDs.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> id (required)</para>
        /// <para>- <c>UserExpansions</c> expansions (optional)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Users.</returns>
        public UsersResponse GetUsers(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UsersResponse>(MethodType.Get, "users", parameters, urlPrefix: "2", urlSuffix: "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a variety of information about one or more Users specified by the requested IDs.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> id (required)</para>
        /// <para>- <c>UserExpansions</c> expansions (optional)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Users.</returns>
        public UsersResponse GetUsers(object parameters)
        {
            return this.Tokens.AccessApi<UsersResponse>(MethodType.Get, "users", parameters, urlPrefix: "2", urlSuffix: "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a variety of information about one or more Users specified by the requested IDs.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="expansions">optional.</param>
        /// <param name="tweet_fields">optional.</param>
        /// <param name="user_fields">optional.</param>
        /// <returns>The Users.</returns>
        public UsersResponse GetUsers(IEnumerable<long> id, UserExpansions? expansions = null, TweetFields? tweet_fields = null, UserFields? user_fields = null)
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            if(expansions != null) parameters.Add("expansions", expansions);
            if(tweet_fields != null) parameters.Add("tweet.fields", tweet_fields);
            if(user_fields != null) parameters.Add("user.fields", user_fields);
            return this.Tokens.AccessApi<UsersResponse>(MethodType.Get, "users", parameters, urlPrefix: "2", urlSuffix: "");
        }
        #endif

        /// <summary>
        /// <para>Returns a variety of information about one or more Users specified by the requested IDs.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> id (required)</para>
        /// <para>- <c>UserExpansions</c> expansions (optional)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Users.</returns>
        public Task<UsersResponse> GetUsersAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UsersResponse>(MethodType.Get, "users", parameters, urlPrefix: "2", urlSuffix: "");
        }

        /// <summary>
        /// <para>Returns a variety of information about one or more Users specified by the requested IDs.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> id (required)</para>
        /// <para>- <c>UserExpansions</c> expansions (optional)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The Users.</returns>
        public Task<UsersResponse> GetUsersAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UsersResponse>(MethodType.Get, "users", parameters, cancellationToken, urlPrefix: "2", urlSuffix: "");
        }

        /// <summary>
        /// <para>Returns a variety of information about one or more Users specified by the requested IDs.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> id (required)</para>
        /// <para>- <c>UserExpansions</c> expansions (optional)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The Users.</returns>
        public Task<UsersResponse> GetUsersAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UsersResponse>(MethodType.Get, "users", parameters, cancellationToken, urlPrefix: "2", urlSuffix: "");
        }

        /// <summary>
        /// <para>Returns a variety of information about one or more Users specified by the requested IDs.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="expansions">optional.</param>
        /// <param name="tweet_fields">optional.</param>
        /// <param name="user_fields">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The Users.</returns>
        public Task<UsersResponse> GetUsersAsync(IEnumerable<long> id, UserExpansions? expansions = null, TweetFields? tweet_fields = null, UserFields? user_fields = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            parameters.Add("id", id);
            if(expansions != null) parameters.Add("expansions", expansions);
            if(tweet_fields != null) parameters.Add("tweet.fields", tweet_fields);
            if(user_fields != null) parameters.Add("user.fields", user_fields);
            return this.Tokens.AccessApiAsync<UsersResponse>(MethodType.Get, "users", parameters, cancellationToken, urlPrefix: "2", urlSuffix: "");
        }

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a variety of information about one or more Users specified by the requested usernames.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> usernames (required)</para>
        /// <para>- <c>UserExpansions</c> expansions (optional)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Users.</returns>
        public UsersResponse GetUsersByUsernames(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UsersResponse>(MethodType.Get, "users/by", parameters, urlPrefix: "2", urlSuffix: "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a variety of information about one or more Users specified by the requested usernames.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> usernames (required)</para>
        /// <para>- <c>UserExpansions</c> expansions (optional)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Users.</returns>
        public UsersResponse GetUsersByUsernames(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UsersResponse>(MethodType.Get, "users/by", parameters, urlPrefix: "2", urlSuffix: "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a variety of information about one or more Users specified by the requested usernames.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> usernames (required)</para>
        /// <para>- <c>UserExpansions</c> expansions (optional)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Users.</returns>
        public UsersResponse GetUsersByUsernames(object parameters)
        {
            return this.Tokens.AccessApi<UsersResponse>(MethodType.Get, "users/by", parameters, urlPrefix: "2", urlSuffix: "");
        }
        #endif

        #if !NETSTANDARD1_3
        /// <summary>
        /// <para>Returns a variety of information about one or more Users specified by the requested usernames.</para>
        /// </summary>
        /// <param name="usernames">required.</param>
        /// <param name="expansions">optional.</param>
        /// <param name="tweet_fields">optional.</param>
        /// <param name="user_fields">optional.</param>
        /// <returns>The Users.</returns>
        public UsersResponse GetUsersByUsernames(IEnumerable<string> usernames, UserExpansions? expansions = null, TweetFields? tweet_fields = null, UserFields? user_fields = null)
        {
            var parameters = new Dictionary<string, object>();
            if(usernames == null) throw new ArgumentNullException("usernames");
            parameters.Add("usernames", usernames);
            if(expansions != null) parameters.Add("expansions", expansions);
            if(tweet_fields != null) parameters.Add("tweet.fields", tweet_fields);
            if(user_fields != null) parameters.Add("user.fields", user_fields);
            return this.Tokens.AccessApi<UsersResponse>(MethodType.Get, "users/by", parameters, urlPrefix: "2", urlSuffix: "");
        }
        #endif

        /// <summary>
        /// <para>Returns a variety of information about one or more Users specified by the requested usernames.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> usernames (required)</para>
        /// <para>- <c>UserExpansions</c> expansions (optional)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The Users.</returns>
        public Task<UsersResponse> GetUsersByUsernamesAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UsersResponse>(MethodType.Get, "users/by", parameters, urlPrefix: "2", urlSuffix: "");
        }

        /// <summary>
        /// <para>Returns a variety of information about one or more Users specified by the requested usernames.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> usernames (required)</para>
        /// <para>- <c>UserExpansions</c> expansions (optional)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The Users.</returns>
        public Task<UsersResponse> GetUsersByUsernamesAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UsersResponse>(MethodType.Get, "users/by", parameters, cancellationToken, urlPrefix: "2", urlSuffix: "");
        }

        /// <summary>
        /// <para>Returns a variety of information about one or more Users specified by the requested usernames.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> usernames (required)</para>
        /// <para>- <c>UserExpansions</c> expansions (optional)</para>
        /// <para>- <c>TweetFields</c> tweet_fields (optional, query string: <c>"tweet.fields"</c>)</para>
        /// <para>- <c>UserFields</c> user_fields (optional, query string: <c>"user.fields"</c>)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The Users.</returns>
        public Task<UsersResponse> GetUsersByUsernamesAsync(object parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UsersResponse>(MethodType.Get, "users/by", parameters, cancellationToken, urlPrefix: "2", urlSuffix: "");
        }

        /// <summary>
        /// <para>Returns a variety of information about one or more Users specified by the requested usernames.</para>
        /// </summary>
        /// <param name="usernames">required.</param>
        /// <param name="expansions">optional.</param>
        /// <param name="tweet_fields">optional.</param>
        /// <param name="user_fields">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The Users.</returns>
        public Task<UsersResponse> GetUsersByUsernamesAsync(IEnumerable<string> usernames, UserExpansions? expansions = null, TweetFields? tweet_fields = null, UserFields? user_fields = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(usernames == null) throw new ArgumentNullException("usernames");
            parameters.Add("usernames", usernames);
            if(expansions != null) parameters.Add("expansions", expansions);
            if(tweet_fields != null) parameters.Add("tweet.fields", tweet_fields);
            if(user_fields != null) parameters.Add("user.fields", user_fields);
            return this.Tokens.AccessApiAsync<UsersResponse>(MethodType.Get, "users/by", parameters, cancellationToken, urlPrefix: "2", urlSuffix: "");
        }

    }

}
namespace CoreTweet.Rest
{
}
